<!DOCTYPE HTML>
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc -->
<title>KTable (kafka 3.0.2 API)</title>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="description" content="declaration: package: org.apache.kafka.streams.kstream, interface: KTable">
<meta name="generator" content="javadoc/ClassWriterImpl">
<link rel="stylesheet" type="text/css" href="../../../../../stylesheet.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../../../../script-dir/jquery-ui.min.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../../../../jquery-ui.overrides.css" title="Style">
<script type="text/javascript" src="../../../../../script.js"></script>
<script type="text/javascript" src="../../../../../script-dir/jquery-3.5.1.min.js"></script>
<script type="text/javascript" src="../../../../../script-dir/jquery-ui.min.js"></script>
</head>
<body class="class-declaration-page">
<script type="text/javascript">var data = {"i0":6,"i1":6,"i2":6,"i3":6,"i4":6,"i5":6,"i6":6,"i7":6,"i8":6,"i9":6,"i10":6,"i11":6,"i12":6,"i13":6,"i14":6,"i15":6,"i16":6,"i17":6,"i18":6,"i19":6,"i20":6,"i21":6,"i22":6,"i23":6,"i24":6,"i25":6,"i26":6,"i27":6,"i28":6,"i29":6,"i30":6,"i31":6,"i32":6,"i33":6,"i34":6,"i35":6,"i36":6,"i37":6,"i38":6,"i39":6,"i40":6,"i41":6,"i42":6,"i43":6,"i44":6,"i45":6,"i46":6,"i47":6};
var tabs = {65535:["t0","All Methods"],2:["t2","Instance Methods"],4:["t3","Abstract Methods"]};
var altColor = "alt-color";
var rowColor = "row-color";
var tableTab = "table-tab";
var activeTableTab = "active-table-tab";
var pathtoroot = "../../../../../";
loadScripts(document, 'script');</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<div class="flex-box">
<header role="banner" class="flex-header">
<nav role="navigation">
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="top-nav" id="navbar.top">
<div class="skip-nav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<ul id="navbar.top.firstrow" class="nav-list" title="Navigation">
<li><a href="../../../../../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="nav-bar-cell1-rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../../index-all.html">Index</a></li>
<li><a href="../../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="sub-nav">
<div>
<ul class="sub-nav-list">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="sub-nav-list">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<div class="nav-list-search"><label for="search">SEARCH:</label>
<input type="text" id="search" value="search" disabled="disabled">
<input type="reset" id="reset" value="reset" disabled="disabled">
</div>
</div>
<!-- ========= END OF TOP NAVBAR ========= -->
<span class="skip-nav" id="skip.navbar.top">
<!--   -->
</span></nav>
</header>
<div class="flex-content">
<main role="main">
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="sub-title"><span class="package-label-in-type">Package</span>&nbsp;<a href="package-summary.html">org.apache.kafka.streams.kstream</a></div>
<h1 title="Interface KTable" class="title">Interface KTable&lt;K,&#8203;V&gt;</h1>
</div>
<section class="description">
<dl class="notes">
<dt>Type Parameters:</dt>
<dd><code>K</code> - Type of primary keys</dd>
<dd><code>V</code> - Type of value changes</dd>
</dl>
<hr>
<pre>public interface <span class="type-name-label">KTable&lt;K,&#8203;V&gt;</span></pre>
<div class="block"><code>KTable</code> is an abstraction of a <i>changelog stream</i> from a primary-keyed table.
 Each record in this changelog stream is an update on the primary-keyed table with the record key as the primary key.
 <p>
 A <code>KTable</code> is either <a href="../StreamsBuilder.html#table(java.lang.String)"><code>defined from a single Kafka topic</code></a> that is
 consumed message by message or the result of a <code>KTable</code> transformation.
 An aggregation of a <a href="KStream.html" title="interface in org.apache.kafka.streams.kstream"><code>KStream</code></a> also yields a <code>KTable</code>.
 <p>
 A <code>KTable</code> can be transformed record by record, joined with another <code>KTable</code> or <a href="KStream.html" title="interface in org.apache.kafka.streams.kstream"><code>KStream</code></a>, or
 can be re-partitioned and aggregated into a new <code>KTable</code>.
 <p>
 Some <code>KTable</code>s have an internal state (a <a href="../state/ReadOnlyKeyValueStore.html" title="interface in org.apache.kafka.streams.state"><code>ReadOnlyKeyValueStore</code></a>) and are therefore queryable via the
 interactive queries API.
 For example:
 <pre><code>
     final KTable table = ...
     ...
     final KafkaStreams streams = ...;
     streams.start()
     ...
     final String queryableStoreName = table.queryableStoreName(); // returns null if KTable is not queryable
     ReadOnlyKeyValueStore view = streams.store(queryableStoreName, QueryableStoreTypes.timestampedKeyValueStore());
     view.get(key);
</code></pre>
<p>
 Records from the source topic that have null keys are dropped.</div>
<dl class="notes">
<dt>See Also:</dt>
<dd><a href="KStream.html" title="interface in org.apache.kafka.streams.kstream"><code>KStream</code></a>, 
<a href="KGroupedTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KGroupedTable</code></a>, 
<a href="GlobalKTable.html" title="interface in org.apache.kafka.streams.kstream"><code>GlobalKTable</code></a>, 
<a href="../StreamsBuilder.html#table(java.lang.String)"><code>StreamsBuilder.table(String)</code></a></dd>
</dl>
</section>
<section class="summary">
<ul class="summary-list">
<!-- ========== METHOD SUMMARY =========== -->
<li>
<section class="method-summary" id="method.summary">
<h2>Method Summary</h2>
<div class="member-summary" id="method-summary-table">
<div class="table-tabs" role="tablist" aria-orientation="horizontal"><button role="tab" aria-selected="true" aria-controls="method-summary-table.tabpanel" tabindex="0" onkeydown="switchTab(event)" id="t0" class="active-table-tab">All Methods</button><button role="tab" aria-selected="false" aria-controls="method-summary-table.tabpanel" tabindex="-1" onkeydown="switchTab(event)" id="t2" class="table-tab" onclick="show(2);">Instance Methods</button><button role="tab" aria-selected="false" aria-controls="method-summary-table.tabpanel" tabindex="-1" onkeydown="switchTab(event)" id="t3" class="table-tab" onclick="show(4);">Abstract Methods</button></div>
<div id="method-summary-table.tabpanel" role="tabpanel">
<table class="summary-table" aria-labelledby="t0">
<thead>
<tr>
<th class="col-first" scope="col">Modifier and Type</th>
<th class="col-second" scope="col">Method</th>
<th class="col-last" scope="col">Description</th>
</tr>
</thead>
<tbody>
<tr class="alt-color" id="i0">
<td class="col-first"><code><a href="KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;<a href="KTable.html" title="type parameter in KTable">V</a>&gt;</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#filter(org.apache.kafka.streams.kstream.Predicate)">filter</a></span>&#8203;(<a href="Predicate.html" title="interface in org.apache.kafka.streams.kstream">Predicate</a>&lt;? super <a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;? super <a href="KTable.html" title="type parameter in KTable">V</a>&gt;&nbsp;predicate)</code></th>
<td class="col-last">
<div class="block">Create a new <code>KTable</code> that consists of all records of this <code>KTable</code> which satisfy the given
 predicate, with default serializers, deserializers, and state store.</div>
</td>
</tr>
<tr class="row-color" id="i1">
<td class="col-first"><code><a href="KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;<a href="KTable.html" title="type parameter in KTable">V</a>&gt;</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#filter(org.apache.kafka.streams.kstream.Predicate,org.apache.kafka.streams.kstream.Materialized)">filter</a></span>&#8203;(<a href="Predicate.html" title="interface in org.apache.kafka.streams.kstream">Predicate</a>&lt;? super <a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;? super <a href="KTable.html" title="type parameter in KTable">V</a>&gt;&nbsp;predicate,
<a href="Materialized.html" title="class in org.apache.kafka.streams.kstream">Materialized</a>&lt;<a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;<a href="KTable.html" title="type parameter in KTable">V</a>,&#8203;<a href="../state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state">KeyValueStore</a>&lt;org.apache.kafka.common.utils.Bytes,&#8203;byte[]&gt;&gt;&nbsp;materialized)</code></th>
<td class="col-last">
<div class="block">Create a new <code>KTable</code> that consists of all records of this <code>KTable</code> which satisfy the given
 predicate, with the <a href="../../common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization"><code>key serde</code></a>, <a href="../../common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization"><code>value serde</code></a>, and the underlying
 <a href="../state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state"><code>materialized state storage</code></a> configured in the <a href="Materialized.html" title="class in org.apache.kafka.streams.kstream"><code>Materialized</code></a> instance.</div>
</td>
</tr>
<tr class="alt-color" id="i2">
<td class="col-first"><code><a href="KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;<a href="KTable.html" title="type parameter in KTable">V</a>&gt;</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#filter(org.apache.kafka.streams.kstream.Predicate,org.apache.kafka.streams.kstream.Named)">filter</a></span>&#8203;(<a href="Predicate.html" title="interface in org.apache.kafka.streams.kstream">Predicate</a>&lt;? super <a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;? super <a href="KTable.html" title="type parameter in KTable">V</a>&gt;&nbsp;predicate,
<a href="Named.html" title="class in org.apache.kafka.streams.kstream">Named</a>&nbsp;named)</code></th>
<td class="col-last">
<div class="block">Create a new <code>KTable</code> that consists of all records of this <code>KTable</code> which satisfy the given
 predicate, with default serializers, deserializers, and state store.</div>
</td>
</tr>
<tr class="row-color" id="i3">
<td class="col-first"><code><a href="KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;<a href="KTable.html" title="type parameter in KTable">V</a>&gt;</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#filter(org.apache.kafka.streams.kstream.Predicate,org.apache.kafka.streams.kstream.Named,org.apache.kafka.streams.kstream.Materialized)">filter</a></span>&#8203;(<a href="Predicate.html" title="interface in org.apache.kafka.streams.kstream">Predicate</a>&lt;? super <a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;? super <a href="KTable.html" title="type parameter in KTable">V</a>&gt;&nbsp;predicate,
<a href="Named.html" title="class in org.apache.kafka.streams.kstream">Named</a>&nbsp;named,
<a href="Materialized.html" title="class in org.apache.kafka.streams.kstream">Materialized</a>&lt;<a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;<a href="KTable.html" title="type parameter in KTable">V</a>,&#8203;<a href="../state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state">KeyValueStore</a>&lt;org.apache.kafka.common.utils.Bytes,&#8203;byte[]&gt;&gt;&nbsp;materialized)</code></th>
<td class="col-last">
<div class="block">Create a new <code>KTable</code> that consists of all records of this <code>KTable</code> which satisfy the given
 predicate, with the <a href="../../common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization"><code>key serde</code></a>, <a href="../../common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization"><code>value serde</code></a>, and the underlying
 <a href="../state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state"><code>materialized state storage</code></a> configured in the <a href="Materialized.html" title="class in org.apache.kafka.streams.kstream"><code>Materialized</code></a> instance.</div>
</td>
</tr>
<tr class="alt-color" id="i4">
<td class="col-first"><code><a href="KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;<a href="KTable.html" title="type parameter in KTable">V</a>&gt;</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#filterNot(org.apache.kafka.streams.kstream.Predicate)">filterNot</a></span>&#8203;(<a href="Predicate.html" title="interface in org.apache.kafka.streams.kstream">Predicate</a>&lt;? super <a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;? super <a href="KTable.html" title="type parameter in KTable">V</a>&gt;&nbsp;predicate)</code></th>
<td class="col-last">
<div class="block">Create a new <code>KTable</code> that consists all records of this <code>KTable</code> which do <em>not</em> satisfy the
 given predicate, with default serializers, deserializers, and state store.</div>
</td>
</tr>
<tr class="row-color" id="i5">
<td class="col-first"><code><a href="KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;<a href="KTable.html" title="type parameter in KTable">V</a>&gt;</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#filterNot(org.apache.kafka.streams.kstream.Predicate,org.apache.kafka.streams.kstream.Materialized)">filterNot</a></span>&#8203;(<a href="Predicate.html" title="interface in org.apache.kafka.streams.kstream">Predicate</a>&lt;? super <a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;? super <a href="KTable.html" title="type parameter in KTable">V</a>&gt;&nbsp;predicate,
<a href="Materialized.html" title="class in org.apache.kafka.streams.kstream">Materialized</a>&lt;<a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;<a href="KTable.html" title="type parameter in KTable">V</a>,&#8203;<a href="../state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state">KeyValueStore</a>&lt;org.apache.kafka.common.utils.Bytes,&#8203;byte[]&gt;&gt;&nbsp;materialized)</code></th>
<td class="col-last">
<div class="block">Create a new <code>KTable</code> that consists all records of this <code>KTable</code> which do <em>not</em> satisfy the
 given predicate, with the <a href="../../common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization"><code>key serde</code></a>, <a href="../../common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization"><code>value serde</code></a>, and the underlying
 <a href="../state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state"><code>materialized state storage</code></a> configured in the <a href="Materialized.html" title="class in org.apache.kafka.streams.kstream"><code>Materialized</code></a> instance.</div>
</td>
</tr>
<tr class="alt-color" id="i6">
<td class="col-first"><code><a href="KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;<a href="KTable.html" title="type parameter in KTable">V</a>&gt;</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#filterNot(org.apache.kafka.streams.kstream.Predicate,org.apache.kafka.streams.kstream.Named)">filterNot</a></span>&#8203;(<a href="Predicate.html" title="interface in org.apache.kafka.streams.kstream">Predicate</a>&lt;? super <a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;? super <a href="KTable.html" title="type parameter in KTable">V</a>&gt;&nbsp;predicate,
<a href="Named.html" title="class in org.apache.kafka.streams.kstream">Named</a>&nbsp;named)</code></th>
<td class="col-last">
<div class="block">Create a new <code>KTable</code> that consists all records of this <code>KTable</code> which do <em>not</em> satisfy the
 given predicate, with default serializers, deserializers, and state store.</div>
</td>
</tr>
<tr class="row-color" id="i7">
<td class="col-first"><code><a href="KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;<a href="KTable.html" title="type parameter in KTable">V</a>&gt;</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#filterNot(org.apache.kafka.streams.kstream.Predicate,org.apache.kafka.streams.kstream.Named,org.apache.kafka.streams.kstream.Materialized)">filterNot</a></span>&#8203;(<a href="Predicate.html" title="interface in org.apache.kafka.streams.kstream">Predicate</a>&lt;? super <a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;? super <a href="KTable.html" title="type parameter in KTable">V</a>&gt;&nbsp;predicate,
<a href="Named.html" title="class in org.apache.kafka.streams.kstream">Named</a>&nbsp;named,
<a href="Materialized.html" title="class in org.apache.kafka.streams.kstream">Materialized</a>&lt;<a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;<a href="KTable.html" title="type parameter in KTable">V</a>,&#8203;<a href="../state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state">KeyValueStore</a>&lt;org.apache.kafka.common.utils.Bytes,&#8203;byte[]&gt;&gt;&nbsp;materialized)</code></th>
<td class="col-last">
<div class="block">Create a new <code>KTable</code> that consists all records of this <code>KTable</code> which do <em>not</em> satisfy the
 given predicate, with the <a href="../../common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization"><code>key serde</code></a>, <a href="../../common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization"><code>value serde</code></a>, and the underlying
 <a href="../state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state"><code>materialized state storage</code></a> configured in the <a href="Materialized.html" title="class in org.apache.kafka.streams.kstream"><code>Materialized</code></a> instance.</div>
</td>
</tr>
<tr class="alt-color" id="i8">
<td class="col-first"><code>&lt;KR,&#8203;
VR&gt;&nbsp;<a href="KGroupedTable.html" title="interface in org.apache.kafka.streams.kstream">KGroupedTable</a>&lt;KR,&#8203;VR&gt;</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#groupBy(org.apache.kafka.streams.kstream.KeyValueMapper)">groupBy</a></span>&#8203;(<a href="KeyValueMapper.html" title="interface in org.apache.kafka.streams.kstream">KeyValueMapper</a>&lt;? super <a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;? super <a href="KTable.html" title="type parameter in KTable">V</a>,&#8203;<a href="../KeyValue.html" title="class in org.apache.kafka.streams">KeyValue</a>&lt;KR,&#8203;VR&gt;&gt;&nbsp;selector)</code></th>
<td class="col-last">
<div class="block">Re-groups the records of this <code>KTable</code> using the provided <a href="KeyValueMapper.html" title="interface in org.apache.kafka.streams.kstream"><code>KeyValueMapper</code></a> and default serializers
 and deserializers.</div>
</td>
</tr>
<tr class="row-color" id="i9">
<td class="col-first"><code>&lt;KR,&#8203;
VR&gt;&nbsp;<a href="KGroupedTable.html" title="interface in org.apache.kafka.streams.kstream">KGroupedTable</a>&lt;KR,&#8203;VR&gt;</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#groupBy(org.apache.kafka.streams.kstream.KeyValueMapper,org.apache.kafka.streams.kstream.Grouped)">groupBy</a></span>&#8203;(<a href="KeyValueMapper.html" title="interface in org.apache.kafka.streams.kstream">KeyValueMapper</a>&lt;? super <a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;? super <a href="KTable.html" title="type parameter in KTable">V</a>,&#8203;<a href="../KeyValue.html" title="class in org.apache.kafka.streams">KeyValue</a>&lt;KR,&#8203;VR&gt;&gt;&nbsp;selector,
<a href="Grouped.html" title="class in org.apache.kafka.streams.kstream">Grouped</a>&lt;KR,&#8203;VR&gt;&nbsp;grouped)</code></th>
<td class="col-last">
<div class="block">Re-groups the records of this <code>KTable</code> using the provided <a href="KeyValueMapper.html" title="interface in org.apache.kafka.streams.kstream"><code>KeyValueMapper</code></a>
 and <a href="../../common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization"><code>Serde</code></a>s as specified by <a href="Grouped.html" title="class in org.apache.kafka.streams.kstream"><code>Grouped</code></a>.</div>
</td>
</tr>
<tr class="alt-color" id="i10">
<td class="col-first"><code>&lt;VO,&#8203;
VR&gt;&nbsp;<a href="KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;VR&gt;</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#join(org.apache.kafka.streams.kstream.KTable,org.apache.kafka.streams.kstream.ValueJoiner)">join</a></span>&#8203;(<a href="KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;VO&gt;&nbsp;other,
<a href="ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream">ValueJoiner</a>&lt;? super <a href="KTable.html" title="type parameter in KTable">V</a>,&#8203;? super VO,&#8203;? extends VR&gt;&nbsp;joiner)</code></th>
<td class="col-last">
<div class="block">Join records of this <code>KTable</code> with another <code>KTable</code>'s records using non-windowed inner equi join,
 with default serializers, deserializers, and state store.</div>
</td>
</tr>
<tr class="row-color" id="i11">
<td class="col-first"><code>&lt;VO,&#8203;
VR&gt;&nbsp;<a href="KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;VR&gt;</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#join(org.apache.kafka.streams.kstream.KTable,org.apache.kafka.streams.kstream.ValueJoiner,org.apache.kafka.streams.kstream.Materialized)">join</a></span>&#8203;(<a href="KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;VO&gt;&nbsp;other,
<a href="ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream">ValueJoiner</a>&lt;? super <a href="KTable.html" title="type parameter in KTable">V</a>,&#8203;? super VO,&#8203;? extends VR&gt;&nbsp;joiner,
<a href="Materialized.html" title="class in org.apache.kafka.streams.kstream">Materialized</a>&lt;<a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;VR,&#8203;<a href="../state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state">KeyValueStore</a>&lt;org.apache.kafka.common.utils.Bytes,&#8203;byte[]&gt;&gt;&nbsp;materialized)</code></th>
<td class="col-last">
<div class="block">Join records of this <code>KTable</code> with another <code>KTable</code>'s records using non-windowed inner equi join,
 with the <a href="Materialized.html" title="class in org.apache.kafka.streams.kstream"><code>Materialized</code></a> instance for configuration of the <a href="../../common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization"><code>key serde</code></a>,
 <a href="../../common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization"><code>the result table's value serde</code></a>, and <a href="../state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state"><code>state store</code></a>.</div>
</td>
</tr>
<tr class="alt-color" id="i12">
<td class="col-first"><code>&lt;VO,&#8203;
VR&gt;&nbsp;<a href="KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;VR&gt;</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#join(org.apache.kafka.streams.kstream.KTable,org.apache.kafka.streams.kstream.ValueJoiner,org.apache.kafka.streams.kstream.Named)">join</a></span>&#8203;(<a href="KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;VO&gt;&nbsp;other,
<a href="ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream">ValueJoiner</a>&lt;? super <a href="KTable.html" title="type parameter in KTable">V</a>,&#8203;? super VO,&#8203;? extends VR&gt;&nbsp;joiner,
<a href="Named.html" title="class in org.apache.kafka.streams.kstream">Named</a>&nbsp;named)</code></th>
<td class="col-last">
<div class="block">Join records of this <code>KTable</code> with another <code>KTable</code>'s records using non-windowed inner equi join,
 with default serializers, deserializers, and state store.</div>
</td>
</tr>
<tr class="row-color" id="i13">
<td class="col-first"><code>&lt;VO,&#8203;
VR&gt;&nbsp;<a href="KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;VR&gt;</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#join(org.apache.kafka.streams.kstream.KTable,org.apache.kafka.streams.kstream.ValueJoiner,org.apache.kafka.streams.kstream.Named,org.apache.kafka.streams.kstream.Materialized)">join</a></span>&#8203;(<a href="KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;VO&gt;&nbsp;other,
<a href="ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream">ValueJoiner</a>&lt;? super <a href="KTable.html" title="type parameter in KTable">V</a>,&#8203;? super VO,&#8203;? extends VR&gt;&nbsp;joiner,
<a href="Named.html" title="class in org.apache.kafka.streams.kstream">Named</a>&nbsp;named,
<a href="Materialized.html" title="class in org.apache.kafka.streams.kstream">Materialized</a>&lt;<a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;VR,&#8203;<a href="../state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state">KeyValueStore</a>&lt;org.apache.kafka.common.utils.Bytes,&#8203;byte[]&gt;&gt;&nbsp;materialized)</code></th>
<td class="col-last">
<div class="block">Join records of this <code>KTable</code> with another <code>KTable</code>'s records using non-windowed inner equi join,
 with the <a href="Materialized.html" title="class in org.apache.kafka.streams.kstream"><code>Materialized</code></a> instance for configuration of the <a href="../../common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization"><code>key serde</code></a>,
 <a href="../../common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization"><code>the result table's value serde</code></a>, and <a href="../state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state"><code>state store</code></a>.</div>
</td>
</tr>
<tr class="alt-color" id="i14">
<td class="col-first"><code>&lt;VR,&#8203;
KO,&#8203;
VO&gt;&nbsp;<a href="KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;VR&gt;</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#join(org.apache.kafka.streams.kstream.KTable,java.util.function.Function,org.apache.kafka.streams.kstream.ValueJoiner)">join</a></span>&#8203;(<a href="KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;KO,&#8203;VO&gt;&nbsp;other,
<a href="https://docs.oracle.com/en/java/javase/15/docs/api/java.base/java/util/function/Function.html" title="class or interface in java.util.function" class="external-link">Function</a>&lt;<a href="KTable.html" title="type parameter in KTable">V</a>,&#8203;KO&gt;&nbsp;foreignKeyExtractor,
<a href="ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream">ValueJoiner</a>&lt;<a href="KTable.html" title="type parameter in KTable">V</a>,&#8203;VO,&#8203;VR&gt;&nbsp;joiner)</code></th>
<td class="col-last">
<div class="block">Join records of this <code>KTable</code> with another <code>KTable</code> using non-windowed inner join.</div>
</td>
</tr>
<tr class="row-color" id="i15">
<td class="col-first"><code>&lt;VR,&#8203;
KO,&#8203;
VO&gt;&nbsp;<a href="KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;VR&gt;</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#join(org.apache.kafka.streams.kstream.KTable,java.util.function.Function,org.apache.kafka.streams.kstream.ValueJoiner,org.apache.kafka.streams.kstream.Materialized)">join</a></span>&#8203;(<a href="KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;KO,&#8203;VO&gt;&nbsp;other,
<a href="https://docs.oracle.com/en/java/javase/15/docs/api/java.base/java/util/function/Function.html" title="class or interface in java.util.function" class="external-link">Function</a>&lt;<a href="KTable.html" title="type parameter in KTable">V</a>,&#8203;KO&gt;&nbsp;foreignKeyExtractor,
<a href="ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream">ValueJoiner</a>&lt;<a href="KTable.html" title="type parameter in KTable">V</a>,&#8203;VO,&#8203;VR&gt;&nbsp;joiner,
<a href="Materialized.html" title="class in org.apache.kafka.streams.kstream">Materialized</a>&lt;<a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;VR,&#8203;<a href="../state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state">KeyValueStore</a>&lt;org.apache.kafka.common.utils.Bytes,&#8203;byte[]&gt;&gt;&nbsp;materialized)</code></th>
<td class="col-last">
<div class="block">Join records of this <code>KTable</code> with another <code>KTable</code> using non-windowed inner join.</div>
</td>
</tr>
<tr class="alt-color" id="i16">
<td class="col-first"><code>&lt;VR,&#8203;
KO,&#8203;
VO&gt;&nbsp;<a href="KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;VR&gt;</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#join(org.apache.kafka.streams.kstream.KTable,java.util.function.Function,org.apache.kafka.streams.kstream.ValueJoiner,org.apache.kafka.streams.kstream.Named)">join</a></span>&#8203;(<a href="KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;KO,&#8203;VO&gt;&nbsp;other,
<a href="https://docs.oracle.com/en/java/javase/15/docs/api/java.base/java/util/function/Function.html" title="class or interface in java.util.function" class="external-link">Function</a>&lt;<a href="KTable.html" title="type parameter in KTable">V</a>,&#8203;KO&gt;&nbsp;foreignKeyExtractor,
<a href="ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream">ValueJoiner</a>&lt;<a href="KTable.html" title="type parameter in KTable">V</a>,&#8203;VO,&#8203;VR&gt;&nbsp;joiner,
<a href="Named.html" title="class in org.apache.kafka.streams.kstream">Named</a>&nbsp;named)</code></th>
<td class="col-last">
<div class="block">Join records of this <code>KTable</code> with another <code>KTable</code> using non-windowed inner join.</div>
</td>
</tr>
<tr class="row-color" id="i17">
<td class="col-first"><code>&lt;VR,&#8203;
KO,&#8203;
VO&gt;&nbsp;<a href="KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;VR&gt;</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#join(org.apache.kafka.streams.kstream.KTable,java.util.function.Function,org.apache.kafka.streams.kstream.ValueJoiner,org.apache.kafka.streams.kstream.Named,org.apache.kafka.streams.kstream.Materialized)">join</a></span>&#8203;(<a href="KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;KO,&#8203;VO&gt;&nbsp;other,
<a href="https://docs.oracle.com/en/java/javase/15/docs/api/java.base/java/util/function/Function.html" title="class or interface in java.util.function" class="external-link">Function</a>&lt;<a href="KTable.html" title="type parameter in KTable">V</a>,&#8203;KO&gt;&nbsp;foreignKeyExtractor,
<a href="ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream">ValueJoiner</a>&lt;<a href="KTable.html" title="type parameter in KTable">V</a>,&#8203;VO,&#8203;VR&gt;&nbsp;joiner,
<a href="Named.html" title="class in org.apache.kafka.streams.kstream">Named</a>&nbsp;named,
<a href="Materialized.html" title="class in org.apache.kafka.streams.kstream">Materialized</a>&lt;<a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;VR,&#8203;<a href="../state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state">KeyValueStore</a>&lt;org.apache.kafka.common.utils.Bytes,&#8203;byte[]&gt;&gt;&nbsp;materialized)</code></th>
<td class="col-last">
<div class="block">Join records of this <code>KTable</code> with another <code>KTable</code> using non-windowed inner join.</div>
</td>
</tr>
<tr class="alt-color" id="i18">
<td class="col-first"><code>&lt;VO,&#8203;
VR&gt;&nbsp;<a href="KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;VR&gt;</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#leftJoin(org.apache.kafka.streams.kstream.KTable,org.apache.kafka.streams.kstream.ValueJoiner)">leftJoin</a></span>&#8203;(<a href="KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;VO&gt;&nbsp;other,
<a href="ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream">ValueJoiner</a>&lt;? super <a href="KTable.html" title="type parameter in KTable">V</a>,&#8203;? super VO,&#8203;? extends VR&gt;&nbsp;joiner)</code></th>
<td class="col-last">
<div class="block">Join records of this <code>KTable</code> (left input) with another <code>KTable</code>'s (right input) records using
 non-windowed left equi join, with default serializers, deserializers, and state store.</div>
</td>
</tr>
<tr class="row-color" id="i19">
<td class="col-first"><code>&lt;VO,&#8203;
VR&gt;&nbsp;<a href="KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;VR&gt;</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#leftJoin(org.apache.kafka.streams.kstream.KTable,org.apache.kafka.streams.kstream.ValueJoiner,org.apache.kafka.streams.kstream.Materialized)">leftJoin</a></span>&#8203;(<a href="KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;VO&gt;&nbsp;other,
<a href="ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream">ValueJoiner</a>&lt;? super <a href="KTable.html" title="type parameter in KTable">V</a>,&#8203;? super VO,&#8203;? extends VR&gt;&nbsp;joiner,
<a href="Materialized.html" title="class in org.apache.kafka.streams.kstream">Materialized</a>&lt;<a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;VR,&#8203;<a href="../state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state">KeyValueStore</a>&lt;org.apache.kafka.common.utils.Bytes,&#8203;byte[]&gt;&gt;&nbsp;materialized)</code></th>
<td class="col-last">
<div class="block">Join records of this <code>KTable</code> (left input) with another <code>KTable</code>'s (right input) records using
 non-windowed left equi join, with the <a href="Materialized.html" title="class in org.apache.kafka.streams.kstream"><code>Materialized</code></a> instance for configuration of the <a href="../../common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization"><code>key serde</code></a>,
 <a href="../../common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization"><code>the result table's value serde</code></a>, and <a href="../state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state"><code>state store</code></a>.</div>
</td>
</tr>
<tr class="alt-color" id="i20">
<td class="col-first"><code>&lt;VO,&#8203;
VR&gt;&nbsp;<a href="KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;VR&gt;</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#leftJoin(org.apache.kafka.streams.kstream.KTable,org.apache.kafka.streams.kstream.ValueJoiner,org.apache.kafka.streams.kstream.Named)">leftJoin</a></span>&#8203;(<a href="KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;VO&gt;&nbsp;other,
<a href="ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream">ValueJoiner</a>&lt;? super <a href="KTable.html" title="type parameter in KTable">V</a>,&#8203;? super VO,&#8203;? extends VR&gt;&nbsp;joiner,
<a href="Named.html" title="class in org.apache.kafka.streams.kstream">Named</a>&nbsp;named)</code></th>
<td class="col-last">
<div class="block">Join records of this <code>KTable</code> (left input) with another <code>KTable</code>'s (right input) records using
 non-windowed left equi join, with default serializers, deserializers, and state store.</div>
</td>
</tr>
<tr class="row-color" id="i21">
<td class="col-first"><code>&lt;VO,&#8203;
VR&gt;&nbsp;<a href="KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;VR&gt;</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#leftJoin(org.apache.kafka.streams.kstream.KTable,org.apache.kafka.streams.kstream.ValueJoiner,org.apache.kafka.streams.kstream.Named,org.apache.kafka.streams.kstream.Materialized)">leftJoin</a></span>&#8203;(<a href="KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;VO&gt;&nbsp;other,
<a href="ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream">ValueJoiner</a>&lt;? super <a href="KTable.html" title="type parameter in KTable">V</a>,&#8203;? super VO,&#8203;? extends VR&gt;&nbsp;joiner,
<a href="Named.html" title="class in org.apache.kafka.streams.kstream">Named</a>&nbsp;named,
<a href="Materialized.html" title="class in org.apache.kafka.streams.kstream">Materialized</a>&lt;<a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;VR,&#8203;<a href="../state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state">KeyValueStore</a>&lt;org.apache.kafka.common.utils.Bytes,&#8203;byte[]&gt;&gt;&nbsp;materialized)</code></th>
<td class="col-last">
<div class="block">Join records of this <code>KTable</code> (left input) with another <code>KTable</code>'s (right input) records using
 non-windowed left equi join, with the <a href="Materialized.html" title="class in org.apache.kafka.streams.kstream"><code>Materialized</code></a> instance for configuration of the <a href="../../common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization"><code>key serde</code></a>,
 <a href="../../common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization"><code>the result table's value serde</code></a>, and <a href="../state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state"><code>state store</code></a>.</div>
</td>
</tr>
<tr class="alt-color" id="i22">
<td class="col-first"><code>&lt;VR,&#8203;
KO,&#8203;
VO&gt;&nbsp;<a href="KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;VR&gt;</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#leftJoin(org.apache.kafka.streams.kstream.KTable,java.util.function.Function,org.apache.kafka.streams.kstream.ValueJoiner)">leftJoin</a></span>&#8203;(<a href="KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;KO,&#8203;VO&gt;&nbsp;other,
<a href="https://docs.oracle.com/en/java/javase/15/docs/api/java.base/java/util/function/Function.html" title="class or interface in java.util.function" class="external-link">Function</a>&lt;<a href="KTable.html" title="type parameter in KTable">V</a>,&#8203;KO&gt;&nbsp;foreignKeyExtractor,
<a href="ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream">ValueJoiner</a>&lt;<a href="KTable.html" title="type parameter in KTable">V</a>,&#8203;VO,&#8203;VR&gt;&nbsp;joiner)</code></th>
<td class="col-last">
<div class="block">Join records of this <code>KTable</code> with another <code>KTable</code> using non-windowed left join.</div>
</td>
</tr>
<tr class="row-color" id="i23">
<td class="col-first"><code>&lt;VR,&#8203;
KO,&#8203;
VO&gt;&nbsp;<a href="KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;VR&gt;</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#leftJoin(org.apache.kafka.streams.kstream.KTable,java.util.function.Function,org.apache.kafka.streams.kstream.ValueJoiner,org.apache.kafka.streams.kstream.Materialized)">leftJoin</a></span>&#8203;(<a href="KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;KO,&#8203;VO&gt;&nbsp;other,
<a href="https://docs.oracle.com/en/java/javase/15/docs/api/java.base/java/util/function/Function.html" title="class or interface in java.util.function" class="external-link">Function</a>&lt;<a href="KTable.html" title="type parameter in KTable">V</a>,&#8203;KO&gt;&nbsp;foreignKeyExtractor,
<a href="ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream">ValueJoiner</a>&lt;<a href="KTable.html" title="type parameter in KTable">V</a>,&#8203;VO,&#8203;VR&gt;&nbsp;joiner,
<a href="Materialized.html" title="class in org.apache.kafka.streams.kstream">Materialized</a>&lt;<a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;VR,&#8203;<a href="../state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state">KeyValueStore</a>&lt;org.apache.kafka.common.utils.Bytes,&#8203;byte[]&gt;&gt;&nbsp;materialized)</code></th>
<td class="col-last">
<div class="block">Join records of this <code>KTable</code> with another <code>KTable</code> using non-windowed left join.</div>
</td>
</tr>
<tr class="alt-color" id="i24">
<td class="col-first"><code>&lt;VR,&#8203;
KO,&#8203;
VO&gt;&nbsp;<a href="KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;VR&gt;</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#leftJoin(org.apache.kafka.streams.kstream.KTable,java.util.function.Function,org.apache.kafka.streams.kstream.ValueJoiner,org.apache.kafka.streams.kstream.Named)">leftJoin</a></span>&#8203;(<a href="KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;KO,&#8203;VO&gt;&nbsp;other,
<a href="https://docs.oracle.com/en/java/javase/15/docs/api/java.base/java/util/function/Function.html" title="class or interface in java.util.function" class="external-link">Function</a>&lt;<a href="KTable.html" title="type parameter in KTable">V</a>,&#8203;KO&gt;&nbsp;foreignKeyExtractor,
<a href="ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream">ValueJoiner</a>&lt;<a href="KTable.html" title="type parameter in KTable">V</a>,&#8203;VO,&#8203;VR&gt;&nbsp;joiner,
<a href="Named.html" title="class in org.apache.kafka.streams.kstream">Named</a>&nbsp;named)</code></th>
<td class="col-last">
<div class="block">Join records of this <code>KTable</code> with another <code>KTable</code> using non-windowed left join.</div>
</td>
</tr>
<tr class="row-color" id="i25">
<td class="col-first"><code>&lt;VR,&#8203;
KO,&#8203;
VO&gt;&nbsp;<a href="KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;VR&gt;</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#leftJoin(org.apache.kafka.streams.kstream.KTable,java.util.function.Function,org.apache.kafka.streams.kstream.ValueJoiner,org.apache.kafka.streams.kstream.Named,org.apache.kafka.streams.kstream.Materialized)">leftJoin</a></span>&#8203;(<a href="KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;KO,&#8203;VO&gt;&nbsp;other,
<a href="https://docs.oracle.com/en/java/javase/15/docs/api/java.base/java/util/function/Function.html" title="class or interface in java.util.function" class="external-link">Function</a>&lt;<a href="KTable.html" title="type parameter in KTable">V</a>,&#8203;KO&gt;&nbsp;foreignKeyExtractor,
<a href="ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream">ValueJoiner</a>&lt;<a href="KTable.html" title="type parameter in KTable">V</a>,&#8203;VO,&#8203;VR&gt;&nbsp;joiner,
<a href="Named.html" title="class in org.apache.kafka.streams.kstream">Named</a>&nbsp;named,
<a href="Materialized.html" title="class in org.apache.kafka.streams.kstream">Materialized</a>&lt;<a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;VR,&#8203;<a href="../state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state">KeyValueStore</a>&lt;org.apache.kafka.common.utils.Bytes,&#8203;byte[]&gt;&gt;&nbsp;materialized)</code></th>
<td class="col-last">
<div class="block">Join records of this <code>KTable</code> with another <code>KTable</code> using non-windowed left join.</div>
</td>
</tr>
<tr class="alt-color" id="i26">
<td class="col-first"><code>&lt;VR&gt;&nbsp;<a href="KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;VR&gt;</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#mapValues(org.apache.kafka.streams.kstream.ValueMapper)">mapValues</a></span>&#8203;(<a href="ValueMapper.html" title="interface in org.apache.kafka.streams.kstream">ValueMapper</a>&lt;? super <a href="KTable.html" title="type parameter in KTable">V</a>,&#8203;? extends VR&gt;&nbsp;mapper)</code></th>
<td class="col-last">
<div class="block">Create a new <code>KTable</code> by transforming the value of each record in this <code>KTable</code> into a new value
 (with possibly a new type) in the new <code>KTable</code>, with default serializers, deserializers, and state store.</div>
</td>
</tr>
<tr class="row-color" id="i27">
<td class="col-first"><code>&lt;VR&gt;&nbsp;<a href="KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;VR&gt;</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#mapValues(org.apache.kafka.streams.kstream.ValueMapper,org.apache.kafka.streams.kstream.Materialized)">mapValues</a></span>&#8203;(<a href="ValueMapper.html" title="interface in org.apache.kafka.streams.kstream">ValueMapper</a>&lt;? super <a href="KTable.html" title="type parameter in KTable">V</a>,&#8203;? extends VR&gt;&nbsp;mapper,
<a href="Materialized.html" title="class in org.apache.kafka.streams.kstream">Materialized</a>&lt;<a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;VR,&#8203;<a href="../state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state">KeyValueStore</a>&lt;org.apache.kafka.common.utils.Bytes,&#8203;byte[]&gt;&gt;&nbsp;materialized)</code></th>
<td class="col-last">
<div class="block">Create a new <code>KTable</code> by transforming the value of each record in this <code>KTable</code> into a new value
 (with possibly a new type) in the new <code>KTable</code>, with the <a href="../../common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization"><code>key serde</code></a>, <a href="../../common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization"><code>value serde</code></a>,
 and the underlying <a href="../state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state"><code>materialized state storage</code></a> configured in the <a href="Materialized.html" title="class in org.apache.kafka.streams.kstream"><code>Materialized</code></a>
 instance.</div>
</td>
</tr>
<tr class="alt-color" id="i28">
<td class="col-first"><code>&lt;VR&gt;&nbsp;<a href="KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;VR&gt;</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#mapValues(org.apache.kafka.streams.kstream.ValueMapper,org.apache.kafka.streams.kstream.Named)">mapValues</a></span>&#8203;(<a href="ValueMapper.html" title="interface in org.apache.kafka.streams.kstream">ValueMapper</a>&lt;? super <a href="KTable.html" title="type parameter in KTable">V</a>,&#8203;? extends VR&gt;&nbsp;mapper,
<a href="Named.html" title="class in org.apache.kafka.streams.kstream">Named</a>&nbsp;named)</code></th>
<td class="col-last">
<div class="block">Create a new <code>KTable</code> by transforming the value of each record in this <code>KTable</code> into a new value
 (with possibly a new type) in the new <code>KTable</code>, with default serializers, deserializers, and state store.</div>
</td>
</tr>
<tr class="row-color" id="i29">
<td class="col-first"><code>&lt;VR&gt;&nbsp;<a href="KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;VR&gt;</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#mapValues(org.apache.kafka.streams.kstream.ValueMapper,org.apache.kafka.streams.kstream.Named,org.apache.kafka.streams.kstream.Materialized)">mapValues</a></span>&#8203;(<a href="ValueMapper.html" title="interface in org.apache.kafka.streams.kstream">ValueMapper</a>&lt;? super <a href="KTable.html" title="type parameter in KTable">V</a>,&#8203;? extends VR&gt;&nbsp;mapper,
<a href="Named.html" title="class in org.apache.kafka.streams.kstream">Named</a>&nbsp;named,
<a href="Materialized.html" title="class in org.apache.kafka.streams.kstream">Materialized</a>&lt;<a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;VR,&#8203;<a href="../state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state">KeyValueStore</a>&lt;org.apache.kafka.common.utils.Bytes,&#8203;byte[]&gt;&gt;&nbsp;materialized)</code></th>
<td class="col-last">
<div class="block">Create a new <code>KTable</code> by transforming the value of each record in this <code>KTable</code> into a new value
 (with possibly a new type) in the new <code>KTable</code>, with the <a href="../../common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization"><code>key serde</code></a>, <a href="../../common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization"><code>value serde</code></a>,
 and the underlying <a href="../state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state"><code>materialized state storage</code></a> configured in the <a href="Materialized.html" title="class in org.apache.kafka.streams.kstream"><code>Materialized</code></a>
 instance.</div>
</td>
</tr>
<tr class="alt-color" id="i30">
<td class="col-first"><code>&lt;VR&gt;&nbsp;<a href="KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;VR&gt;</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#mapValues(org.apache.kafka.streams.kstream.ValueMapperWithKey)">mapValues</a></span>&#8203;(<a href="ValueMapperWithKey.html" title="interface in org.apache.kafka.streams.kstream">ValueMapperWithKey</a>&lt;? super <a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;? super <a href="KTable.html" title="type parameter in KTable">V</a>,&#8203;? extends VR&gt;&nbsp;mapper)</code></th>
<td class="col-last">
<div class="block">Create a new <code>KTable</code> by transforming the value of each record in this <code>KTable</code> into a new value
 (with possibly a new type) in the new <code>KTable</code>, with default serializers, deserializers, and state store.</div>
</td>
</tr>
<tr class="row-color" id="i31">
<td class="col-first"><code>&lt;VR&gt;&nbsp;<a href="KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;VR&gt;</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#mapValues(org.apache.kafka.streams.kstream.ValueMapperWithKey,org.apache.kafka.streams.kstream.Materialized)">mapValues</a></span>&#8203;(<a href="ValueMapperWithKey.html" title="interface in org.apache.kafka.streams.kstream">ValueMapperWithKey</a>&lt;? super <a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;? super <a href="KTable.html" title="type parameter in KTable">V</a>,&#8203;? extends VR&gt;&nbsp;mapper,
<a href="Materialized.html" title="class in org.apache.kafka.streams.kstream">Materialized</a>&lt;<a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;VR,&#8203;<a href="../state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state">KeyValueStore</a>&lt;org.apache.kafka.common.utils.Bytes,&#8203;byte[]&gt;&gt;&nbsp;materialized)</code></th>
<td class="col-last">
<div class="block">Create a new <code>KTable</code> by transforming the value of each record in this <code>KTable</code> into a new value
 (with possibly a new type) in the new <code>KTable</code>, with the <a href="../../common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization"><code>key serde</code></a>, <a href="../../common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization"><code>value serde</code></a>,
 and the underlying <a href="../state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state"><code>materialized state storage</code></a> configured in the <a href="Materialized.html" title="class in org.apache.kafka.streams.kstream"><code>Materialized</code></a>
 instance.</div>
</td>
</tr>
<tr class="alt-color" id="i32">
<td class="col-first"><code>&lt;VR&gt;&nbsp;<a href="KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;VR&gt;</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#mapValues(org.apache.kafka.streams.kstream.ValueMapperWithKey,org.apache.kafka.streams.kstream.Named)">mapValues</a></span>&#8203;(<a href="ValueMapperWithKey.html" title="interface in org.apache.kafka.streams.kstream">ValueMapperWithKey</a>&lt;? super <a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;? super <a href="KTable.html" title="type parameter in KTable">V</a>,&#8203;? extends VR&gt;&nbsp;mapper,
<a href="Named.html" title="class in org.apache.kafka.streams.kstream">Named</a>&nbsp;named)</code></th>
<td class="col-last">
<div class="block">Create a new <code>KTable</code> by transforming the value of each record in this <code>KTable</code> into a new value
 (with possibly a new type) in the new <code>KTable</code>, with default serializers, deserializers, and state store.</div>
</td>
</tr>
<tr class="row-color" id="i33">
<td class="col-first"><code>&lt;VR&gt;&nbsp;<a href="KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;VR&gt;</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#mapValues(org.apache.kafka.streams.kstream.ValueMapperWithKey,org.apache.kafka.streams.kstream.Named,org.apache.kafka.streams.kstream.Materialized)">mapValues</a></span>&#8203;(<a href="ValueMapperWithKey.html" title="interface in org.apache.kafka.streams.kstream">ValueMapperWithKey</a>&lt;? super <a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;? super <a href="KTable.html" title="type parameter in KTable">V</a>,&#8203;? extends VR&gt;&nbsp;mapper,
<a href="Named.html" title="class in org.apache.kafka.streams.kstream">Named</a>&nbsp;named,
<a href="Materialized.html" title="class in org.apache.kafka.streams.kstream">Materialized</a>&lt;<a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;VR,&#8203;<a href="../state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state">KeyValueStore</a>&lt;org.apache.kafka.common.utils.Bytes,&#8203;byte[]&gt;&gt;&nbsp;materialized)</code></th>
<td class="col-last">
<div class="block">Create a new <code>KTable</code> by transforming the value of each record in this <code>KTable</code> into a new value
 (with possibly a new type) in the new <code>KTable</code>, with the <a href="../../common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization"><code>key serde</code></a>, <a href="../../common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization"><code>value serde</code></a>,
 and the underlying <a href="../state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state"><code>materialized state storage</code></a> configured in the <a href="Materialized.html" title="class in org.apache.kafka.streams.kstream"><code>Materialized</code></a>
 instance.</div>
</td>
</tr>
<tr class="alt-color" id="i34">
<td class="col-first"><code>&lt;VO,&#8203;
VR&gt;&nbsp;<a href="KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;VR&gt;</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#outerJoin(org.apache.kafka.streams.kstream.KTable,org.apache.kafka.streams.kstream.ValueJoiner)">outerJoin</a></span>&#8203;(<a href="KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;VO&gt;&nbsp;other,
<a href="ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream">ValueJoiner</a>&lt;? super <a href="KTable.html" title="type parameter in KTable">V</a>,&#8203;? super VO,&#8203;? extends VR&gt;&nbsp;joiner)</code></th>
<td class="col-last">
<div class="block">Join records of this <code>KTable</code> (left input) with another <code>KTable</code>'s (right input) records using
 non-windowed outer equi join, with default serializers, deserializers, and state store.</div>
</td>
</tr>
<tr class="row-color" id="i35">
<td class="col-first"><code>&lt;VO,&#8203;
VR&gt;&nbsp;<a href="KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;VR&gt;</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#outerJoin(org.apache.kafka.streams.kstream.KTable,org.apache.kafka.streams.kstream.ValueJoiner,org.apache.kafka.streams.kstream.Materialized)">outerJoin</a></span>&#8203;(<a href="KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;VO&gt;&nbsp;other,
<a href="ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream">ValueJoiner</a>&lt;? super <a href="KTable.html" title="type parameter in KTable">V</a>,&#8203;? super VO,&#8203;? extends VR&gt;&nbsp;joiner,
<a href="Materialized.html" title="class in org.apache.kafka.streams.kstream">Materialized</a>&lt;<a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;VR,&#8203;<a href="../state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state">KeyValueStore</a>&lt;org.apache.kafka.common.utils.Bytes,&#8203;byte[]&gt;&gt;&nbsp;materialized)</code></th>
<td class="col-last">
<div class="block">Join records of this <code>KTable</code> (left input) with another <code>KTable</code>'s (right input) records using
 non-windowed outer equi join, with the <a href="Materialized.html" title="class in org.apache.kafka.streams.kstream"><code>Materialized</code></a> instance for configuration of the <a href="../../common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization"><code>key serde</code></a>,
 <a href="../../common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization"><code>the result table's value serde</code></a>, and <a href="../state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state"><code>state store</code></a>.</div>
</td>
</tr>
<tr class="alt-color" id="i36">
<td class="col-first"><code>&lt;VO,&#8203;
VR&gt;&nbsp;<a href="KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;VR&gt;</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#outerJoin(org.apache.kafka.streams.kstream.KTable,org.apache.kafka.streams.kstream.ValueJoiner,org.apache.kafka.streams.kstream.Named)">outerJoin</a></span>&#8203;(<a href="KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;VO&gt;&nbsp;other,
<a href="ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream">ValueJoiner</a>&lt;? super <a href="KTable.html" title="type parameter in KTable">V</a>,&#8203;? super VO,&#8203;? extends VR&gt;&nbsp;joiner,
<a href="Named.html" title="class in org.apache.kafka.streams.kstream">Named</a>&nbsp;named)</code></th>
<td class="col-last">
<div class="block">Join records of this <code>KTable</code> (left input) with another <code>KTable</code>'s (right input) records using
 non-windowed outer equi join, with default serializers, deserializers, and state store.</div>
</td>
</tr>
<tr class="row-color" id="i37">
<td class="col-first"><code>&lt;VO,&#8203;
VR&gt;&nbsp;<a href="KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;VR&gt;</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#outerJoin(org.apache.kafka.streams.kstream.KTable,org.apache.kafka.streams.kstream.ValueJoiner,org.apache.kafka.streams.kstream.Named,org.apache.kafka.streams.kstream.Materialized)">outerJoin</a></span>&#8203;(<a href="KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;VO&gt;&nbsp;other,
<a href="ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream">ValueJoiner</a>&lt;? super <a href="KTable.html" title="type parameter in KTable">V</a>,&#8203;? super VO,&#8203;? extends VR&gt;&nbsp;joiner,
<a href="Named.html" title="class in org.apache.kafka.streams.kstream">Named</a>&nbsp;named,
<a href="Materialized.html" title="class in org.apache.kafka.streams.kstream">Materialized</a>&lt;<a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;VR,&#8203;<a href="../state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state">KeyValueStore</a>&lt;org.apache.kafka.common.utils.Bytes,&#8203;byte[]&gt;&gt;&nbsp;materialized)</code></th>
<td class="col-last">
<div class="block">Join records of this <code>KTable</code> (left input) with another <code>KTable</code>'s (right input) records using
 non-windowed outer equi join, with the <a href="Materialized.html" title="class in org.apache.kafka.streams.kstream"><code>Materialized</code></a> instance for configuration of the <a href="../../common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization"><code>key serde</code></a>,
 <a href="../../common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization"><code>the result table's value serde</code></a>, and <a href="../state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state"><code>state store</code></a>.</div>
</td>
</tr>
<tr class="alt-color" id="i38">
<td class="col-first"><code><a href="https://docs.oracle.com/en/java/javase/15/docs/api/java.base/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#queryableStoreName()">queryableStoreName</a></span>()</code></th>
<td class="col-last">
<div class="block">Get the name of the local state store used that can be used to query this <code>KTable</code>.</div>
</td>
</tr>
<tr class="row-color" id="i39">
<td class="col-first"><code><a href="KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;<a href="KTable.html" title="type parameter in KTable">V</a>&gt;</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#suppress(org.apache.kafka.streams.kstream.Suppressed)">suppress</a></span>&#8203;(<a href="Suppressed.html" title="interface in org.apache.kafka.streams.kstream">Suppressed</a>&lt;? super <a href="KTable.html" title="type parameter in KTable">K</a>&gt;&nbsp;suppressed)</code></th>
<td class="col-last">
<div class="block">Suppress some updates from this changelog stream, determined by the supplied <a href="Suppressed.html" title="interface in org.apache.kafka.streams.kstream"><code>Suppressed</code></a> configuration.</div>
</td>
</tr>
<tr class="alt-color" id="i40">
<td class="col-first"><code><a href="KStream.html" title="interface in org.apache.kafka.streams.kstream">KStream</a>&lt;<a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;<a href="KTable.html" title="type parameter in KTable">V</a>&gt;</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#toStream()">toStream</a></span>()</code></th>
<td class="col-last">
<div class="block">Convert this changelog stream to a <a href="KStream.html" title="interface in org.apache.kafka.streams.kstream"><code>KStream</code></a>.</div>
</td>
</tr>
<tr class="row-color" id="i41">
<td class="col-first"><code>&lt;KR&gt;&nbsp;<a href="KStream.html" title="interface in org.apache.kafka.streams.kstream">KStream</a>&lt;KR,&#8203;<a href="KTable.html" title="type parameter in KTable">V</a>&gt;</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#toStream(org.apache.kafka.streams.kstream.KeyValueMapper)">toStream</a></span>&#8203;(<a href="KeyValueMapper.html" title="interface in org.apache.kafka.streams.kstream">KeyValueMapper</a>&lt;? super <a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;? super <a href="KTable.html" title="type parameter in KTable">V</a>,&#8203;? extends KR&gt;&nbsp;mapper)</code></th>
<td class="col-last">
<div class="block">Convert this changelog stream to a <a href="KStream.html" title="interface in org.apache.kafka.streams.kstream"><code>KStream</code></a> using the given <a href="KeyValueMapper.html" title="interface in org.apache.kafka.streams.kstream"><code>KeyValueMapper</code></a> to select the new key.</div>
</td>
</tr>
<tr class="alt-color" id="i42">
<td class="col-first"><code>&lt;KR&gt;&nbsp;<a href="KStream.html" title="interface in org.apache.kafka.streams.kstream">KStream</a>&lt;KR,&#8203;<a href="KTable.html" title="type parameter in KTable">V</a>&gt;</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#toStream(org.apache.kafka.streams.kstream.KeyValueMapper,org.apache.kafka.streams.kstream.Named)">toStream</a></span>&#8203;(<a href="KeyValueMapper.html" title="interface in org.apache.kafka.streams.kstream">KeyValueMapper</a>&lt;? super <a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;? super <a href="KTable.html" title="type parameter in KTable">V</a>,&#8203;? extends KR&gt;&nbsp;mapper,
<a href="Named.html" title="class in org.apache.kafka.streams.kstream">Named</a>&nbsp;named)</code></th>
<td class="col-last">
<div class="block">Convert this changelog stream to a <a href="KStream.html" title="interface in org.apache.kafka.streams.kstream"><code>KStream</code></a> using the given <a href="KeyValueMapper.html" title="interface in org.apache.kafka.streams.kstream"><code>KeyValueMapper</code></a> to select the new key.</div>
</td>
</tr>
<tr class="row-color" id="i43">
<td class="col-first"><code><a href="KStream.html" title="interface in org.apache.kafka.streams.kstream">KStream</a>&lt;<a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;<a href="KTable.html" title="type parameter in KTable">V</a>&gt;</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#toStream(org.apache.kafka.streams.kstream.Named)">toStream</a></span>&#8203;(<a href="Named.html" title="class in org.apache.kafka.streams.kstream">Named</a>&nbsp;named)</code></th>
<td class="col-last">
<div class="block">Convert this changelog stream to a <a href="KStream.html" title="interface in org.apache.kafka.streams.kstream"><code>KStream</code></a>.</div>
</td>
</tr>
<tr class="alt-color" id="i44">
<td class="col-first"><code>&lt;VR&gt;&nbsp;<a href="KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;VR&gt;</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#transformValues(org.apache.kafka.streams.kstream.ValueTransformerWithKeySupplier,java.lang.String...)">transformValues</a></span>&#8203;(<a href="ValueTransformerWithKeySupplier.html" title="interface in org.apache.kafka.streams.kstream">ValueTransformerWithKeySupplier</a>&lt;? super <a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;? super <a href="KTable.html" title="type parameter in KTable">V</a>,&#8203;? extends VR&gt;&nbsp;transformerSupplier,
<a href="https://docs.oracle.com/en/java/javase/15/docs/api/java.base/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a>...&nbsp;stateStoreNames)</code></th>
<td class="col-last">
<div class="block">Create a new <code>KTable</code> by transforming the value of each record in this <code>KTable</code> into a new value
 (with possibly a new type), with default serializers, deserializers, and state store.</div>
</td>
</tr>
<tr class="row-color" id="i45">
<td class="col-first"><code>&lt;VR&gt;&nbsp;<a href="KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;VR&gt;</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#transformValues(org.apache.kafka.streams.kstream.ValueTransformerWithKeySupplier,org.apache.kafka.streams.kstream.Materialized,java.lang.String...)">transformValues</a></span>&#8203;(<a href="ValueTransformerWithKeySupplier.html" title="interface in org.apache.kafka.streams.kstream">ValueTransformerWithKeySupplier</a>&lt;? super <a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;? super <a href="KTable.html" title="type parameter in KTable">V</a>,&#8203;? extends VR&gt;&nbsp;transformerSupplier,
<a href="Materialized.html" title="class in org.apache.kafka.streams.kstream">Materialized</a>&lt;<a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;VR,&#8203;<a href="../state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state">KeyValueStore</a>&lt;org.apache.kafka.common.utils.Bytes,&#8203;byte[]&gt;&gt;&nbsp;materialized,
<a href="https://docs.oracle.com/en/java/javase/15/docs/api/java.base/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a>...&nbsp;stateStoreNames)</code></th>
<td class="col-last">
<div class="block">Create a new <code>KTable</code> by transforming the value of each record in this <code>KTable</code> into a new value
 (with possibly a new type), with the <a href="../../common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization"><code>key serde</code></a>, <a href="../../common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization"><code>value serde</code></a>, and the underlying
 <a href="../state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state"><code>materialized state storage</code></a> configured in the <a href="Materialized.html" title="class in org.apache.kafka.streams.kstream"><code>Materialized</code></a> instance.</div>
</td>
</tr>
<tr class="alt-color" id="i46">
<td class="col-first"><code>&lt;VR&gt;&nbsp;<a href="KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;VR&gt;</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#transformValues(org.apache.kafka.streams.kstream.ValueTransformerWithKeySupplier,org.apache.kafka.streams.kstream.Materialized,org.apache.kafka.streams.kstream.Named,java.lang.String...)">transformValues</a></span>&#8203;(<a href="ValueTransformerWithKeySupplier.html" title="interface in org.apache.kafka.streams.kstream">ValueTransformerWithKeySupplier</a>&lt;? super <a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;? super <a href="KTable.html" title="type parameter in KTable">V</a>,&#8203;? extends VR&gt;&nbsp;transformerSupplier,
<a href="Materialized.html" title="class in org.apache.kafka.streams.kstream">Materialized</a>&lt;<a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;VR,&#8203;<a href="../state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state">KeyValueStore</a>&lt;org.apache.kafka.common.utils.Bytes,&#8203;byte[]&gt;&gt;&nbsp;materialized,
<a href="Named.html" title="class in org.apache.kafka.streams.kstream">Named</a>&nbsp;named,
<a href="https://docs.oracle.com/en/java/javase/15/docs/api/java.base/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a>...&nbsp;stateStoreNames)</code></th>
<td class="col-last">
<div class="block">Create a new <code>KTable</code> by transforming the value of each record in this <code>KTable</code> into a new value
 (with possibly a new type), with the <a href="../../common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization"><code>key serde</code></a>, <a href="../../common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization"><code>value serde</code></a>, and the underlying
 <a href="../state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state"><code>materialized state storage</code></a> configured in the <a href="Materialized.html" title="class in org.apache.kafka.streams.kstream"><code>Materialized</code></a> instance.</div>
</td>
</tr>
<tr class="row-color" id="i47">
<td class="col-first"><code>&lt;VR&gt;&nbsp;<a href="KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;VR&gt;</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#transformValues(org.apache.kafka.streams.kstream.ValueTransformerWithKeySupplier,org.apache.kafka.streams.kstream.Named,java.lang.String...)">transformValues</a></span>&#8203;(<a href="ValueTransformerWithKeySupplier.html" title="interface in org.apache.kafka.streams.kstream">ValueTransformerWithKeySupplier</a>&lt;? super <a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;? super <a href="KTable.html" title="type parameter in KTable">V</a>,&#8203;? extends VR&gt;&nbsp;transformerSupplier,
<a href="Named.html" title="class in org.apache.kafka.streams.kstream">Named</a>&nbsp;named,
<a href="https://docs.oracle.com/en/java/javase/15/docs/api/java.base/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a>...&nbsp;stateStoreNames)</code></th>
<td class="col-last">
<div class="block">Create a new <code>KTable</code> by transforming the value of each record in this <code>KTable</code> into a new value
 (with possibly a new type), with default serializers, deserializers, and state store.</div>
</td>
</tr>
</tbody>
</table>
</div>
</div>
</section>
</li>
</ul>
</section>
<section class="details">
<ul class="details-list">
<!-- ============ METHOD DETAIL ========== -->
<li>
<section class="method-details" id="method.detail">
<h2>Method Details</h2>
<ul class="member-list">
<li>
<section class="detail" id="filter(org.apache.kafka.streams.kstream.Predicate)">
<h3>filter</h3>
<div class="member-signature"><span class="return-type"><a href="KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;<a href="KTable.html" title="type parameter in KTable">V</a>&gt;</span>&nbsp;<span class="member-name">filter</span>&#8203;(<span class="parameters"><a href="Predicate.html" title="interface in org.apache.kafka.streams.kstream">Predicate</a>&lt;? super <a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;? super <a href="KTable.html" title="type parameter in KTable">V</a>&gt;&nbsp;predicate)</span></div>
<div class="block">Create a new <code>KTable</code> that consists of all records of this <code>KTable</code> which satisfy the given
 predicate, with default serializers, deserializers, and state store.
 All records that do not satisfy the predicate are dropped.
 For each <code>KTable</code> update, the filter is evaluated based on the current update
 record and then an update record is produced for the result <code>KTable</code>.
 This is a stateless record-by-record operation.
 <p>
 Note that <code>filter</code> for a <i>changelog stream</i> works differently than <a href="KStream.html#filter(org.apache.kafka.streams.kstream.Predicate)"><code>record stream filters</code></a>, because <a href="../KeyValue.html" title="class in org.apache.kafka.streams"><code>records</code></a> with <code>null</code> values (so-called tombstone records)
 have delete semantics.
 Thus, for tombstones the provided filter predicate is not evaluated but the tombstone record is forwarded
 directly if required (i.e., if there is anything to be deleted).
 Furthermore, for each record that gets dropped (i.e., does not satisfy the given predicate) a tombstone record
 is forwarded.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>predicate</code> - a filter <a href="Predicate.html" title="interface in org.apache.kafka.streams.kstream"><code>Predicate</code></a> that is applied to each record</dd>
<dt>Returns:</dt>
<dd>a <code>KTable</code> that contains only those records that satisfy the given predicate</dd>
<dt>See Also:</dt>
<dd><a href="#filterNot(org.apache.kafka.streams.kstream.Predicate)"><code>filterNot(Predicate)</code></a></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="filter(org.apache.kafka.streams.kstream.Predicate,org.apache.kafka.streams.kstream.Named)">
<h3>filter</h3>
<div class="member-signature"><span class="return-type"><a href="KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;<a href="KTable.html" title="type parameter in KTable">V</a>&gt;</span>&nbsp;<span class="member-name">filter</span>&#8203;(<span class="parameters"><a href="Predicate.html" title="interface in org.apache.kafka.streams.kstream">Predicate</a>&lt;? super <a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;? super <a href="KTable.html" title="type parameter in KTable">V</a>&gt;&nbsp;predicate,
<a href="Named.html" title="class in org.apache.kafka.streams.kstream">Named</a>&nbsp;named)</span></div>
<div class="block">Create a new <code>KTable</code> that consists of all records of this <code>KTable</code> which satisfy the given
 predicate, with default serializers, deserializers, and state store.
 All records that do not satisfy the predicate are dropped.
 For each <code>KTable</code> update, the filter is evaluated based on the current update
 record and then an update record is produced for the result <code>KTable</code>.
 This is a stateless record-by-record operation.
 <p>
 Note that <code>filter</code> for a <i>changelog stream</i> works differently than <a href="KStream.html#filter(org.apache.kafka.streams.kstream.Predicate)"><code>record stream filters</code></a>, because <a href="../KeyValue.html" title="class in org.apache.kafka.streams"><code>records</code></a> with <code>null</code> values (so-called tombstone records)
 have delete semantics.
 Thus, for tombstones the provided filter predicate is not evaluated but the tombstone record is forwarded
 directly if required (i.e., if there is anything to be deleted).
 Furthermore, for each record that gets dropped (i.e., does not satisfy the given predicate) a tombstone record
 is forwarded.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>predicate</code> - a filter <a href="Predicate.html" title="interface in org.apache.kafka.streams.kstream"><code>Predicate</code></a> that is applied to each record</dd>
<dd><code>named</code> - a <a href="Named.html" title="class in org.apache.kafka.streams.kstream"><code>Named</code></a> config used to name the processor in the topology</dd>
<dt>Returns:</dt>
<dd>a <code>KTable</code> that contains only those records that satisfy the given predicate</dd>
<dt>See Also:</dt>
<dd><a href="#filterNot(org.apache.kafka.streams.kstream.Predicate)"><code>filterNot(Predicate)</code></a></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="filter(org.apache.kafka.streams.kstream.Predicate,org.apache.kafka.streams.kstream.Materialized)">
<h3>filter</h3>
<div class="member-signature"><span class="return-type"><a href="KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;<a href="KTable.html" title="type parameter in KTable">V</a>&gt;</span>&nbsp;<span class="member-name">filter</span>&#8203;(<span class="parameters"><a href="Predicate.html" title="interface in org.apache.kafka.streams.kstream">Predicate</a>&lt;? super <a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;? super <a href="KTable.html" title="type parameter in KTable">V</a>&gt;&nbsp;predicate,
<a href="Materialized.html" title="class in org.apache.kafka.streams.kstream">Materialized</a>&lt;<a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;<a href="KTable.html" title="type parameter in KTable">V</a>,&#8203;<a href="../state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state">KeyValueStore</a>&lt;org.apache.kafka.common.utils.Bytes,&#8203;byte[]&gt;&gt;&nbsp;materialized)</span></div>
<div class="block">Create a new <code>KTable</code> that consists of all records of this <code>KTable</code> which satisfy the given
 predicate, with the <a href="../../common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization"><code>key serde</code></a>, <a href="../../common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization"><code>value serde</code></a>, and the underlying
 <a href="../state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state"><code>materialized state storage</code></a> configured in the <a href="Materialized.html" title="class in org.apache.kafka.streams.kstream"><code>Materialized</code></a> instance.
 All records that do not satisfy the predicate are dropped.
 For each <code>KTable</code> update, the filter is evaluated based on the current update
 record and then an update record is produced for the result <code>KTable</code>.
 This is a stateless record-by-record operation.
 <p>
 Note that <code>filter</code> for a <i>changelog stream</i> works differently than <a href="KStream.html#filter(org.apache.kafka.streams.kstream.Predicate)"><code>record stream filters</code></a>, because <a href="../KeyValue.html" title="class in org.apache.kafka.streams"><code>records</code></a> with <code>null</code> values (so-called tombstone records)
 have delete semantics.
 Thus, for tombstones the provided filter predicate is not evaluated but the tombstone record is forwarded
 directly if required (i.e., if there is anything to be deleted).
 Furthermore, for each record that gets dropped (i.e., does not satisfy the given predicate) a tombstone record
 is forwarded.
 <p>
 To query the local <a href="../state/ReadOnlyKeyValueStore.html" title="interface in org.apache.kafka.streams.state"><code>ReadOnlyKeyValueStore</code></a> it must be obtained via
 <a href="../KafkaStreams.html#store(org.apache.kafka.streams.StoreQueryParameters)"><code>KafkaStreams#store(...)</code></a>:
 <pre><code>
 KafkaStreams streams = ... // filtering words
 ReadOnlyKeyValueStore&lt;K, ValueAndTimestamp&lt;V&gt;&gt; localStore = streams.store(queryableStoreName, QueryableStoreTypes.&lt;K, ValueAndTimestamp&lt;V&gt;&gt;timestampedKeyValueStore());
 K key = "some-word";
 ValueAndTimestamp&lt;V&gt; valueForKey = localStore.get(key); // key must be local (application state is shared over all running Kafka Streams instances)
 </code></pre>
 For non-local keys, a custom RPC mechanism must be implemented using <a href="../KafkaStreams.html#metadataForAllStreamsClients()"><code>KafkaStreams.metadataForAllStreamsClients()</code></a> to
 query the value of the key on a parallel running instance of your Kafka Streams application.
 The store name to query with is specified by <a href="Materialized.html#as(java.lang.String)"><code>Materialized.as(String)</code></a> or <a href="Materialized.html#as(org.apache.kafka.streams.state.KeyValueBytesStoreSupplier)"><code>Materialized.as(KeyValueBytesStoreSupplier)</code></a>.
 <p></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>predicate</code> - a filter <a href="Predicate.html" title="interface in org.apache.kafka.streams.kstream"><code>Predicate</code></a> that is applied to each record</dd>
<dd><code>materialized</code> - a <a href="Materialized.html" title="class in org.apache.kafka.streams.kstream"><code>Materialized</code></a> that describes how the <a href="../processor/StateStore.html" title="interface in org.apache.kafka.streams.processor"><code>StateStore</code></a> for the resulting <code>KTable</code>
                      should be materialized. Cannot be <code>null</code></dd>
<dt>Returns:</dt>
<dd>a <code>KTable</code> that contains only those records that satisfy the given predicate</dd>
<dt>See Also:</dt>
<dd><a href="#filterNot(org.apache.kafka.streams.kstream.Predicate,org.apache.kafka.streams.kstream.Materialized)"><code>filterNot(Predicate, Materialized)</code></a></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="filter(org.apache.kafka.streams.kstream.Predicate,org.apache.kafka.streams.kstream.Named,org.apache.kafka.streams.kstream.Materialized)">
<h3>filter</h3>
<div class="member-signature"><span class="return-type"><a href="KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;<a href="KTable.html" title="type parameter in KTable">V</a>&gt;</span>&nbsp;<span class="member-name">filter</span>&#8203;(<span class="parameters"><a href="Predicate.html" title="interface in org.apache.kafka.streams.kstream">Predicate</a>&lt;? super <a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;? super <a href="KTable.html" title="type parameter in KTable">V</a>&gt;&nbsp;predicate,
<a href="Named.html" title="class in org.apache.kafka.streams.kstream">Named</a>&nbsp;named,
<a href="Materialized.html" title="class in org.apache.kafka.streams.kstream">Materialized</a>&lt;<a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;<a href="KTable.html" title="type parameter in KTable">V</a>,&#8203;<a href="../state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state">KeyValueStore</a>&lt;org.apache.kafka.common.utils.Bytes,&#8203;byte[]&gt;&gt;&nbsp;materialized)</span></div>
<div class="block">Create a new <code>KTable</code> that consists of all records of this <code>KTable</code> which satisfy the given
 predicate, with the <a href="../../common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization"><code>key serde</code></a>, <a href="../../common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization"><code>value serde</code></a>, and the underlying
 <a href="../state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state"><code>materialized state storage</code></a> configured in the <a href="Materialized.html" title="class in org.apache.kafka.streams.kstream"><code>Materialized</code></a> instance.
 All records that do not satisfy the predicate are dropped.
 For each <code>KTable</code> update, the filter is evaluated based on the current update
 record and then an update record is produced for the result <code>KTable</code>.
 This is a stateless record-by-record operation.
 <p>
 Note that <code>filter</code> for a <i>changelog stream</i> works differently than <a href="KStream.html#filter(org.apache.kafka.streams.kstream.Predicate)"><code>record stream filters</code></a>, because <a href="../KeyValue.html" title="class in org.apache.kafka.streams"><code>records</code></a> with <code>null</code> values (so-called tombstone records)
 have delete semantics.
 Thus, for tombstones the provided filter predicate is not evaluated but the tombstone record is forwarded
 directly if required (i.e., if there is anything to be deleted).
 Furthermore, for each record that gets dropped (i.e., does not satisfy the given predicate) a tombstone record
 is forwarded.
 <p>
 To query the local <a href="../state/ReadOnlyKeyValueStore.html" title="interface in org.apache.kafka.streams.state"><code>ReadOnlyKeyValueStore</code></a> it must be obtained via
 <a href="../KafkaStreams.html#store(org.apache.kafka.streams.StoreQueryParameters)"><code>KafkaStreams#store(...)</code></a>:
 <pre><code>
 KafkaStreams streams = ... // filtering words
 ReadOnlyKeyValueStore&lt;K, ValueAndTimestamp&lt;V&gt;&gt; localStore = streams.store(queryableStoreName, QueryableStoreTypes.&lt;K, ValueAndTimestamp&lt;V&gt;&gt;timestampedKeyValueStore());
 K key = "some-word";
 ValueAndTimestamp&lt;V&gt; valueForKey = localStore.get(key); // key must be local (application state is shared over all running Kafka Streams instances)
 </code></pre>
 For non-local keys, a custom RPC mechanism must be implemented using <a href="../KafkaStreams.html#metadataForAllStreamsClients()"><code>KafkaStreams.metadataForAllStreamsClients()</code></a> to
 query the value of the key on a parallel running instance of your Kafka Streams application.
 The store name to query with is specified by <a href="Materialized.html#as(java.lang.String)"><code>Materialized.as(String)</code></a> or <a href="Materialized.html#as(org.apache.kafka.streams.state.KeyValueBytesStoreSupplier)"><code>Materialized.as(KeyValueBytesStoreSupplier)</code></a>.
 <p></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>predicate</code> - a filter <a href="Predicate.html" title="interface in org.apache.kafka.streams.kstream"><code>Predicate</code></a> that is applied to each record</dd>
<dd><code>named</code> - a <a href="Named.html" title="class in org.apache.kafka.streams.kstream"><code>Named</code></a> config used to name the processor in the topology</dd>
<dd><code>materialized</code> - a <a href="Materialized.html" title="class in org.apache.kafka.streams.kstream"><code>Materialized</code></a> that describes how the <a href="../processor/StateStore.html" title="interface in org.apache.kafka.streams.processor"><code>StateStore</code></a> for the resulting <code>KTable</code>
                      should be materialized. Cannot be <code>null</code></dd>
<dt>Returns:</dt>
<dd>a <code>KTable</code> that contains only those records that satisfy the given predicate</dd>
<dt>See Also:</dt>
<dd><a href="#filterNot(org.apache.kafka.streams.kstream.Predicate,org.apache.kafka.streams.kstream.Materialized)"><code>filterNot(Predicate, Materialized)</code></a></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="filterNot(org.apache.kafka.streams.kstream.Predicate)">
<h3>filterNot</h3>
<div class="member-signature"><span class="return-type"><a href="KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;<a href="KTable.html" title="type parameter in KTable">V</a>&gt;</span>&nbsp;<span class="member-name">filterNot</span>&#8203;(<span class="parameters"><a href="Predicate.html" title="interface in org.apache.kafka.streams.kstream">Predicate</a>&lt;? super <a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;? super <a href="KTable.html" title="type parameter in KTable">V</a>&gt;&nbsp;predicate)</span></div>
<div class="block">Create a new <code>KTable</code> that consists all records of this <code>KTable</code> which do <em>not</em> satisfy the
 given predicate, with default serializers, deserializers, and state store.
 All records that <em>do</em> satisfy the predicate are dropped.
 For each <code>KTable</code> update, the filter is evaluated based on the current update
 record and then an update record is produced for the result <code>KTable</code>.
 This is a stateless record-by-record operation.
 <p>
 Note that <code>filterNot</code> for a <i>changelog stream</i> works differently than <a href="KStream.html#filterNot(org.apache.kafka.streams.kstream.Predicate)"><code>record stream filters</code></a>, because <a href="../KeyValue.html" title="class in org.apache.kafka.streams"><code>records</code></a> with <code>null</code> values (so-called tombstone records)
 have delete semantics.
 Thus, for tombstones the provided filter predicate is not evaluated but the tombstone record is forwarded
 directly if required (i.e., if there is anything to be deleted).
 Furthermore, for each record that gets dropped (i.e., does satisfy the given predicate) a tombstone record is
 forwarded.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>predicate</code> - a filter <a href="Predicate.html" title="interface in org.apache.kafka.streams.kstream"><code>Predicate</code></a> that is applied to each record</dd>
<dt>Returns:</dt>
<dd>a <code>KTable</code> that contains only those records that do <em>not</em> satisfy the given predicate</dd>
<dt>See Also:</dt>
<dd><a href="#filter(org.apache.kafka.streams.kstream.Predicate)"><code>filter(Predicate)</code></a></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="filterNot(org.apache.kafka.streams.kstream.Predicate,org.apache.kafka.streams.kstream.Named)">
<h3>filterNot</h3>
<div class="member-signature"><span class="return-type"><a href="KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;<a href="KTable.html" title="type parameter in KTable">V</a>&gt;</span>&nbsp;<span class="member-name">filterNot</span>&#8203;(<span class="parameters"><a href="Predicate.html" title="interface in org.apache.kafka.streams.kstream">Predicate</a>&lt;? super <a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;? super <a href="KTable.html" title="type parameter in KTable">V</a>&gt;&nbsp;predicate,
<a href="Named.html" title="class in org.apache.kafka.streams.kstream">Named</a>&nbsp;named)</span></div>
<div class="block">Create a new <code>KTable</code> that consists all records of this <code>KTable</code> which do <em>not</em> satisfy the
 given predicate, with default serializers, deserializers, and state store.
 All records that <em>do</em> satisfy the predicate are dropped.
 For each <code>KTable</code> update, the filter is evaluated based on the current update
 record and then an update record is produced for the result <code>KTable</code>.
 This is a stateless record-by-record operation.
 <p>
 Note that <code>filterNot</code> for a <i>changelog stream</i> works differently than <a href="KStream.html#filterNot(org.apache.kafka.streams.kstream.Predicate)"><code>record stream filters</code></a>, because <a href="../KeyValue.html" title="class in org.apache.kafka.streams"><code>records</code></a> with <code>null</code> values (so-called tombstone records)
 have delete semantics.
 Thus, for tombstones the provided filter predicate is not evaluated but the tombstone record is forwarded
 directly if required (i.e., if there is anything to be deleted).
 Furthermore, for each record that gets dropped (i.e., does satisfy the given predicate) a tombstone record is
 forwarded.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>predicate</code> - a filter <a href="Predicate.html" title="interface in org.apache.kafka.streams.kstream"><code>Predicate</code></a> that is applied to each record</dd>
<dd><code>named</code> - a <a href="Named.html" title="class in org.apache.kafka.streams.kstream"><code>Named</code></a> config used to name the processor in the topology</dd>
<dt>Returns:</dt>
<dd>a <code>KTable</code> that contains only those records that do <em>not</em> satisfy the given predicate</dd>
<dt>See Also:</dt>
<dd><a href="#filter(org.apache.kafka.streams.kstream.Predicate)"><code>filter(Predicate)</code></a></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="filterNot(org.apache.kafka.streams.kstream.Predicate,org.apache.kafka.streams.kstream.Materialized)">
<h3>filterNot</h3>
<div class="member-signature"><span class="return-type"><a href="KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;<a href="KTable.html" title="type parameter in KTable">V</a>&gt;</span>&nbsp;<span class="member-name">filterNot</span>&#8203;(<span class="parameters"><a href="Predicate.html" title="interface in org.apache.kafka.streams.kstream">Predicate</a>&lt;? super <a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;? super <a href="KTable.html" title="type parameter in KTable">V</a>&gt;&nbsp;predicate,
<a href="Materialized.html" title="class in org.apache.kafka.streams.kstream">Materialized</a>&lt;<a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;<a href="KTable.html" title="type parameter in KTable">V</a>,&#8203;<a href="../state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state">KeyValueStore</a>&lt;org.apache.kafka.common.utils.Bytes,&#8203;byte[]&gt;&gt;&nbsp;materialized)</span></div>
<div class="block">Create a new <code>KTable</code> that consists all records of this <code>KTable</code> which do <em>not</em> satisfy the
 given predicate, with the <a href="../../common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization"><code>key serde</code></a>, <a href="../../common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization"><code>value serde</code></a>, and the underlying
 <a href="../state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state"><code>materialized state storage</code></a> configured in the <a href="Materialized.html" title="class in org.apache.kafka.streams.kstream"><code>Materialized</code></a> instance.
 All records that <em>do</em> satisfy the predicate are dropped.
 For each <code>KTable</code> update, the filter is evaluated based on the current update
 record and then an update record is produced for the result <code>KTable</code>.
 This is a stateless record-by-record operation.
 <p>
 Note that <code>filterNot</code> for a <i>changelog stream</i> works differently than <a href="KStream.html#filterNot(org.apache.kafka.streams.kstream.Predicate)"><code>record stream filters</code></a>, because <a href="../KeyValue.html" title="class in org.apache.kafka.streams"><code>records</code></a> with <code>null</code> values (so-called tombstone records)
 have delete semantics.
 Thus, for tombstones the provided filter predicate is not evaluated but the tombstone record is forwarded
 directly if required (i.e., if there is anything to be deleted).
 Furthermore, for each record that gets dropped (i.e., does satisfy the given predicate) a tombstone record is
 forwarded.
 <p>
 To query the local <a href="../state/ReadOnlyKeyValueStore.html" title="interface in org.apache.kafka.streams.state"><code>ReadOnlyKeyValueStore</code></a> it must be obtained via
 <a href="../KafkaStreams.html#store(org.apache.kafka.streams.StoreQueryParameters)"><code>KafkaStreams#store(...)</code></a>:
 <pre><code>
 KafkaStreams streams = ... // filtering words
 ReadOnlyKeyValueStore&lt;K, ValueAndTimestamp&lt;V&gt;&gt; localStore = streams.store(queryableStoreName, QueryableStoreTypes.&lt;K, ValueAndTimestamp&lt;V&gt;&gt;timestampedKeyValueStore());
 K key = "some-word";
 ValueAndTimestamp&lt;V&gt; valueForKey = localStore.get(key); // key must be local (application state is shared over all running Kafka Streams instances)
 </code></pre>
 For non-local keys, a custom RPC mechanism must be implemented using <a href="../KafkaStreams.html#metadataForAllStreamsClients()"><code>KafkaStreams.metadataForAllStreamsClients()</code></a> to
 query the value of the key on a parallel running instance of your Kafka Streams application.
 The store name to query with is specified by <a href="Materialized.html#as(java.lang.String)"><code>Materialized.as(String)</code></a> or <a href="Materialized.html#as(org.apache.kafka.streams.state.KeyValueBytesStoreSupplier)"><code>Materialized.as(KeyValueBytesStoreSupplier)</code></a>.
 <p></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>predicate</code> - a filter <a href="Predicate.html" title="interface in org.apache.kafka.streams.kstream"><code>Predicate</code></a> that is applied to each record</dd>
<dd><code>materialized</code> - a <a href="Materialized.html" title="class in org.apache.kafka.streams.kstream"><code>Materialized</code></a> that describes how the <a href="../processor/StateStore.html" title="interface in org.apache.kafka.streams.processor"><code>StateStore</code></a> for the resulting <code>KTable</code>
                      should be materialized. Cannot be <code>null</code></dd>
<dt>Returns:</dt>
<dd>a <code>KTable</code> that contains only those records that do <em>not</em> satisfy the given predicate</dd>
<dt>See Also:</dt>
<dd><a href="#filter(org.apache.kafka.streams.kstream.Predicate,org.apache.kafka.streams.kstream.Materialized)"><code>filter(Predicate, Materialized)</code></a></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="filterNot(org.apache.kafka.streams.kstream.Predicate,org.apache.kafka.streams.kstream.Named,org.apache.kafka.streams.kstream.Materialized)">
<h3>filterNot</h3>
<div class="member-signature"><span class="return-type"><a href="KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;<a href="KTable.html" title="type parameter in KTable">V</a>&gt;</span>&nbsp;<span class="member-name">filterNot</span>&#8203;(<span class="parameters"><a href="Predicate.html" title="interface in org.apache.kafka.streams.kstream">Predicate</a>&lt;? super <a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;? super <a href="KTable.html" title="type parameter in KTable">V</a>&gt;&nbsp;predicate,
<a href="Named.html" title="class in org.apache.kafka.streams.kstream">Named</a>&nbsp;named,
<a href="Materialized.html" title="class in org.apache.kafka.streams.kstream">Materialized</a>&lt;<a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;<a href="KTable.html" title="type parameter in KTable">V</a>,&#8203;<a href="../state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state">KeyValueStore</a>&lt;org.apache.kafka.common.utils.Bytes,&#8203;byte[]&gt;&gt;&nbsp;materialized)</span></div>
<div class="block">Create a new <code>KTable</code> that consists all records of this <code>KTable</code> which do <em>not</em> satisfy the
 given predicate, with the <a href="../../common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization"><code>key serde</code></a>, <a href="../../common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization"><code>value serde</code></a>, and the underlying
 <a href="../state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state"><code>materialized state storage</code></a> configured in the <a href="Materialized.html" title="class in org.apache.kafka.streams.kstream"><code>Materialized</code></a> instance.
 All records that <em>do</em> satisfy the predicate are dropped.
 For each <code>KTable</code> update, the filter is evaluated based on the current update
 record and then an update record is produced for the result <code>KTable</code>.
 This is a stateless record-by-record operation.
 <p>
 Note that <code>filterNot</code> for a <i>changelog stream</i> works differently than <a href="KStream.html#filterNot(org.apache.kafka.streams.kstream.Predicate)"><code>record stream filters</code></a>, because <a href="../KeyValue.html" title="class in org.apache.kafka.streams"><code>records</code></a> with <code>null</code> values (so-called tombstone records)
 have delete semantics.
 Thus, for tombstones the provided filter predicate is not evaluated but the tombstone record is forwarded
 directly if required (i.e., if there is anything to be deleted).
 Furthermore, for each record that gets dropped (i.e., does satisfy the given predicate) a tombstone record is
 forwarded.
 <p>
 To query the local <a href="../state/ReadOnlyKeyValueStore.html" title="interface in org.apache.kafka.streams.state"><code>ReadOnlyKeyValueStore</code></a> it must be obtained via
 <a href="../KafkaStreams.html#store(org.apache.kafka.streams.StoreQueryParameters)"><code>KafkaStreams#store(...)</code></a>:
 <pre><code>
 KafkaStreams streams = ... // filtering words
 ReadOnlyKeyValueStore&lt;K, ValueAndTimestamp&lt;V&gt;&gt; localStore = streams.store(queryableStoreName, QueryableStoreTypes.&lt;K, ValueAndTimestamp&lt;V&gt;&gt;timestampedKeyValueStore());
 K key = "some-word";
 ValueAndTimestamp&lt;V&gt; valueForKey = localStore.get(key); // key must be local (application state is shared over all running Kafka Streams instances)
 </code></pre>
 For non-local keys, a custom RPC mechanism must be implemented using <a href="../KafkaStreams.html#metadataForAllStreamsClients()"><code>KafkaStreams.metadataForAllStreamsClients()</code></a> to
 query the value of the key on a parallel running instance of your Kafka Streams application.
 The store name to query with is specified by <a href="Materialized.html#as(java.lang.String)"><code>Materialized.as(String)</code></a> or <a href="Materialized.html#as(org.apache.kafka.streams.state.KeyValueBytesStoreSupplier)"><code>Materialized.as(KeyValueBytesStoreSupplier)</code></a>.
 <p></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>predicate</code> - a filter <a href="Predicate.html" title="interface in org.apache.kafka.streams.kstream"><code>Predicate</code></a> that is applied to each record</dd>
<dd><code>named</code> - a <a href="Named.html" title="class in org.apache.kafka.streams.kstream"><code>Named</code></a> config used to name the processor in the topology</dd>
<dd><code>materialized</code> - a <a href="Materialized.html" title="class in org.apache.kafka.streams.kstream"><code>Materialized</code></a> that describes how the <a href="../processor/StateStore.html" title="interface in org.apache.kafka.streams.processor"><code>StateStore</code></a> for the resulting <code>KTable</code>
                      should be materialized. Cannot be <code>null</code></dd>
<dt>Returns:</dt>
<dd>a <code>KTable</code> that contains only those records that do <em>not</em> satisfy the given predicate</dd>
<dt>See Also:</dt>
<dd><a href="#filter(org.apache.kafka.streams.kstream.Predicate,org.apache.kafka.streams.kstream.Materialized)"><code>filter(Predicate, Materialized)</code></a></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="mapValues(org.apache.kafka.streams.kstream.ValueMapper)">
<h3>mapValues</h3>
<div class="member-signature"><span class="type-parameters">&lt;VR&gt;</span>&nbsp;<span class="return-type"><a href="KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;VR&gt;</span>&nbsp;<span class="member-name">mapValues</span>&#8203;(<span class="parameters"><a href="ValueMapper.html" title="interface in org.apache.kafka.streams.kstream">ValueMapper</a>&lt;? super <a href="KTable.html" title="type parameter in KTable">V</a>,&#8203;? extends VR&gt;&nbsp;mapper)</span></div>
<div class="block">Create a new <code>KTable</code> by transforming the value of each record in this <code>KTable</code> into a new value
 (with possibly a new type) in the new <code>KTable</code>, with default serializers, deserializers, and state store.
 For each <code>KTable</code> update the provided <a href="ValueMapper.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueMapper</code></a> is applied to the value of the updated record and
 computes a new value for it, resulting in an updated record for the result <code>KTable</code>.
 Thus, an input record <code>&lt;K,V&gt;</code> can be transformed into an output record <code>&lt;K:V'&gt;</code>.
 This is a stateless record-by-record operation.
 <p>
 The example below counts the number of token of the value string.
 <pre><code>
 KTable&lt;String, String&gt; inputTable = builder.table("topic");
 KTable&lt;String, Integer&gt; outputTable = inputTable.mapValues(value -&gt; value.split(" ").length);
 </code></pre>
 <p>
 This operation preserves data co-location with respect to the key.
 Thus, <em>no</em> internal data redistribution is required if a key based operator (like a join) is applied to
 the result <code>KTable</code>.
 <p>
 Note that <code>mapValues</code> for a <i>changelog stream</i> works differently than <a href="KStream.html#mapValues(org.apache.kafka.streams.kstream.ValueMapper)"><code>record stream filters</code></a>, because <a href="../KeyValue.html" title="class in org.apache.kafka.streams"><code>records</code></a> with <code>null</code> values (so-called tombstone records)
 have delete semantics.
 Thus, for tombstones the provided value-mapper is not evaluated but the tombstone record is forwarded directly to
 delete the corresponding record in the result <code>KTable</code>.</div>
<dl class="notes">
<dt>Type Parameters:</dt>
<dd><code>VR</code> - the value type of the result <code>KTable</code></dd>
<dt>Parameters:</dt>
<dd><code>mapper</code> - a <a href="ValueMapper.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueMapper</code></a> that computes a new output value</dd>
<dt>Returns:</dt>
<dd>a <code>KTable</code> that contains records with unmodified keys and new values (possibly of different type)</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="mapValues(org.apache.kafka.streams.kstream.ValueMapper,org.apache.kafka.streams.kstream.Named)">
<h3>mapValues</h3>
<div class="member-signature"><span class="type-parameters">&lt;VR&gt;</span>&nbsp;<span class="return-type"><a href="KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;VR&gt;</span>&nbsp;<span class="member-name">mapValues</span>&#8203;(<span class="parameters"><a href="ValueMapper.html" title="interface in org.apache.kafka.streams.kstream">ValueMapper</a>&lt;? super <a href="KTable.html" title="type parameter in KTable">V</a>,&#8203;? extends VR&gt;&nbsp;mapper,
<a href="Named.html" title="class in org.apache.kafka.streams.kstream">Named</a>&nbsp;named)</span></div>
<div class="block">Create a new <code>KTable</code> by transforming the value of each record in this <code>KTable</code> into a new value
 (with possibly a new type) in the new <code>KTable</code>, with default serializers, deserializers, and state store.
 For each <code>KTable</code> update the provided <a href="ValueMapper.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueMapper</code></a> is applied to the value of the updated record and
 computes a new value for it, resulting in an updated record for the result <code>KTable</code>.
 Thus, an input record <code>&lt;K,V&gt;</code> can be transformed into an output record <code>&lt;K:V'&gt;</code>.
 This is a stateless record-by-record operation.
 <p>
 The example below counts the number of token of the value string.
 <pre><code>
 KTable&lt;String, String&gt; inputTable = builder.table("topic");
 KTable&lt;String, Integer&gt; outputTable = inputTable.mapValues(value -&gt; value.split(" ").length, Named.as("countTokenValue"));
 </code></pre>
 <p>
 This operation preserves data co-location with respect to the key.
 Thus, <em>no</em> internal data redistribution is required if a key based operator (like a join) is applied to
 the result <code>KTable</code>.
 <p>
 Note that <code>mapValues</code> for a <i>changelog stream</i> works differently than <a href="KStream.html#mapValues(org.apache.kafka.streams.kstream.ValueMapper)"><code>record stream filters</code></a>, because <a href="../KeyValue.html" title="class in org.apache.kafka.streams"><code>records</code></a> with <code>null</code> values (so-called tombstone records)
 have delete semantics.
 Thus, for tombstones the provided value-mapper is not evaluated but the tombstone record is forwarded directly to
 delete the corresponding record in the result <code>KTable</code>.</div>
<dl class="notes">
<dt>Type Parameters:</dt>
<dd><code>VR</code> - the value type of the result <code>KTable</code></dd>
<dt>Parameters:</dt>
<dd><code>mapper</code> - a <a href="ValueMapper.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueMapper</code></a> that computes a new output value</dd>
<dd><code>named</code> - a <a href="Named.html" title="class in org.apache.kafka.streams.kstream"><code>Named</code></a> config used to name the processor in the topology</dd>
<dt>Returns:</dt>
<dd>a <code>KTable</code> that contains records with unmodified keys and new values (possibly of different type)</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="mapValues(org.apache.kafka.streams.kstream.ValueMapperWithKey)">
<h3>mapValues</h3>
<div class="member-signature"><span class="type-parameters">&lt;VR&gt;</span>&nbsp;<span class="return-type"><a href="KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;VR&gt;</span>&nbsp;<span class="member-name">mapValues</span>&#8203;(<span class="parameters"><a href="ValueMapperWithKey.html" title="interface in org.apache.kafka.streams.kstream">ValueMapperWithKey</a>&lt;? super <a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;? super <a href="KTable.html" title="type parameter in KTable">V</a>,&#8203;? extends VR&gt;&nbsp;mapper)</span></div>
<div class="block">Create a new <code>KTable</code> by transforming the value of each record in this <code>KTable</code> into a new value
 (with possibly a new type) in the new <code>KTable</code>, with default serializers, deserializers, and state store.
 For each <code>KTable</code> update the provided <a href="ValueMapperWithKey.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueMapperWithKey</code></a> is applied to the value of the update
 record and computes a new value for it, resulting in an updated record for the result <code>KTable</code>.
 Thus, an input record <code>&lt;K,V&gt;</code> can be transformed into an output record <code>&lt;K:V'&gt;</code>.
 This is a stateless record-by-record operation.
 <p>
 The example below counts the number of token of value and key strings.
 <pre><code>
 KTable&lt;String, String&gt; inputTable = builder.table("topic");
 KTable&lt;String, Integer&gt; outputTable =
  inputTable.mapValues((readOnlyKey, value) -&gt; readOnlyKey.split(" ").length + value.split(" ").length);
 </code></pre>
 <p>
 Note that the key is read-only and should not be modified, as this can lead to corrupt partitioning.
 This operation preserves data co-location with respect to the key.
 Thus, <em>no</em> internal data redistribution is required if a key based operator (like a join) is applied to
 the result <code>KTable</code>.
 <p>
 Note that <code>mapValues</code> for a <i>changelog stream</i> works differently than <a href="KStream.html#mapValues(org.apache.kafka.streams.kstream.ValueMapperWithKey)"><code>record stream filters</code></a>, because <a href="../KeyValue.html" title="class in org.apache.kafka.streams"><code>records</code></a> with <code>null</code> values (so-called tombstone records)
 have delete semantics.
 Thus, for tombstones the provided value-mapper is not evaluated but the tombstone record is forwarded directly to
 delete the corresponding record in the result <code>KTable</code>.</div>
<dl class="notes">
<dt>Type Parameters:</dt>
<dd><code>VR</code> - the value type of the result <code>KTable</code></dd>
<dt>Parameters:</dt>
<dd><code>mapper</code> - a <a href="ValueMapperWithKey.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueMapperWithKey</code></a> that computes a new output value</dd>
<dt>Returns:</dt>
<dd>a <code>KTable</code> that contains records with unmodified keys and new values (possibly of different type)</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="mapValues(org.apache.kafka.streams.kstream.ValueMapperWithKey,org.apache.kafka.streams.kstream.Named)">
<h3>mapValues</h3>
<div class="member-signature"><span class="type-parameters">&lt;VR&gt;</span>&nbsp;<span class="return-type"><a href="KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;VR&gt;</span>&nbsp;<span class="member-name">mapValues</span>&#8203;(<span class="parameters"><a href="ValueMapperWithKey.html" title="interface in org.apache.kafka.streams.kstream">ValueMapperWithKey</a>&lt;? super <a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;? super <a href="KTable.html" title="type parameter in KTable">V</a>,&#8203;? extends VR&gt;&nbsp;mapper,
<a href="Named.html" title="class in org.apache.kafka.streams.kstream">Named</a>&nbsp;named)</span></div>
<div class="block">Create a new <code>KTable</code> by transforming the value of each record in this <code>KTable</code> into a new value
 (with possibly a new type) in the new <code>KTable</code>, with default serializers, deserializers, and state store.
 For each <code>KTable</code> update the provided <a href="ValueMapperWithKey.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueMapperWithKey</code></a> is applied to the value of the update
 record and computes a new value for it, resulting in an updated record for the result <code>KTable</code>.
 Thus, an input record <code>&lt;K,V&gt;</code> can be transformed into an output record <code>&lt;K:V'&gt;</code>.
 This is a stateless record-by-record operation.
 <p>
 The example below counts the number of token of value and key strings.
 <pre><code>
 KTable&lt;String, String&gt; inputTable = builder.table("topic");
 KTable&lt;String, Integer&gt; outputTable =
  inputTable.mapValues((readOnlyKey, value) -&gt; readOnlyKey.split(" ").length + value.split(" ").length, Named.as("countTokenValueAndKey"));
 </code></pre>
 <p>
 Note that the key is read-only and should not be modified, as this can lead to corrupt partitioning.
 This operation preserves data co-location with respect to the key.
 Thus, <em>no</em> internal data redistribution is required if a key based operator (like a join) is applied to
 the result <code>KTable</code>.
 <p>
 Note that <code>mapValues</code> for a <i>changelog stream</i> works differently than <a href="KStream.html#mapValues(org.apache.kafka.streams.kstream.ValueMapperWithKey)"><code>record stream filters</code></a>, because <a href="../KeyValue.html" title="class in org.apache.kafka.streams"><code>records</code></a> with <code>null</code> values (so-called tombstone records)
 have delete semantics.
 Thus, for tombstones the provided value-mapper is not evaluated but the tombstone record is forwarded directly to
 delete the corresponding record in the result <code>KTable</code>.</div>
<dl class="notes">
<dt>Type Parameters:</dt>
<dd><code>VR</code> - the value type of the result <code>KTable</code></dd>
<dt>Parameters:</dt>
<dd><code>mapper</code> - a <a href="ValueMapperWithKey.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueMapperWithKey</code></a> that computes a new output value</dd>
<dd><code>named</code> - a <a href="Named.html" title="class in org.apache.kafka.streams.kstream"><code>Named</code></a> config used to name the processor in the topology</dd>
<dt>Returns:</dt>
<dd>a <code>KTable</code> that contains records with unmodified keys and new values (possibly of different type)</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="mapValues(org.apache.kafka.streams.kstream.ValueMapper,org.apache.kafka.streams.kstream.Materialized)">
<h3>mapValues</h3>
<div class="member-signature"><span class="type-parameters">&lt;VR&gt;</span>&nbsp;<span class="return-type"><a href="KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;VR&gt;</span>&nbsp;<span class="member-name">mapValues</span>&#8203;(<span class="parameters"><a href="ValueMapper.html" title="interface in org.apache.kafka.streams.kstream">ValueMapper</a>&lt;? super <a href="KTable.html" title="type parameter in KTable">V</a>,&#8203;? extends VR&gt;&nbsp;mapper,
<a href="Materialized.html" title="class in org.apache.kafka.streams.kstream">Materialized</a>&lt;<a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;VR,&#8203;<a href="../state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state">KeyValueStore</a>&lt;org.apache.kafka.common.utils.Bytes,&#8203;byte[]&gt;&gt;&nbsp;materialized)</span></div>
<div class="block">Create a new <code>KTable</code> by transforming the value of each record in this <code>KTable</code> into a new value
 (with possibly a new type) in the new <code>KTable</code>, with the <a href="../../common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization"><code>key serde</code></a>, <a href="../../common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization"><code>value serde</code></a>,
 and the underlying <a href="../state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state"><code>materialized state storage</code></a> configured in the <a href="Materialized.html" title="class in org.apache.kafka.streams.kstream"><code>Materialized</code></a>
 instance.
 For each <code>KTable</code> update the provided <a href="ValueMapper.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueMapper</code></a> is applied to the value of the updated record and
 computes a new value for it, resulting in an updated record for the result <code>KTable</code>.
 Thus, an input record <code>&lt;K,V&gt;</code> can be transformed into an output record <code>&lt;K:V'&gt;</code>.
 This is a stateless record-by-record operation.
 <p>
 The example below counts the number of token of the value string.
 <pre><code>
 KTable&lt;String, String&gt; inputTable = builder.table("topic");
 KTable&lt;String, Integer&gt; outputTable = inputTable.mapValue(new ValueMapper&lt;String, Integer&gt; {
     Integer apply(String value) {
         return value.split(" ").length;
     }
 });
 </code></pre>
 <p>
 To query the local <a href="../state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state"><code>KeyValueStore</code></a> representing outputTable above it must be obtained via
 <a href="../KafkaStreams.html#store(org.apache.kafka.streams.StoreQueryParameters)"><code>KafkaStreams#store(...)</code></a>:
 For non-local keys, a custom RPC mechanism must be implemented using <a href="../KafkaStreams.html#metadataForAllStreamsClients()"><code>KafkaStreams.metadataForAllStreamsClients()</code></a> to
 query the value of the key on a parallel running instance of your Kafka Streams application.
 The store name to query with is specified by <a href="Materialized.html#as(java.lang.String)"><code>Materialized.as(String)</code></a> or <a href="Materialized.html#as(org.apache.kafka.streams.state.KeyValueBytesStoreSupplier)"><code>Materialized.as(KeyValueBytesStoreSupplier)</code></a>.
 <p>
 This operation preserves data co-location with respect to the key.
 Thus, <em>no</em> internal data redistribution is required if a key based operator (like a join) is applied to
 the result <code>KTable</code>.
 <p>
 Note that <code>mapValues</code> for a <i>changelog stream</i> works differently than <a href="KStream.html#mapValues(org.apache.kafka.streams.kstream.ValueMapper)"><code>record stream filters</code></a>, because <a href="../KeyValue.html" title="class in org.apache.kafka.streams"><code>records</code></a> with <code>null</code> values (so-called tombstone records)
 have delete semantics.
 Thus, for tombstones the provided value-mapper is not evaluated but the tombstone record is forwarded directly to
 delete the corresponding record in the result <code>KTable</code>.</div>
<dl class="notes">
<dt>Type Parameters:</dt>
<dd><code>VR</code> - the value type of the result <code>KTable</code></dd>
<dt>Parameters:</dt>
<dd><code>mapper</code> - a <a href="ValueMapper.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueMapper</code></a> that computes a new output value</dd>
<dd><code>materialized</code> - a <a href="Materialized.html" title="class in org.apache.kafka.streams.kstream"><code>Materialized</code></a> that describes how the <a href="../processor/StateStore.html" title="interface in org.apache.kafka.streams.processor"><code>StateStore</code></a> for the resulting <code>KTable</code>
                      should be materialized. Cannot be <code>null</code></dd>
<dt>Returns:</dt>
<dd>a <code>KTable</code> that contains records with unmodified keys and new values (possibly of different type)</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="mapValues(org.apache.kafka.streams.kstream.ValueMapper,org.apache.kafka.streams.kstream.Named,org.apache.kafka.streams.kstream.Materialized)">
<h3>mapValues</h3>
<div class="member-signature"><span class="type-parameters">&lt;VR&gt;</span>&nbsp;<span class="return-type"><a href="KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;VR&gt;</span>&nbsp;<span class="member-name">mapValues</span>&#8203;(<span class="parameters"><a href="ValueMapper.html" title="interface in org.apache.kafka.streams.kstream">ValueMapper</a>&lt;? super <a href="KTable.html" title="type parameter in KTable">V</a>,&#8203;? extends VR&gt;&nbsp;mapper,
<a href="Named.html" title="class in org.apache.kafka.streams.kstream">Named</a>&nbsp;named,
<a href="Materialized.html" title="class in org.apache.kafka.streams.kstream">Materialized</a>&lt;<a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;VR,&#8203;<a href="../state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state">KeyValueStore</a>&lt;org.apache.kafka.common.utils.Bytes,&#8203;byte[]&gt;&gt;&nbsp;materialized)</span></div>
<div class="block">Create a new <code>KTable</code> by transforming the value of each record in this <code>KTable</code> into a new value
 (with possibly a new type) in the new <code>KTable</code>, with the <a href="../../common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization"><code>key serde</code></a>, <a href="../../common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization"><code>value serde</code></a>,
 and the underlying <a href="../state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state"><code>materialized state storage</code></a> configured in the <a href="Materialized.html" title="class in org.apache.kafka.streams.kstream"><code>Materialized</code></a>
 instance.
 For each <code>KTable</code> update the provided <a href="ValueMapper.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueMapper</code></a> is applied to the value of the updated record and
 computes a new value for it, resulting in an updated record for the result <code>KTable</code>.
 Thus, an input record <code>&lt;K,V&gt;</code> can be transformed into an output record <code>&lt;K:V'&gt;</code>.
 This is a stateless record-by-record operation.
 <p>
 The example below counts the number of token of the value string.
 <pre><code>
 KTable&lt;String, String&gt; inputTable = builder.table("topic");
 KTable&lt;String, Integer&gt; outputTable = inputTable.mapValue(new ValueMapper&lt;String, Integer&gt; {
     Integer apply(String value) {
         return value.split(" ").length;
     }
 });
 </code></pre>
 <p>
 To query the local <a href="../state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state"><code>KeyValueStore</code></a> representing outputTable above it must be obtained via
 <a href="../KafkaStreams.html#store(org.apache.kafka.streams.StoreQueryParameters)"><code>KafkaStreams#store(...)</code></a>:
 For non-local keys, a custom RPC mechanism must be implemented using <a href="../KafkaStreams.html#metadataForAllStreamsClients()"><code>KafkaStreams.metadataForAllStreamsClients()</code></a> to
 query the value of the key on a parallel running instance of your Kafka Streams application.
 The store name to query with is specified by <a href="Materialized.html#as(java.lang.String)"><code>Materialized.as(String)</code></a> or <a href="Materialized.html#as(org.apache.kafka.streams.state.KeyValueBytesStoreSupplier)"><code>Materialized.as(KeyValueBytesStoreSupplier)</code></a>.
 <p>
 This operation preserves data co-location with respect to the key.
 Thus, <em>no</em> internal data redistribution is required if a key based operator (like a join) is applied to
 the result <code>KTable</code>.
 <p>
 Note that <code>mapValues</code> for a <i>changelog stream</i> works differently than <a href="KStream.html#mapValues(org.apache.kafka.streams.kstream.ValueMapper)"><code>record stream filters</code></a>, because <a href="../KeyValue.html" title="class in org.apache.kafka.streams"><code>records</code></a> with <code>null</code> values (so-called tombstone records)
 have delete semantics.
 Thus, for tombstones the provided value-mapper is not evaluated but the tombstone record is forwarded directly to
 delete the corresponding record in the result <code>KTable</code>.</div>
<dl class="notes">
<dt>Type Parameters:</dt>
<dd><code>VR</code> - the value type of the result <code>KTable</code></dd>
<dt>Parameters:</dt>
<dd><code>mapper</code> - a <a href="ValueMapper.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueMapper</code></a> that computes a new output value</dd>
<dd><code>named</code> - a <a href="Named.html" title="class in org.apache.kafka.streams.kstream"><code>Named</code></a> config used to name the processor in the topology</dd>
<dd><code>materialized</code> - a <a href="Materialized.html" title="class in org.apache.kafka.streams.kstream"><code>Materialized</code></a> that describes how the <a href="../processor/StateStore.html" title="interface in org.apache.kafka.streams.processor"><code>StateStore</code></a> for the resulting <code>KTable</code>
                      should be materialized. Cannot be <code>null</code></dd>
<dt>Returns:</dt>
<dd>a <code>KTable</code> that contains records with unmodified keys and new values (possibly of different type)</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="mapValues(org.apache.kafka.streams.kstream.ValueMapperWithKey,org.apache.kafka.streams.kstream.Materialized)">
<h3>mapValues</h3>
<div class="member-signature"><span class="type-parameters">&lt;VR&gt;</span>&nbsp;<span class="return-type"><a href="KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;VR&gt;</span>&nbsp;<span class="member-name">mapValues</span>&#8203;(<span class="parameters"><a href="ValueMapperWithKey.html" title="interface in org.apache.kafka.streams.kstream">ValueMapperWithKey</a>&lt;? super <a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;? super <a href="KTable.html" title="type parameter in KTable">V</a>,&#8203;? extends VR&gt;&nbsp;mapper,
<a href="Materialized.html" title="class in org.apache.kafka.streams.kstream">Materialized</a>&lt;<a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;VR,&#8203;<a href="../state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state">KeyValueStore</a>&lt;org.apache.kafka.common.utils.Bytes,&#8203;byte[]&gt;&gt;&nbsp;materialized)</span></div>
<div class="block">Create a new <code>KTable</code> by transforming the value of each record in this <code>KTable</code> into a new value
 (with possibly a new type) in the new <code>KTable</code>, with the <a href="../../common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization"><code>key serde</code></a>, <a href="../../common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization"><code>value serde</code></a>,
 and the underlying <a href="../state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state"><code>materialized state storage</code></a> configured in the <a href="Materialized.html" title="class in org.apache.kafka.streams.kstream"><code>Materialized</code></a>
 instance.
 For each <code>KTable</code> update the provided <a href="ValueMapperWithKey.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueMapperWithKey</code></a> is applied to the value of the update
 record and computes a new value for it, resulting in an updated record for the result <code>KTable</code>.
 Thus, an input record <code>&lt;K,V&gt;</code> can be transformed into an output record <code>&lt;K:V'&gt;</code>.
 This is a stateless record-by-record operation.
 <p>
 The example below counts the number of token of value and key strings.
 <pre><code>
 KTable&lt;String, String&gt; inputTable = builder.table("topic");
 KTable&lt;String, Integer&gt; outputTable = inputTable.mapValue(new ValueMapperWithKey&lt;String, String, Integer&gt; {
     Integer apply(String readOnlyKey, String value) {
          return readOnlyKey.split(" ").length + value.split(" ").length;
     }
 });
 </code></pre>
 <p>
 To query the local <a href="../state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state"><code>KeyValueStore</code></a> representing outputTable above it must be obtained via
 <a href="../KafkaStreams.html#store(org.apache.kafka.streams.StoreQueryParameters)"><code>KafkaStreams.store(StoreQueryParameters)</code></a>  KafkaStreams#store(...)}:
 For non-local keys, a custom RPC mechanism must be implemented using <a href="../KafkaStreams.html#metadataForAllStreamsClients()"><code>KafkaStreams.metadataForAllStreamsClients()</code></a> to
 query the value of the key on a parallel running instance of your Kafka Streams application.
 The store name to query with is specified by <a href="Materialized.html#as(java.lang.String)"><code>Materialized.as(String)</code></a> or <a href="Materialized.html#as(org.apache.kafka.streams.state.KeyValueBytesStoreSupplier)"><code>Materialized.as(KeyValueBytesStoreSupplier)</code></a>.
 <p>
 Note that the key is read-only and should not be modified, as this can lead to corrupt partitioning.
 This operation preserves data co-location with respect to the key.
 Thus, <em>no</em> internal data redistribution is required if a key based operator (like a join) is applied to
 the result <code>KTable</code>.
 <p>
 Note that <code>mapValues</code> for a <i>changelog stream</i> works differently than <a href="KStream.html#mapValues(org.apache.kafka.streams.kstream.ValueMapper)"><code>record stream filters</code></a>, because <a href="../KeyValue.html" title="class in org.apache.kafka.streams"><code>records</code></a> with <code>null</code> values (so-called tombstone records)
 have delete semantics.
 Thus, for tombstones the provided value-mapper is not evaluated but the tombstone record is forwarded directly to
 delete the corresponding record in the result <code>KTable</code>.</div>
<dl class="notes">
<dt>Type Parameters:</dt>
<dd><code>VR</code> - the value type of the result <code>KTable</code></dd>
<dt>Parameters:</dt>
<dd><code>mapper</code> - a <a href="ValueMapperWithKey.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueMapperWithKey</code></a> that computes a new output value</dd>
<dd><code>materialized</code> - a <a href="Materialized.html" title="class in org.apache.kafka.streams.kstream"><code>Materialized</code></a> that describes how the <a href="../processor/StateStore.html" title="interface in org.apache.kafka.streams.processor"><code>StateStore</code></a> for the resulting <code>KTable</code>
                      should be materialized. Cannot be <code>null</code></dd>
<dt>Returns:</dt>
<dd>a <code>KTable</code> that contains records with unmodified keys and new values (possibly of different type)</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="mapValues(org.apache.kafka.streams.kstream.ValueMapperWithKey,org.apache.kafka.streams.kstream.Named,org.apache.kafka.streams.kstream.Materialized)">
<h3>mapValues</h3>
<div class="member-signature"><span class="type-parameters">&lt;VR&gt;</span>&nbsp;<span class="return-type"><a href="KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;VR&gt;</span>&nbsp;<span class="member-name">mapValues</span>&#8203;(<span class="parameters"><a href="ValueMapperWithKey.html" title="interface in org.apache.kafka.streams.kstream">ValueMapperWithKey</a>&lt;? super <a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;? super <a href="KTable.html" title="type parameter in KTable">V</a>,&#8203;? extends VR&gt;&nbsp;mapper,
<a href="Named.html" title="class in org.apache.kafka.streams.kstream">Named</a>&nbsp;named,
<a href="Materialized.html" title="class in org.apache.kafka.streams.kstream">Materialized</a>&lt;<a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;VR,&#8203;<a href="../state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state">KeyValueStore</a>&lt;org.apache.kafka.common.utils.Bytes,&#8203;byte[]&gt;&gt;&nbsp;materialized)</span></div>
<div class="block">Create a new <code>KTable</code> by transforming the value of each record in this <code>KTable</code> into a new value
 (with possibly a new type) in the new <code>KTable</code>, with the <a href="../../common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization"><code>key serde</code></a>, <a href="../../common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization"><code>value serde</code></a>,
 and the underlying <a href="../state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state"><code>materialized state storage</code></a> configured in the <a href="Materialized.html" title="class in org.apache.kafka.streams.kstream"><code>Materialized</code></a>
 instance.
 For each <code>KTable</code> update the provided <a href="ValueMapperWithKey.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueMapperWithKey</code></a> is applied to the value of the update
 record and computes a new value for it, resulting in an updated record for the result <code>KTable</code>.
 Thus, an input record <code>&lt;K,V&gt;</code> can be transformed into an output record <code>&lt;K:V'&gt;</code>.
 This is a stateless record-by-record operation.
 <p>
 The example below counts the number of token of value and key strings.
 <pre><code>
 KTable&lt;String, String&gt; inputTable = builder.table("topic");
 KTable&lt;String, Integer&gt; outputTable = inputTable.mapValue(new ValueMapperWithKey&lt;String, String, Integer&gt; {
     Integer apply(String readOnlyKey, String value) {
          return readOnlyKey.split(" ").length + value.split(" ").length;
     }
 });
 </code></pre>
 <p>
 To query the local <a href="../state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state"><code>KeyValueStore</code></a> representing outputTable above it must be obtained via
 <a href="../KafkaStreams.html#store(org.apache.kafka.streams.StoreQueryParameters)"><code>KafkaStreams#store(...)</code></a>:
 For non-local keys, a custom RPC mechanism must be implemented using <a href="../KafkaStreams.html#metadataForAllStreamsClients()"><code>KafkaStreams.metadataForAllStreamsClients()</code></a> to
 query the value of the key on a parallel running instance of your Kafka Streams application.
 The store name to query with is specified by <a href="Materialized.html#as(java.lang.String)"><code>Materialized.as(String)</code></a> or <a href="Materialized.html#as(org.apache.kafka.streams.state.KeyValueBytesStoreSupplier)"><code>Materialized.as(KeyValueBytesStoreSupplier)</code></a>.
 <p>
 Note that the key is read-only and should not be modified, as this can lead to corrupt partitioning.
 This operation preserves data co-location with respect to the key.
 Thus, <em>no</em> internal data redistribution is required if a key based operator (like a join) is applied to
 the result <code>KTable</code>.
 <p>
 Note that <code>mapValues</code> for a <i>changelog stream</i> works differently than <a href="KStream.html#mapValues(org.apache.kafka.streams.kstream.ValueMapper)"><code>record stream filters</code></a>, because <a href="../KeyValue.html" title="class in org.apache.kafka.streams"><code>records</code></a> with <code>null</code> values (so-called tombstone records)
 have delete semantics.
 Thus, for tombstones the provided value-mapper is not evaluated but the tombstone record is forwarded directly to
 delete the corresponding record in the result <code>KTable</code>.</div>
<dl class="notes">
<dt>Type Parameters:</dt>
<dd><code>VR</code> - the value type of the result <code>KTable</code></dd>
<dt>Parameters:</dt>
<dd><code>mapper</code> - a <a href="ValueMapperWithKey.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueMapperWithKey</code></a> that computes a new output value</dd>
<dd><code>named</code> - a <a href="Named.html" title="class in org.apache.kafka.streams.kstream"><code>Named</code></a> config used to name the processor in the topology</dd>
<dd><code>materialized</code> - a <a href="Materialized.html" title="class in org.apache.kafka.streams.kstream"><code>Materialized</code></a> that describes how the <a href="../processor/StateStore.html" title="interface in org.apache.kafka.streams.processor"><code>StateStore</code></a> for the resulting <code>KTable</code>
                      should be materialized. Cannot be <code>null</code></dd>
<dt>Returns:</dt>
<dd>a <code>KTable</code> that contains records with unmodified keys and new values (possibly of different type)</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="toStream()">
<h3>toStream</h3>
<div class="member-signature"><span class="return-type"><a href="KStream.html" title="interface in org.apache.kafka.streams.kstream">KStream</a>&lt;<a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;<a href="KTable.html" title="type parameter in KTable">V</a>&gt;</span>&nbsp;<span class="member-name">toStream</span>()</div>
<div class="block">Convert this changelog stream to a <a href="KStream.html" title="interface in org.apache.kafka.streams.kstream"><code>KStream</code></a>.
 <p>
 Note that this is a logical operation and only changes the "interpretation" of the stream, i.e., each record of
 this changelog stream is no longer treated as an updated record (cf. <a href="KStream.html" title="interface in org.apache.kafka.streams.kstream"><code>KStream</code></a> vs <code>KTable</code>).</div>
<dl class="notes">
<dt>Returns:</dt>
<dd>a <a href="KStream.html" title="interface in org.apache.kafka.streams.kstream"><code>KStream</code></a> that contains the same records as this <code>KTable</code></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="toStream(org.apache.kafka.streams.kstream.Named)">
<h3>toStream</h3>
<div class="member-signature"><span class="return-type"><a href="KStream.html" title="interface in org.apache.kafka.streams.kstream">KStream</a>&lt;<a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;<a href="KTable.html" title="type parameter in KTable">V</a>&gt;</span>&nbsp;<span class="member-name">toStream</span>&#8203;(<span class="parameters"><a href="Named.html" title="class in org.apache.kafka.streams.kstream">Named</a>&nbsp;named)</span></div>
<div class="block">Convert this changelog stream to a <a href="KStream.html" title="interface in org.apache.kafka.streams.kstream"><code>KStream</code></a>.
 <p>
 Note that this is a logical operation and only changes the "interpretation" of the stream, i.e., each record of
 this changelog stream is no longer treated as an updated record (cf. <a href="KStream.html" title="interface in org.apache.kafka.streams.kstream"><code>KStream</code></a> vs <code>KTable</code>).</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>named</code> - a <a href="Named.html" title="class in org.apache.kafka.streams.kstream"><code>Named</code></a> config used to name the processor in the topology</dd>
<dt>Returns:</dt>
<dd>a <a href="KStream.html" title="interface in org.apache.kafka.streams.kstream"><code>KStream</code></a> that contains the same records as this <code>KTable</code></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="toStream(org.apache.kafka.streams.kstream.KeyValueMapper)">
<h3>toStream</h3>
<div class="member-signature"><span class="type-parameters">&lt;KR&gt;</span>&nbsp;<span class="return-type"><a href="KStream.html" title="interface in org.apache.kafka.streams.kstream">KStream</a>&lt;KR,&#8203;<a href="KTable.html" title="type parameter in KTable">V</a>&gt;</span>&nbsp;<span class="member-name">toStream</span>&#8203;(<span class="parameters"><a href="KeyValueMapper.html" title="interface in org.apache.kafka.streams.kstream">KeyValueMapper</a>&lt;? super <a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;? super <a href="KTable.html" title="type parameter in KTable">V</a>,&#8203;? extends KR&gt;&nbsp;mapper)</span></div>
<div class="block">Convert this changelog stream to a <a href="KStream.html" title="interface in org.apache.kafka.streams.kstream"><code>KStream</code></a> using the given <a href="KeyValueMapper.html" title="interface in org.apache.kafka.streams.kstream"><code>KeyValueMapper</code></a> to select the new key.
 <p>
 For example, you can compute the new key as the length of the value string.
 <pre><code>
 KTable&lt;String, String&gt; table = builder.table("topic");
 KTable&lt;Integer, String&gt; keyedStream = table.toStream(new KeyValueMapper&lt;String, String, Integer&gt; {
     Integer apply(String key, String value) {
         return value.length();
     }
 });
 </code></pre>
 Setting a new key might result in an internal data redistribution if a key based operator (like an aggregation or
 join) is applied to the result <a href="KStream.html" title="interface in org.apache.kafka.streams.kstream"><code>KStream</code></a>.
 <p>
 This operation is equivalent to calling
 <code>table.</code><a href="#toStream()"><code>toStream</code></a><code>().</code><a href="KStream.html#selectKey(org.apache.kafka.streams.kstream.KeyValueMapper)"><code>selectKey(KeyValueMapper)</code></a>.
 <p>
 Note that <a href="#toStream()"><code>toStream()</code></a> is a logical operation and only changes the "interpretation" of the stream, i.e.,
 each record of this changelog stream is no longer treated as an updated record (cf. <a href="KStream.html" title="interface in org.apache.kafka.streams.kstream"><code>KStream</code></a> vs <code>KTable</code>).</div>
<dl class="notes">
<dt>Type Parameters:</dt>
<dd><code>KR</code> - the new key type of the result stream</dd>
<dt>Parameters:</dt>
<dd><code>mapper</code> - a <a href="KeyValueMapper.html" title="interface in org.apache.kafka.streams.kstream"><code>KeyValueMapper</code></a> that computes a new key for each record</dd>
<dt>Returns:</dt>
<dd>a <a href="KStream.html" title="interface in org.apache.kafka.streams.kstream"><code>KStream</code></a> that contains the same records as this <code>KTable</code></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="toStream(org.apache.kafka.streams.kstream.KeyValueMapper,org.apache.kafka.streams.kstream.Named)">
<h3>toStream</h3>
<div class="member-signature"><span class="type-parameters">&lt;KR&gt;</span>&nbsp;<span class="return-type"><a href="KStream.html" title="interface in org.apache.kafka.streams.kstream">KStream</a>&lt;KR,&#8203;<a href="KTable.html" title="type parameter in KTable">V</a>&gt;</span>&nbsp;<span class="member-name">toStream</span>&#8203;(<span class="parameters"><a href="KeyValueMapper.html" title="interface in org.apache.kafka.streams.kstream">KeyValueMapper</a>&lt;? super <a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;? super <a href="KTable.html" title="type parameter in KTable">V</a>,&#8203;? extends KR&gt;&nbsp;mapper,
<a href="Named.html" title="class in org.apache.kafka.streams.kstream">Named</a>&nbsp;named)</span></div>
<div class="block">Convert this changelog stream to a <a href="KStream.html" title="interface in org.apache.kafka.streams.kstream"><code>KStream</code></a> using the given <a href="KeyValueMapper.html" title="interface in org.apache.kafka.streams.kstream"><code>KeyValueMapper</code></a> to select the new key.
 <p>
 For example, you can compute the new key as the length of the value string.
 <pre><code>
 KTable&lt;String, String&gt; table = builder.table("topic");
 KTable&lt;Integer, String&gt; keyedStream = table.toStream(new KeyValueMapper&lt;String, String, Integer&gt; {
     Integer apply(String key, String value) {
         return value.length();
     }
 });
 </code></pre>
 Setting a new key might result in an internal data redistribution if a key based operator (like an aggregation or
 join) is applied to the result <a href="KStream.html" title="interface in org.apache.kafka.streams.kstream"><code>KStream</code></a>.
 <p>
 This operation is equivalent to calling
 <code>table.</code><a href="#toStream()"><code>toStream</code></a><code>().</code><a href="KStream.html#selectKey(org.apache.kafka.streams.kstream.KeyValueMapper)"><code>selectKey(KeyValueMapper)</code></a>.
 <p>
 Note that <a href="#toStream()"><code>toStream()</code></a> is a logical operation and only changes the "interpretation" of the stream, i.e.,
 each record of this changelog stream is no longer treated as an updated record (cf. <a href="KStream.html" title="interface in org.apache.kafka.streams.kstream"><code>KStream</code></a> vs <code>KTable</code>).</div>
<dl class="notes">
<dt>Type Parameters:</dt>
<dd><code>KR</code> - the new key type of the result stream</dd>
<dt>Parameters:</dt>
<dd><code>mapper</code> - a <a href="KeyValueMapper.html" title="interface in org.apache.kafka.streams.kstream"><code>KeyValueMapper</code></a> that computes a new key for each record</dd>
<dd><code>named</code> - a <a href="Named.html" title="class in org.apache.kafka.streams.kstream"><code>Named</code></a> config used to name the processor in the topology</dd>
<dt>Returns:</dt>
<dd>a <a href="KStream.html" title="interface in org.apache.kafka.streams.kstream"><code>KStream</code></a> that contains the same records as this <code>KTable</code></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="suppress(org.apache.kafka.streams.kstream.Suppressed)">
<h3>suppress</h3>
<div class="member-signature"><span class="return-type"><a href="KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;<a href="KTable.html" title="type parameter in KTable">V</a>&gt;</span>&nbsp;<span class="member-name">suppress</span>&#8203;(<span class="parameters"><a href="Suppressed.html" title="interface in org.apache.kafka.streams.kstream">Suppressed</a>&lt;? super <a href="KTable.html" title="type parameter in KTable">K</a>&gt;&nbsp;suppressed)</span></div>
<div class="block">Suppress some updates from this changelog stream, determined by the supplied <a href="Suppressed.html" title="interface in org.apache.kafka.streams.kstream"><code>Suppressed</code></a> configuration.

 This controls what updates downstream table and stream operations will receive.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>suppressed</code> - Configuration object determining what, if any, updates to suppress</dd>
<dt>Returns:</dt>
<dd>A new KTable with the desired suppression characteristics.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="transformValues(org.apache.kafka.streams.kstream.ValueTransformerWithKeySupplier,java.lang.String...)">
<h3>transformValues</h3>
<div class="member-signature"><span class="type-parameters">&lt;VR&gt;</span>&nbsp;<span class="return-type"><a href="KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;VR&gt;</span>&nbsp;<span class="member-name">transformValues</span>&#8203;(<span class="parameters"><a href="ValueTransformerWithKeySupplier.html" title="interface in org.apache.kafka.streams.kstream">ValueTransformerWithKeySupplier</a>&lt;? super <a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;? super <a href="KTable.html" title="type parameter in KTable">V</a>,&#8203;? extends VR&gt;&nbsp;transformerSupplier,
<a href="https://docs.oracle.com/en/java/javase/15/docs/api/java.base/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a>...&nbsp;stateStoreNames)</span></div>
<div class="block">Create a new <code>KTable</code> by transforming the value of each record in this <code>KTable</code> into a new value
 (with possibly a new type), with default serializers, deserializers, and state store.
 A <a href="ValueTransformerWithKey.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueTransformerWithKey</code></a> (provided by the given <a href="ValueTransformerWithKeySupplier.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueTransformerWithKeySupplier</code></a>) is applied to each input
 record value and computes a new value for it.
 Thus, an input record <code>&lt;K,V&gt;</code> can be transformed into an output record <code>&lt;K:V'&gt;</code>.
 This is similar to <a href="#mapValues(org.apache.kafka.streams.kstream.ValueMapperWithKey)"><code>mapValues(ValueMapperWithKey)</code></a>, but more flexible, allowing access to additional state-stores,
 and access to the <a href="../processor/ProcessorContext.html" title="interface in org.apache.kafka.streams.processor"><code>ProcessorContext</code></a>.
 Furthermore, via <a href="../processor/Punctuator.html#punctuate(long)"><code>Punctuator.punctuate(long)</code></a> the processing progress can be observed and additional
 periodic actions can be performed.
 <p>
 If the downstream topology uses aggregation functions, (e.g. <a href="KGroupedTable.html#reduce(org.apache.kafka.streams.kstream.Reducer,org.apache.kafka.streams.kstream.Reducer,org.apache.kafka.streams.kstream.Materialized)"><code>KGroupedTable.reduce(org.apache.kafka.streams.kstream.Reducer&lt;V&gt;, org.apache.kafka.streams.kstream.Reducer&lt;V&gt;, org.apache.kafka.streams.kstream.Materialized&lt;K, V, org.apache.kafka.streams.state.KeyValueStore&lt;org.apache.kafka.common.utils.Bytes, byte[]&gt;&gt;)</code></a>, <a href="KGroupedTable.html#aggregate(org.apache.kafka.streams.kstream.Initializer,org.apache.kafka.streams.kstream.Aggregator,org.apache.kafka.streams.kstream.Aggregator,org.apache.kafka.streams.kstream.Materialized)"><code>KGroupedTable.aggregate(org.apache.kafka.streams.kstream.Initializer&lt;VR&gt;, org.apache.kafka.streams.kstream.Aggregator&lt;? super K, ? super V, VR&gt;, org.apache.kafka.streams.kstream.Aggregator&lt;? super K, ? super V, VR&gt;, org.apache.kafka.streams.kstream.Materialized&lt;K, VR, org.apache.kafka.streams.state.KeyValueStore&lt;org.apache.kafka.common.utils.Bytes, byte[]&gt;&gt;)</code></a>, etc),
 care must be taken when dealing with state, (either held in state-stores or transformer instances), to ensure correct aggregate results.
 In contrast, if the resulting KTable is materialized, (cf. <a href="#transformValues(org.apache.kafka.streams.kstream.ValueTransformerWithKeySupplier,org.apache.kafka.streams.kstream.Materialized,java.lang.String...)"><code>transformValues(ValueTransformerWithKeySupplier, Materialized, String...)</code></a>),
 such concerns are handled for you.
 <p>
 In order to assign a state, the state must be created and registered beforehand:
 <pre><code>
 // create store
 StoreBuilder&lt;KeyValueStore&lt;String,String&gt;&gt; keyValueStoreBuilder =
         Stores.keyValueStoreBuilder(Stores.persistentKeyValueStore("myValueTransformState"),
                 Serdes.String(),
                 Serdes.String());
 // register store
 builder.addStateStore(keyValueStoreBuilder);

 KTable outputTable = inputTable.transformValues(new ValueTransformerWithKeySupplier() { ... }, "myValueTransformState");
 </code></pre>
 <p>
 Within the <a href="ValueTransformerWithKey.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueTransformerWithKey</code></a>, the state is obtained via the
 <a href="../processor/ProcessorContext.html" title="interface in org.apache.kafka.streams.processor"><code>ProcessorContext</code></a>.
 To trigger periodic actions via <a href="../processor/Punctuator.html#punctuate(long)"><code>punctuate()</code></a>,
 a schedule must be registered.
 <pre><code>
 new ValueTransformerWithKeySupplier() {
     ValueTransformerWithKey get() {
         return new ValueTransformerWithKey() {
             private KeyValueStore&lt;String, String&gt; state;

             void init(ProcessorContext context) {
                 this.state = (KeyValueStore&lt;String, String&gt;)context.getStateStore("myValueTransformState");
                 context.schedule(Duration.ofSeconds(1), PunctuationType.WALL_CLOCK_TIME, new Punctuator(..)); // punctuate each 1000ms, can access this.state
             }

             NewValueType transform(K readOnlyKey, V value) {
                 // can access this.state and use read-only key
                 return new NewValueType(readOnlyKey); // or null
             }

             void close() {
                 // can access this.state
             }
         }
     }
 }
 </code></pre>
 <p>
 Note that the key is read-only and should not be modified, as this can lead to corrupt partitioning.
 Setting a new value preserves data co-location with respect to the key.</div>
<dl class="notes">
<dt>Type Parameters:</dt>
<dd><code>VR</code> - the value type of the result table</dd>
<dt>Parameters:</dt>
<dd><code>transformerSupplier</code> - a instance of <a href="ValueTransformerWithKeySupplier.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueTransformerWithKeySupplier</code></a> that generates a
                            <a href="ValueTransformerWithKey.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueTransformerWithKey</code></a>.
                            At least one transformer instance will be created per streaming task.
                            Transformers do not need to be thread-safe.</dd>
<dd><code>stateStoreNames</code> - the names of the state stores used by the processor</dd>
<dt>Returns:</dt>
<dd>a <code>KTable</code> that contains records with unmodified key and new values (possibly of different type)</dd>
<dt>See Also:</dt>
<dd><a href="#mapValues(org.apache.kafka.streams.kstream.ValueMapper)"><code>mapValues(ValueMapper)</code></a>, 
<a href="#mapValues(org.apache.kafka.streams.kstream.ValueMapperWithKey)"><code>mapValues(ValueMapperWithKey)</code></a></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="transformValues(org.apache.kafka.streams.kstream.ValueTransformerWithKeySupplier,org.apache.kafka.streams.kstream.Named,java.lang.String...)">
<h3>transformValues</h3>
<div class="member-signature"><span class="type-parameters">&lt;VR&gt;</span>&nbsp;<span class="return-type"><a href="KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;VR&gt;</span>&nbsp;<span class="member-name">transformValues</span>&#8203;(<span class="parameters"><a href="ValueTransformerWithKeySupplier.html" title="interface in org.apache.kafka.streams.kstream">ValueTransformerWithKeySupplier</a>&lt;? super <a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;? super <a href="KTable.html" title="type parameter in KTable">V</a>,&#8203;? extends VR&gt;&nbsp;transformerSupplier,
<a href="Named.html" title="class in org.apache.kafka.streams.kstream">Named</a>&nbsp;named,
<a href="https://docs.oracle.com/en/java/javase/15/docs/api/java.base/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a>...&nbsp;stateStoreNames)</span></div>
<div class="block">Create a new <code>KTable</code> by transforming the value of each record in this <code>KTable</code> into a new value
 (with possibly a new type), with default serializers, deserializers, and state store.
 A <a href="ValueTransformerWithKey.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueTransformerWithKey</code></a> (provided by the given <a href="ValueTransformerWithKeySupplier.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueTransformerWithKeySupplier</code></a>) is applied to each input
 record value and computes a new value for it.
 Thus, an input record <code>&lt;K,V&gt;</code> can be transformed into an output record <code>&lt;K:V'&gt;</code>.
 This is similar to <a href="#mapValues(org.apache.kafka.streams.kstream.ValueMapperWithKey)"><code>mapValues(ValueMapperWithKey)</code></a>, but more flexible, allowing access to additional state-stores,
 and access to the <a href="../processor/ProcessorContext.html" title="interface in org.apache.kafka.streams.processor"><code>ProcessorContext</code></a>.
 Furthermore, via <a href="../processor/Punctuator.html#punctuate(long)"><code>Punctuator.punctuate(long)</code></a> the processing progress can be observed and additional
 periodic actions can be performed.
 <p>
 If the downstream topology uses aggregation functions, (e.g. <a href="KGroupedTable.html#reduce(org.apache.kafka.streams.kstream.Reducer,org.apache.kafka.streams.kstream.Reducer,org.apache.kafka.streams.kstream.Materialized)"><code>KGroupedTable.reduce(org.apache.kafka.streams.kstream.Reducer&lt;V&gt;, org.apache.kafka.streams.kstream.Reducer&lt;V&gt;, org.apache.kafka.streams.kstream.Materialized&lt;K, V, org.apache.kafka.streams.state.KeyValueStore&lt;org.apache.kafka.common.utils.Bytes, byte[]&gt;&gt;)</code></a>, <a href="KGroupedTable.html#aggregate(org.apache.kafka.streams.kstream.Initializer,org.apache.kafka.streams.kstream.Aggregator,org.apache.kafka.streams.kstream.Aggregator,org.apache.kafka.streams.kstream.Materialized)"><code>KGroupedTable.aggregate(org.apache.kafka.streams.kstream.Initializer&lt;VR&gt;, org.apache.kafka.streams.kstream.Aggregator&lt;? super K, ? super V, VR&gt;, org.apache.kafka.streams.kstream.Aggregator&lt;? super K, ? super V, VR&gt;, org.apache.kafka.streams.kstream.Materialized&lt;K, VR, org.apache.kafka.streams.state.KeyValueStore&lt;org.apache.kafka.common.utils.Bytes, byte[]&gt;&gt;)</code></a>, etc),
 care must be taken when dealing with state, (either held in state-stores or transformer instances), to ensure correct aggregate results.
 In contrast, if the resulting KTable is materialized, (cf. <a href="#transformValues(org.apache.kafka.streams.kstream.ValueTransformerWithKeySupplier,org.apache.kafka.streams.kstream.Materialized,java.lang.String...)"><code>transformValues(ValueTransformerWithKeySupplier, Materialized, String...)</code></a>),
 such concerns are handled for you.
 <p>
 In order to assign a state, the state must be created and registered beforehand:
 <pre><code>
 // create store
 StoreBuilder&lt;KeyValueStore&lt;String,String&gt;&gt; keyValueStoreBuilder =
         Stores.keyValueStoreBuilder(Stores.persistentKeyValueStore("myValueTransformState"),
                 Serdes.String(),
                 Serdes.String());
 // register store
 builder.addStateStore(keyValueStoreBuilder);

 KTable outputTable = inputTable.transformValues(new ValueTransformerWithKeySupplier() { ... }, "myValueTransformState");
 </code></pre>
 <p>
 Within the <a href="ValueTransformerWithKey.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueTransformerWithKey</code></a>, the state is obtained via the
 <a href="../processor/ProcessorContext.html" title="interface in org.apache.kafka.streams.processor"><code>ProcessorContext</code></a>.
 To trigger periodic actions via <a href="../processor/Punctuator.html#punctuate(long)"><code>punctuate()</code></a>,
 a schedule must be registered.
 <pre><code>
 new ValueTransformerWithKeySupplier() {
     ValueTransformerWithKey get() {
         return new ValueTransformerWithKey() {
             private KeyValueStore&lt;String, String&gt; state;

             void init(ProcessorContext context) {
                 this.state = (KeyValueStore&lt;String, String&gt;)context.getStateStore("myValueTransformState");
                 context.schedule(Duration.ofSeconds(1), PunctuationType.WALL_CLOCK_TIME, new Punctuator(..)); // punctuate each 1000ms, can access this.state
             }

             NewValueType transform(K readOnlyKey, V value) {
                 // can access this.state and use read-only key
                 return new NewValueType(readOnlyKey); // or null
             }

             void close() {
                 // can access this.state
             }
         }
     }
 }
 </code></pre>
 <p>
 Note that the key is read-only and should not be modified, as this can lead to corrupt partitioning.
 Setting a new value preserves data co-location with respect to the key.</div>
<dl class="notes">
<dt>Type Parameters:</dt>
<dd><code>VR</code> - the value type of the result table</dd>
<dt>Parameters:</dt>
<dd><code>transformerSupplier</code> - a instance of <a href="ValueTransformerWithKeySupplier.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueTransformerWithKeySupplier</code></a> that generates a
                            <a href="ValueTransformerWithKey.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueTransformerWithKey</code></a>.
                            At least one transformer instance will be created per streaming task.
                            Transformers do not need to be thread-safe.</dd>
<dd><code>named</code> - a <a href="Named.html" title="class in org.apache.kafka.streams.kstream"><code>Named</code></a> config used to name the processor in the topology</dd>
<dd><code>stateStoreNames</code> - the names of the state stores used by the processor</dd>
<dt>Returns:</dt>
<dd>a <code>KTable</code> that contains records with unmodified key and new values (possibly of different type)</dd>
<dt>See Also:</dt>
<dd><a href="#mapValues(org.apache.kafka.streams.kstream.ValueMapper)"><code>mapValues(ValueMapper)</code></a>, 
<a href="#mapValues(org.apache.kafka.streams.kstream.ValueMapperWithKey)"><code>mapValues(ValueMapperWithKey)</code></a></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="transformValues(org.apache.kafka.streams.kstream.ValueTransformerWithKeySupplier,org.apache.kafka.streams.kstream.Materialized,java.lang.String...)">
<h3>transformValues</h3>
<div class="member-signature"><span class="type-parameters">&lt;VR&gt;</span>&nbsp;<span class="return-type"><a href="KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;VR&gt;</span>&nbsp;<span class="member-name">transformValues</span>&#8203;(<span class="parameters"><a href="ValueTransformerWithKeySupplier.html" title="interface in org.apache.kafka.streams.kstream">ValueTransformerWithKeySupplier</a>&lt;? super <a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;? super <a href="KTable.html" title="type parameter in KTable">V</a>,&#8203;? extends VR&gt;&nbsp;transformerSupplier,
<a href="Materialized.html" title="class in org.apache.kafka.streams.kstream">Materialized</a>&lt;<a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;VR,&#8203;<a href="../state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state">KeyValueStore</a>&lt;org.apache.kafka.common.utils.Bytes,&#8203;byte[]&gt;&gt;&nbsp;materialized,
<a href="https://docs.oracle.com/en/java/javase/15/docs/api/java.base/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a>...&nbsp;stateStoreNames)</span></div>
<div class="block">Create a new <code>KTable</code> by transforming the value of each record in this <code>KTable</code> into a new value
 (with possibly a new type), with the <a href="../../common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization"><code>key serde</code></a>, <a href="../../common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization"><code>value serde</code></a>, and the underlying
 <a href="../state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state"><code>materialized state storage</code></a> configured in the <a href="Materialized.html" title="class in org.apache.kafka.streams.kstream"><code>Materialized</code></a> instance.
 A <a href="ValueTransformerWithKey.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueTransformerWithKey</code></a> (provided by the given <a href="ValueTransformerWithKeySupplier.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueTransformerWithKeySupplier</code></a>) is applied to each input
 record value and computes a new value for it.
 This is similar to <a href="#mapValues(org.apache.kafka.streams.kstream.ValueMapperWithKey)"><code>mapValues(ValueMapperWithKey)</code></a>, but more flexible, allowing stateful, rather than stateless,
 record-by-record operation, access to additional state-stores, and access to the <a href="../processor/ProcessorContext.html" title="interface in org.apache.kafka.streams.processor"><code>ProcessorContext</code></a>.
 Furthermore, via <a href="../processor/Punctuator.html#punctuate(long)"><code>Punctuator.punctuate(long)</code></a> the processing progress can be observed and additional
 periodic actions can be performed.
 The resulting <code>KTable</code> is materialized into another state store (additional to the provided state store names)
 as specified by the user via <a href="Materialized.html" title="class in org.apache.kafka.streams.kstream"><code>Materialized</code></a> parameter, and is queryable through its given name.
 <p>
 In order to assign a state, the state must be created and registered beforehand:
 <pre><code>
 // create store
 StoreBuilder&lt;KeyValueStore&lt;String,String&gt;&gt; keyValueStoreBuilder =
         Stores.keyValueStoreBuilder(Stores.persistentKeyValueStore("myValueTransformState"),
                 Serdes.String(),
                 Serdes.String());
 // register store
 builder.addStateStore(keyValueStoreBuilder);

 KTable outputTable = inputTable.transformValues(
     new ValueTransformerWithKeySupplier() { ... },
     Materialized.&lt;String, String, KeyValueStore&lt;Bytes, byte[]&gt;&gt;as("outputTable")
                                 .withKeySerde(Serdes.String())
                                 .withValueSerde(Serdes.String()),
     "myValueTransformState");
 </code></pre>
 <p>
 Within the <a href="ValueTransformerWithKey.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueTransformerWithKey</code></a>, the state is obtained via the
 <a href="../processor/ProcessorContext.html" title="interface in org.apache.kafka.streams.processor"><code>ProcessorContext</code></a>.
 To trigger periodic actions via <a href="../processor/Punctuator.html#punctuate(long)"><code>punctuate()</code></a>,
 a schedule must be registered.
 <pre><code>
 new ValueTransformerWithKeySupplier() {
     ValueTransformerWithKey get() {
         return new ValueTransformerWithKey() {
             private KeyValueStore&lt;String, String&gt; state;

             void init(ProcessorContext context) {
                 this.state = (KeyValueStore&lt;String, String&gt;)context.getStateStore("myValueTransformState");
                 context.schedule(Duration.ofSeconds(1), PunctuationType.WALL_CLOCK_TIME, new Punctuator(..)); // punctuate each 1000ms, can access this.state
             }

             NewValueType transform(K readOnlyKey, V value) {
                 // can access this.state and use read-only key
                 return new NewValueType(readOnlyKey); // or null
             }

             void close() {
                 // can access this.state
             }
         }
     }
 }
 </code></pre>
 <p>
 Note that the key is read-only and should not be modified, as this can lead to corrupt partitioning.
 Setting a new value preserves data co-location with respect to the key.</div>
<dl class="notes">
<dt>Type Parameters:</dt>
<dd><code>VR</code> - the value type of the result table</dd>
<dt>Parameters:</dt>
<dd><code>transformerSupplier</code> - a instance of <a href="ValueTransformerWithKeySupplier.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueTransformerWithKeySupplier</code></a> that generates a
                            <a href="ValueTransformerWithKey.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueTransformerWithKey</code></a>.
                            At least one transformer instance will be created per streaming task.
                            Transformers do not need to be thread-safe.</dd>
<dd><code>materialized</code> - an instance of <a href="Materialized.html" title="class in org.apache.kafka.streams.kstream"><code>Materialized</code></a> used to describe how the state store of the
                            resulting table should be materialized.
                            Cannot be <code>null</code></dd>
<dd><code>stateStoreNames</code> - the names of the state stores used by the processor</dd>
<dt>Returns:</dt>
<dd>a <code>KTable</code> that contains records with unmodified key and new values (possibly of different type)</dd>
<dt>See Also:</dt>
<dd><a href="#mapValues(org.apache.kafka.streams.kstream.ValueMapper)"><code>mapValues(ValueMapper)</code></a>, 
<a href="#mapValues(org.apache.kafka.streams.kstream.ValueMapperWithKey)"><code>mapValues(ValueMapperWithKey)</code></a></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="transformValues(org.apache.kafka.streams.kstream.ValueTransformerWithKeySupplier,org.apache.kafka.streams.kstream.Materialized,org.apache.kafka.streams.kstream.Named,java.lang.String...)">
<h3>transformValues</h3>
<div class="member-signature"><span class="type-parameters">&lt;VR&gt;</span>&nbsp;<span class="return-type"><a href="KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;VR&gt;</span>&nbsp;<span class="member-name">transformValues</span>&#8203;(<span class="parameters"><a href="ValueTransformerWithKeySupplier.html" title="interface in org.apache.kafka.streams.kstream">ValueTransformerWithKeySupplier</a>&lt;? super <a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;? super <a href="KTable.html" title="type parameter in KTable">V</a>,&#8203;? extends VR&gt;&nbsp;transformerSupplier,
<a href="Materialized.html" title="class in org.apache.kafka.streams.kstream">Materialized</a>&lt;<a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;VR,&#8203;<a href="../state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state">KeyValueStore</a>&lt;org.apache.kafka.common.utils.Bytes,&#8203;byte[]&gt;&gt;&nbsp;materialized,
<a href="Named.html" title="class in org.apache.kafka.streams.kstream">Named</a>&nbsp;named,
<a href="https://docs.oracle.com/en/java/javase/15/docs/api/java.base/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a>...&nbsp;stateStoreNames)</span></div>
<div class="block">Create a new <code>KTable</code> by transforming the value of each record in this <code>KTable</code> into a new value
 (with possibly a new type), with the <a href="../../common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization"><code>key serde</code></a>, <a href="../../common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization"><code>value serde</code></a>, and the underlying
 <a href="../state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state"><code>materialized state storage</code></a> configured in the <a href="Materialized.html" title="class in org.apache.kafka.streams.kstream"><code>Materialized</code></a> instance.
 A <a href="ValueTransformerWithKey.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueTransformerWithKey</code></a> (provided by the given <a href="ValueTransformerWithKeySupplier.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueTransformerWithKeySupplier</code></a>) is applied to each input
 record value and computes a new value for it.
 This is similar to <a href="#mapValues(org.apache.kafka.streams.kstream.ValueMapperWithKey)"><code>mapValues(ValueMapperWithKey)</code></a>, but more flexible, allowing stateful, rather than stateless,
 record-by-record operation, access to additional state-stores, and access to the <a href="../processor/ProcessorContext.html" title="interface in org.apache.kafka.streams.processor"><code>ProcessorContext</code></a>.
 Furthermore, via <a href="../processor/Punctuator.html#punctuate(long)"><code>Punctuator.punctuate(long)</code></a> the processing progress can be observed and additional
 periodic actions can be performed.
 The resulting <code>KTable</code> is materialized into another state store (additional to the provided state store names)
 as specified by the user via <a href="Materialized.html" title="class in org.apache.kafka.streams.kstream"><code>Materialized</code></a> parameter, and is queryable through its given name.
 <p>
 In order to assign a state, the state must be created and registered beforehand:
 <pre><code>
 // create store
 StoreBuilder&lt;KeyValueStore&lt;String,String&gt;&gt; keyValueStoreBuilder =
         Stores.keyValueStoreBuilder(Stores.persistentKeyValueStore("myValueTransformState"),
                 Serdes.String(),
                 Serdes.String());
 // register store
 builder.addStateStore(keyValueStoreBuilder);

 KTable outputTable = inputTable.transformValues(
     new ValueTransformerWithKeySupplier() { ... },
     Materialized.&lt;String, String, KeyValueStore&lt;Bytes, byte[]&gt;&gt;as("outputTable")
                                 .withKeySerde(Serdes.String())
                                 .withValueSerde(Serdes.String()),
     "myValueTransformState");
 </code></pre>
 <p>
 Within the <a href="ValueTransformerWithKey.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueTransformerWithKey</code></a>, the state is obtained via the
 <a href="../processor/ProcessorContext.html" title="interface in org.apache.kafka.streams.processor"><code>ProcessorContext</code></a>.
 To trigger periodic actions via <a href="../processor/Punctuator.html#punctuate(long)"><code>punctuate()</code></a>,
 a schedule must be registered.
 <pre><code>
 new ValueTransformerWithKeySupplier() {
     ValueTransformerWithKey get() {
         return new ValueTransformerWithKey() {
             private KeyValueStore&lt;String, String&gt; state;

             void init(ProcessorContext context) {
                 this.state = (KeyValueStore&lt;String, String&gt;)context.getStateStore("myValueTransformState");
                 context.schedule(Duration.ofSeconds(1), PunctuationType.WALL_CLOCK_TIME, new Punctuator(..)); // punctuate each 1000ms, can access this.state
             }

             NewValueType transform(K readOnlyKey, V value) {
                 // can access this.state and use read-only key
                 return new NewValueType(readOnlyKey); // or null
             }

             void close() {
                 // can access this.state
             }
         }
     }
 }
 </code></pre>
 <p>
 Note that the key is read-only and should not be modified, as this can lead to corrupt partitioning.
 Setting a new value preserves data co-location with respect to the key.</div>
<dl class="notes">
<dt>Type Parameters:</dt>
<dd><code>VR</code> - the value type of the result table</dd>
<dt>Parameters:</dt>
<dd><code>transformerSupplier</code> - a instance of <a href="ValueTransformerWithKeySupplier.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueTransformerWithKeySupplier</code></a> that generates a
                            <a href="ValueTransformerWithKey.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueTransformerWithKey</code></a>.
                            At least one transformer instance will be created per streaming task.
                            Transformers do not need to be thread-safe.</dd>
<dd><code>materialized</code> - an instance of <a href="Materialized.html" title="class in org.apache.kafka.streams.kstream"><code>Materialized</code></a> used to describe how the state store of the
                            resulting table should be materialized.
                            Cannot be <code>null</code></dd>
<dd><code>named</code> - a <a href="Named.html" title="class in org.apache.kafka.streams.kstream"><code>Named</code></a> config used to name the processor in the topology</dd>
<dd><code>stateStoreNames</code> - the names of the state stores used by the processor</dd>
<dt>Returns:</dt>
<dd>a <code>KTable</code> that contains records with unmodified key and new values (possibly of different type)</dd>
<dt>See Also:</dt>
<dd><a href="#mapValues(org.apache.kafka.streams.kstream.ValueMapper)"><code>mapValues(ValueMapper)</code></a>, 
<a href="#mapValues(org.apache.kafka.streams.kstream.ValueMapperWithKey)"><code>mapValues(ValueMapperWithKey)</code></a></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="groupBy(org.apache.kafka.streams.kstream.KeyValueMapper)">
<h3>groupBy</h3>
<div class="member-signature"><span class="type-parameters">&lt;KR,&#8203;
VR&gt;</span>&nbsp;<span class="return-type"><a href="KGroupedTable.html" title="interface in org.apache.kafka.streams.kstream">KGroupedTable</a>&lt;KR,&#8203;VR&gt;</span>&nbsp;<span class="member-name">groupBy</span>&#8203;(<span class="parameters"><a href="KeyValueMapper.html" title="interface in org.apache.kafka.streams.kstream">KeyValueMapper</a>&lt;? super <a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;? super <a href="KTable.html" title="type parameter in KTable">V</a>,&#8203;<a href="../KeyValue.html" title="class in org.apache.kafka.streams">KeyValue</a>&lt;KR,&#8203;VR&gt;&gt;&nbsp;selector)</span></div>
<div class="block">Re-groups the records of this <code>KTable</code> using the provided <a href="KeyValueMapper.html" title="interface in org.apache.kafka.streams.kstream"><code>KeyValueMapper</code></a> and default serializers
 and deserializers.
 Each <a href="../KeyValue.html" title="class in org.apache.kafka.streams"><code>KeyValue</code></a> pair of this <code>KTable</code> is mapped to a new <a href="../KeyValue.html" title="class in org.apache.kafka.streams"><code>KeyValue</code></a> pair by applying the
 provided <a href="KeyValueMapper.html" title="interface in org.apache.kafka.streams.kstream"><code>KeyValueMapper</code></a>.
 Re-grouping a <code>KTable</code> is required before an aggregation operator can be applied to the data
 (cf. <a href="KGroupedTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KGroupedTable</code></a>).
 The <a href="KeyValueMapper.html" title="interface in org.apache.kafka.streams.kstream"><code>KeyValueMapper</code></a> selects a new key and value (with should both have unmodified type).
 If the new record key is <code>null</code> the record will not be included in the resulting <a href="KGroupedTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KGroupedTable</code></a>
 <p>
 Because a new key is selected, an internal repartitioning topic will be created in Kafka.
 This topic will be named "${applicationId}-&lt;name&gt;-repartition", where "applicationId" is user-specified in
 <a href="../StreamsConfig.html" title="class in org.apache.kafka.streams"><code>StreamsConfig</code></a> via parameter <a href="../StreamsConfig.html#APPLICATION_ID_CONFIG"><code>APPLICATION_ID_CONFIG</code></a>, "&lt;name&gt;" is
 an internally generated name, and "-repartition" is a fixed suffix.

 You can retrieve all generated internal topic names via <a href="../Topology.html#describe()"><code>Topology.describe()</code></a>.

 <p>
 All data of this <code>KTable</code> will be redistributed through the repartitioning topic by writing all update
 records to and rereading all updated records from it, such that the resulting <a href="KGroupedTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KGroupedTable</code></a> is partitioned
 on the new key.
 <p>
 If the key or value type is changed, it is recommended to use <a href="#groupBy(org.apache.kafka.streams.kstream.KeyValueMapper,org.apache.kafka.streams.kstream.Grouped)"><code>groupBy(KeyValueMapper, Grouped)</code></a>
 instead.</div>
<dl class="notes">
<dt>Type Parameters:</dt>
<dd><code>KR</code> - the key type of the result <a href="KGroupedTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KGroupedTable</code></a></dd>
<dd><code>VR</code> - the value type of the result <a href="KGroupedTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KGroupedTable</code></a></dd>
<dt>Parameters:</dt>
<dd><code>selector</code> - a <a href="KeyValueMapper.html" title="interface in org.apache.kafka.streams.kstream"><code>KeyValueMapper</code></a> that computes a new grouping key and value to be aggregated</dd>
<dt>Returns:</dt>
<dd>a <a href="KGroupedTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KGroupedTable</code></a> that contains the re-grouped records of the original <code>KTable</code></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="groupBy(org.apache.kafka.streams.kstream.KeyValueMapper,org.apache.kafka.streams.kstream.Grouped)">
<h3>groupBy</h3>
<div class="member-signature"><span class="type-parameters">&lt;KR,&#8203;
VR&gt;</span>&nbsp;<span class="return-type"><a href="KGroupedTable.html" title="interface in org.apache.kafka.streams.kstream">KGroupedTable</a>&lt;KR,&#8203;VR&gt;</span>&nbsp;<span class="member-name">groupBy</span>&#8203;(<span class="parameters"><a href="KeyValueMapper.html" title="interface in org.apache.kafka.streams.kstream">KeyValueMapper</a>&lt;? super <a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;? super <a href="KTable.html" title="type parameter in KTable">V</a>,&#8203;<a href="../KeyValue.html" title="class in org.apache.kafka.streams">KeyValue</a>&lt;KR,&#8203;VR&gt;&gt;&nbsp;selector,
<a href="Grouped.html" title="class in org.apache.kafka.streams.kstream">Grouped</a>&lt;KR,&#8203;VR&gt;&nbsp;grouped)</span></div>
<div class="block">Re-groups the records of this <code>KTable</code> using the provided <a href="KeyValueMapper.html" title="interface in org.apache.kafka.streams.kstream"><code>KeyValueMapper</code></a>
 and <a href="../../common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization"><code>Serde</code></a>s as specified by <a href="Grouped.html" title="class in org.apache.kafka.streams.kstream"><code>Grouped</code></a>.
 Each <a href="../KeyValue.html" title="class in org.apache.kafka.streams"><code>KeyValue</code></a> pair of this <code>KTable</code> is mapped to a new <a href="../KeyValue.html" title="class in org.apache.kafka.streams"><code>KeyValue</code></a> pair by applying the
 provided <a href="KeyValueMapper.html" title="interface in org.apache.kafka.streams.kstream"><code>KeyValueMapper</code></a>.
 Re-grouping a <code>KTable</code> is required before an aggregation operator can be applied to the data
 (cf. <a href="KGroupedTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KGroupedTable</code></a>).
 The <a href="KeyValueMapper.html" title="interface in org.apache.kafka.streams.kstream"><code>KeyValueMapper</code></a> selects a new key and value (where both could the same type or a new type).
 If the new record key is <code>null</code> the record will not be included in the resulting <a href="KGroupedTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KGroupedTable</code></a>
 <p>
 Because a new key is selected, an internal repartitioning topic will be created in Kafka.
 This topic will be named "${applicationId}-&lt;name&gt;-repartition", where "applicationId" is user-specified in
 <a href="../StreamsConfig.html" title="class in org.apache.kafka.streams"><code>StreamsConfig</code></a> via parameter <a href="../StreamsConfig.html#APPLICATION_ID_CONFIG"><code>APPLICATION_ID_CONFIG</code></a>,  "&lt;name&gt;" is
 either provided via <a href="Grouped.html#as(java.lang.String)"><code>Grouped.as(String)</code></a> or an internally generated name.

 <p>
 You can retrieve all generated internal topic names via <a href="../Topology.html#describe()"><code>Topology.describe()</code></a>.

 <p>
 All data of this <code>KTable</code> will be redistributed through the repartitioning topic by writing all update
 records to and rereading all updated records from it, such that the resulting <a href="KGroupedTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KGroupedTable</code></a> is partitioned
 on the new key.</div>
<dl class="notes">
<dt>Type Parameters:</dt>
<dd><code>KR</code> - the key type of the result <a href="KGroupedTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KGroupedTable</code></a></dd>
<dd><code>VR</code> - the value type of the result <a href="KGroupedTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KGroupedTable</code></a></dd>
<dt>Parameters:</dt>
<dd><code>selector</code> - a <a href="KeyValueMapper.html" title="interface in org.apache.kafka.streams.kstream"><code>KeyValueMapper</code></a> that computes a new grouping key and value to be aggregated</dd>
<dd><code>grouped</code> - the <a href="Grouped.html" title="class in org.apache.kafka.streams.kstream"><code>Grouped</code></a> instance used to specify <a href="../../common/serialization/Serdes.html" title="class in org.apache.kafka.common.serialization"><code>Serdes</code></a>
                      and the name for a repartition topic if repartitioning is required.</dd>
<dt>Returns:</dt>
<dd>a <a href="KGroupedTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KGroupedTable</code></a> that contains the re-grouped records of the original <code>KTable</code></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="join(org.apache.kafka.streams.kstream.KTable,org.apache.kafka.streams.kstream.ValueJoiner)">
<h3>join</h3>
<div class="member-signature"><span class="type-parameters">&lt;VO,&#8203;
VR&gt;</span>&nbsp;<span class="return-type"><a href="KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;VR&gt;</span>&nbsp;<span class="member-name">join</span>&#8203;(<span class="parameters"><a href="KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;VO&gt;&nbsp;other,
<a href="ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream">ValueJoiner</a>&lt;? super <a href="KTable.html" title="type parameter in KTable">V</a>,&#8203;? super VO,&#8203;? extends VR&gt;&nbsp;joiner)</span></div>
<div class="block">Join records of this <code>KTable</code> with another <code>KTable</code>'s records using non-windowed inner equi join,
 with default serializers, deserializers, and state store.
 The join is a primary key join with join attribute <code>thisKTable.key == otherKTable.key</code>.
 The result is an ever updating <code>KTable</code> that represents the <em>current</em> (i.e., processing time) result
 of the join.
 <p>
 The join is computed by (1) updating the internal state of one <code>KTable</code> and (2) performing a lookup for a
 matching record in the <em>current</em> (i.e., processing time) internal state of the other <code>KTable</code>.
 This happens in a symmetric way, i.e., for each update of either <code>this</code> or the <code>other</code> input
 <code>KTable</code> the result gets updated.
 <p>
 For each <code>KTable</code> record that finds a corresponding record in the other <code>KTable</code> the provided
 <a href="ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueJoiner</code></a> will be called to compute a value (with arbitrary type) for the result record.
 The key of the result record is the same as for both joining input records.
 <p>
 Note that <a href="../KeyValue.html" title="class in org.apache.kafka.streams"><code>records</code></a> with <code>null</code> values (so-called tombstone records) have delete semantics.
 Thus, for input tombstones the provided value-joiner is not called but a tombstone record is forwarded
 directly to delete a record in the result <code>KTable</code> if required (i.e., if there is anything to be deleted).
 <p>
 Input records with <code>null</code> key will be dropped and no join computation is performed.
 <p>
 Example:
 <table border='1'>
 <tr>
 <th>thisKTable</th>
 <th>thisState</th>
 <th>otherKTable</th>
 <th>otherState</th>
 <th>result updated record</th>
 </tr>
 <tr>
 <td>&lt;K1:A&gt;</td>
 <td>&lt;K1:A&gt;</td>
 <td></td>
 <td></td>
 <td></td>
 </tr>
 <tr>
 <td></td>
 <td>&lt;K1:A&gt;</td>
 <td>&lt;K1:b&gt;</td>
 <td>&lt;K1:b&gt;</td>
 <td>&lt;K1:ValueJoiner(A,b)&gt;</td>
 </tr>
 <tr>
 <td>&lt;K1:C&gt;</td>
 <td>&lt;K1:C&gt;</td>
 <td></td>
 <td>&lt;K1:b&gt;</td>
 <td>&lt;K1:ValueJoiner(C,b)&gt;</td>
 </tr>
 <tr>
 <td></td>
 <td>&lt;K1:C&gt;</td>
 <td>&lt;K1:null&gt;</td>
 <td></td>
 <td>&lt;K1:null&gt;</td>
 </tr>
 </table>
 Both input streams (or to be more precise, their underlying source topics) need to have the same number of
 partitions.</div>
<dl class="notes">
<dt>Type Parameters:</dt>
<dd><code>VO</code> - the value type of the other <code>KTable</code></dd>
<dd><code>VR</code> - the value type of the result <code>KTable</code></dd>
<dt>Parameters:</dt>
<dd><code>other</code> - the other <code>KTable</code> to be joined with this <code>KTable</code></dd>
<dd><code>joiner</code> - a <a href="ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueJoiner</code></a> that computes the join result for a pair of matching records</dd>
<dt>Returns:</dt>
<dd>a <code>KTable</code> that contains join-records for each key and values computed by the given
 <a href="ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueJoiner</code></a>, one for each matched record-pair with the same key</dd>
<dt>See Also:</dt>
<dd><a href="#leftJoin(org.apache.kafka.streams.kstream.KTable,org.apache.kafka.streams.kstream.ValueJoiner)"><code>leftJoin(KTable, ValueJoiner)</code></a>, 
<a href="#outerJoin(org.apache.kafka.streams.kstream.KTable,org.apache.kafka.streams.kstream.ValueJoiner)"><code>outerJoin(KTable, ValueJoiner)</code></a></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="join(org.apache.kafka.streams.kstream.KTable,org.apache.kafka.streams.kstream.ValueJoiner,org.apache.kafka.streams.kstream.Named)">
<h3>join</h3>
<div class="member-signature"><span class="type-parameters">&lt;VO,&#8203;
VR&gt;</span>&nbsp;<span class="return-type"><a href="KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;VR&gt;</span>&nbsp;<span class="member-name">join</span>&#8203;(<span class="parameters"><a href="KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;VO&gt;&nbsp;other,
<a href="ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream">ValueJoiner</a>&lt;? super <a href="KTable.html" title="type parameter in KTable">V</a>,&#8203;? super VO,&#8203;? extends VR&gt;&nbsp;joiner,
<a href="Named.html" title="class in org.apache.kafka.streams.kstream">Named</a>&nbsp;named)</span></div>
<div class="block">Join records of this <code>KTable</code> with another <code>KTable</code>'s records using non-windowed inner equi join,
 with default serializers, deserializers, and state store.
 The join is a primary key join with join attribute <code>thisKTable.key == otherKTable.key</code>.
 The result is an ever updating <code>KTable</code> that represents the <em>current</em> (i.e., processing time) result
 of the join.
 <p>
 The join is computed by (1) updating the internal state of one <code>KTable</code> and (2) performing a lookup for a
 matching record in the <em>current</em> (i.e., processing time) internal state of the other <code>KTable</code>.
 This happens in a symmetric way, i.e., for each update of either <code>this</code> or the <code>other</code> input
 <code>KTable</code> the result gets updated.
 <p>
 For each <code>KTable</code> record that finds a corresponding record in the other <code>KTable</code> the provided
 <a href="ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueJoiner</code></a> will be called to compute a value (with arbitrary type) for the result record.
 The key of the result record is the same as for both joining input records.
 <p>
 Note that <a href="../KeyValue.html" title="class in org.apache.kafka.streams"><code>records</code></a> with <code>null</code> values (so-called tombstone records) have delete semantics.
 Thus, for input tombstones the provided value-joiner is not called but a tombstone record is forwarded
 directly to delete a record in the result <code>KTable</code> if required (i.e., if there is anything to be deleted).
 <p>
 Input records with <code>null</code> key will be dropped and no join computation is performed.
 <p>
 Example:
 <table border='1'>
 <tr>
 <th>thisKTable</th>
 <th>thisState</th>
 <th>otherKTable</th>
 <th>otherState</th>
 <th>result updated record</th>
 </tr>
 <tr>
 <td>&lt;K1:A&gt;</td>
 <td>&lt;K1:A&gt;</td>
 <td></td>
 <td></td>
 <td></td>
 </tr>
 <tr>
 <td></td>
 <td>&lt;K1:A&gt;</td>
 <td>&lt;K1:b&gt;</td>
 <td>&lt;K1:b&gt;</td>
 <td>&lt;K1:ValueJoiner(A,b)&gt;</td>
 </tr>
 <tr>
 <td>&lt;K1:C&gt;</td>
 <td>&lt;K1:C&gt;</td>
 <td></td>
 <td>&lt;K1:b&gt;</td>
 <td>&lt;K1:ValueJoiner(C,b)&gt;</td>
 </tr>
 <tr>
 <td></td>
 <td>&lt;K1:C&gt;</td>
 <td>&lt;K1:null&gt;</td>
 <td></td>
 <td>&lt;K1:null&gt;</td>
 </tr>
 </table>
 Both input streams (or to be more precise, their underlying source topics) need to have the same number of
 partitions.</div>
<dl class="notes">
<dt>Type Parameters:</dt>
<dd><code>VO</code> - the value type of the other <code>KTable</code></dd>
<dd><code>VR</code> - the value type of the result <code>KTable</code></dd>
<dt>Parameters:</dt>
<dd><code>other</code> - the other <code>KTable</code> to be joined with this <code>KTable</code></dd>
<dd><code>joiner</code> - a <a href="ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueJoiner</code></a> that computes the join result for a pair of matching records</dd>
<dd><code>named</code> - a <a href="Named.html" title="class in org.apache.kafka.streams.kstream"><code>Named</code></a> config used to name the processor in the topology</dd>
<dt>Returns:</dt>
<dd>a <code>KTable</code> that contains join-records for each key and values computed by the given
 <a href="ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueJoiner</code></a>, one for each matched record-pair with the same key</dd>
<dt>See Also:</dt>
<dd><a href="#leftJoin(org.apache.kafka.streams.kstream.KTable,org.apache.kafka.streams.kstream.ValueJoiner)"><code>leftJoin(KTable, ValueJoiner)</code></a>, 
<a href="#outerJoin(org.apache.kafka.streams.kstream.KTable,org.apache.kafka.streams.kstream.ValueJoiner)"><code>outerJoin(KTable, ValueJoiner)</code></a></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="join(org.apache.kafka.streams.kstream.KTable,org.apache.kafka.streams.kstream.ValueJoiner,org.apache.kafka.streams.kstream.Materialized)">
<h3>join</h3>
<div class="member-signature"><span class="type-parameters">&lt;VO,&#8203;
VR&gt;</span>&nbsp;<span class="return-type"><a href="KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;VR&gt;</span>&nbsp;<span class="member-name">join</span>&#8203;(<span class="parameters"><a href="KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;VO&gt;&nbsp;other,
<a href="ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream">ValueJoiner</a>&lt;? super <a href="KTable.html" title="type parameter in KTable">V</a>,&#8203;? super VO,&#8203;? extends VR&gt;&nbsp;joiner,
<a href="Materialized.html" title="class in org.apache.kafka.streams.kstream">Materialized</a>&lt;<a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;VR,&#8203;<a href="../state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state">KeyValueStore</a>&lt;org.apache.kafka.common.utils.Bytes,&#8203;byte[]&gt;&gt;&nbsp;materialized)</span></div>
<div class="block">Join records of this <code>KTable</code> with another <code>KTable</code>'s records using non-windowed inner equi join,
 with the <a href="Materialized.html" title="class in org.apache.kafka.streams.kstream"><code>Materialized</code></a> instance for configuration of the <a href="../../common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization"><code>key serde</code></a>,
 <a href="../../common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization"><code>the result table's value serde</code></a>, and <a href="../state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state"><code>state store</code></a>.
 The join is a primary key join with join attribute <code>thisKTable.key == otherKTable.key</code>.
 The result is an ever updating <code>KTable</code> that represents the <em>current</em> (i.e., processing time) result
 of the join.
 <p>
 The join is computed by (1) updating the internal state of one <code>KTable</code> and (2) performing a lookup for a
 matching record in the <em>current</em> (i.e., processing time) internal state of the other <code>KTable</code>.
 This happens in a symmetric way, i.e., for each update of either <code>this</code> or the <code>other</code> input
 <code>KTable</code> the result gets updated.
 <p>
 For each <code>KTable</code> record that finds a corresponding record in the other <code>KTable</code> the provided
 <a href="ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueJoiner</code></a> will be called to compute a value (with arbitrary type) for the result record.
 The key of the result record is the same as for both joining input records.
 <p>
 Note that <a href="../KeyValue.html" title="class in org.apache.kafka.streams"><code>records</code></a> with <code>null</code> values (so-called tombstone records) have delete semantics.
 Thus, for input tombstones the provided value-joiner is not called but a tombstone record is forwarded
 directly to delete a record in the result <code>KTable</code> if required (i.e., if there is anything to be deleted).
 <p>
 Input records with <code>null</code> key will be dropped and no join computation is performed.
 <p>
 Example:
 <table border='1'>
 <tr>
 <th>thisKTable</th>
 <th>thisState</th>
 <th>otherKTable</th>
 <th>otherState</th>
 <th>result updated record</th>
 </tr>
 <tr>
 <td>&lt;K1:A&gt;</td>
 <td>&lt;K1:A&gt;</td>
 <td></td>
 <td></td>
 <td></td>
 </tr>
 <tr>
 <td></td>
 <td>&lt;K1:A&gt;</td>
 <td>&lt;K1:b&gt;</td>
 <td>&lt;K1:b&gt;</td>
 <td>&lt;K1:ValueJoiner(A,b)&gt;</td>
 </tr>
 <tr>
 <td>&lt;K1:C&gt;</td>
 <td>&lt;K1:C&gt;</td>
 <td></td>
 <td>&lt;K1:b&gt;</td>
 <td>&lt;K1:ValueJoiner(C,b)&gt;</td>
 </tr>
 <tr>
 <td></td>
 <td>&lt;K1:C&gt;</td>
 <td>&lt;K1:null&gt;</td>
 <td></td>
 <td>&lt;K1:null&gt;</td>
 </tr>
 </table>
 Both input streams (or to be more precise, their underlying source topics) need to have the same number of
 partitions.</div>
<dl class="notes">
<dt>Type Parameters:</dt>
<dd><code>VO</code> - the value type of the other <code>KTable</code></dd>
<dd><code>VR</code> - the value type of the result <code>KTable</code></dd>
<dt>Parameters:</dt>
<dd><code>other</code> - the other <code>KTable</code> to be joined with this <code>KTable</code></dd>
<dd><code>joiner</code> - a <a href="ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueJoiner</code></a> that computes the join result for a pair of matching records</dd>
<dd><code>materialized</code> - an instance of <a href="Materialized.html" title="class in org.apache.kafka.streams.kstream"><code>Materialized</code></a> used to describe how the state store should be materialized.
                      Cannot be <code>null</code></dd>
<dt>Returns:</dt>
<dd>a <code>KTable</code> that contains join-records for each key and values computed by the given
 <a href="ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueJoiner</code></a>, one for each matched record-pair with the same key</dd>
<dt>See Also:</dt>
<dd><a href="#leftJoin(org.apache.kafka.streams.kstream.KTable,org.apache.kafka.streams.kstream.ValueJoiner,org.apache.kafka.streams.kstream.Materialized)"><code>leftJoin(KTable, ValueJoiner, Materialized)</code></a>, 
<a href="#outerJoin(org.apache.kafka.streams.kstream.KTable,org.apache.kafka.streams.kstream.ValueJoiner,org.apache.kafka.streams.kstream.Materialized)"><code>outerJoin(KTable, ValueJoiner, Materialized)</code></a></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="join(org.apache.kafka.streams.kstream.KTable,org.apache.kafka.streams.kstream.ValueJoiner,org.apache.kafka.streams.kstream.Named,org.apache.kafka.streams.kstream.Materialized)">
<h3>join</h3>
<div class="member-signature"><span class="type-parameters">&lt;VO,&#8203;
VR&gt;</span>&nbsp;<span class="return-type"><a href="KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;VR&gt;</span>&nbsp;<span class="member-name">join</span>&#8203;(<span class="parameters"><a href="KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;VO&gt;&nbsp;other,
<a href="ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream">ValueJoiner</a>&lt;? super <a href="KTable.html" title="type parameter in KTable">V</a>,&#8203;? super VO,&#8203;? extends VR&gt;&nbsp;joiner,
<a href="Named.html" title="class in org.apache.kafka.streams.kstream">Named</a>&nbsp;named,
<a href="Materialized.html" title="class in org.apache.kafka.streams.kstream">Materialized</a>&lt;<a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;VR,&#8203;<a href="../state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state">KeyValueStore</a>&lt;org.apache.kafka.common.utils.Bytes,&#8203;byte[]&gt;&gt;&nbsp;materialized)</span></div>
<div class="block">Join records of this <code>KTable</code> with another <code>KTable</code>'s records using non-windowed inner equi join,
 with the <a href="Materialized.html" title="class in org.apache.kafka.streams.kstream"><code>Materialized</code></a> instance for configuration of the <a href="../../common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization"><code>key serde</code></a>,
 <a href="../../common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization"><code>the result table's value serde</code></a>, and <a href="../state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state"><code>state store</code></a>.
 The join is a primary key join with join attribute <code>thisKTable.key == otherKTable.key</code>.
 The result is an ever updating <code>KTable</code> that represents the <em>current</em> (i.e., processing time) result
 of the join.
 <p>
 The join is computed by (1) updating the internal state of one <code>KTable</code> and (2) performing a lookup for a
 matching record in the <em>current</em> (i.e., processing time) internal state of the other <code>KTable</code>.
 This happens in a symmetric way, i.e., for each update of either <code>this</code> or the <code>other</code> input
 <code>KTable</code> the result gets updated.
 <p>
 For each <code>KTable</code> record that finds a corresponding record in the other <code>KTable</code> the provided
 <a href="ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueJoiner</code></a> will be called to compute a value (with arbitrary type) for the result record.
 The key of the result record is the same as for both joining input records.
 <p>
 Note that <a href="../KeyValue.html" title="class in org.apache.kafka.streams"><code>records</code></a> with <code>null</code> values (so-called tombstone records) have delete semantics.
 Thus, for input tombstones the provided value-joiner is not called but a tombstone record is forwarded
 directly to delete a record in the result <code>KTable</code> if required (i.e., if there is anything to be deleted).
 <p>
 Input records with <code>null</code> key will be dropped and no join computation is performed.
 <p>
 Example:
 <table border='1'>
 <tr>
 <th>thisKTable</th>
 <th>thisState</th>
 <th>otherKTable</th>
 <th>otherState</th>
 <th>result updated record</th>
 </tr>
 <tr>
 <td>&lt;K1:A&gt;</td>
 <td>&lt;K1:A&gt;</td>
 <td></td>
 <td></td>
 <td></td>
 </tr>
 <tr>
 <td></td>
 <td>&lt;K1:A&gt;</td>
 <td>&lt;K1:b&gt;</td>
 <td>&lt;K1:b&gt;</td>
 <td>&lt;K1:ValueJoiner(A,b)&gt;</td>
 </tr>
 <tr>
 <td>&lt;K1:C&gt;</td>
 <td>&lt;K1:C&gt;</td>
 <td></td>
 <td>&lt;K1:b&gt;</td>
 <td>&lt;K1:ValueJoiner(C,b)&gt;</td>
 </tr>
 <tr>
 <td></td>
 <td>&lt;K1:C&gt;</td>
 <td>&lt;K1:null&gt;</td>
 <td></td>
 <td>&lt;K1:null&gt;</td>
 </tr>
 </table>
 Both input streams (or to be more precise, their underlying source topics) need to have the same number of
 partitions.</div>
<dl class="notes">
<dt>Type Parameters:</dt>
<dd><code>VO</code> - the value type of the other <code>KTable</code></dd>
<dd><code>VR</code> - the value type of the result <code>KTable</code></dd>
<dt>Parameters:</dt>
<dd><code>other</code> - the other <code>KTable</code> to be joined with this <code>KTable</code></dd>
<dd><code>joiner</code> - a <a href="ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueJoiner</code></a> that computes the join result for a pair of matching records</dd>
<dd><code>named</code> - a <a href="Named.html" title="class in org.apache.kafka.streams.kstream"><code>Named</code></a> config used to name the processor in the topology</dd>
<dd><code>materialized</code> - an instance of <a href="Materialized.html" title="class in org.apache.kafka.streams.kstream"><code>Materialized</code></a> used to describe how the state store should be materialized.
                      Cannot be <code>null</code></dd>
<dt>Returns:</dt>
<dd>a <code>KTable</code> that contains join-records for each key and values computed by the given
 <a href="ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueJoiner</code></a>, one for each matched record-pair with the same key</dd>
<dt>See Also:</dt>
<dd><a href="#leftJoin(org.apache.kafka.streams.kstream.KTable,org.apache.kafka.streams.kstream.ValueJoiner,org.apache.kafka.streams.kstream.Materialized)"><code>leftJoin(KTable, ValueJoiner, Materialized)</code></a>, 
<a href="#outerJoin(org.apache.kafka.streams.kstream.KTable,org.apache.kafka.streams.kstream.ValueJoiner,org.apache.kafka.streams.kstream.Materialized)"><code>outerJoin(KTable, ValueJoiner, Materialized)</code></a></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="leftJoin(org.apache.kafka.streams.kstream.KTable,org.apache.kafka.streams.kstream.ValueJoiner)">
<h3>leftJoin</h3>
<div class="member-signature"><span class="type-parameters">&lt;VO,&#8203;
VR&gt;</span>&nbsp;<span class="return-type"><a href="KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;VR&gt;</span>&nbsp;<span class="member-name">leftJoin</span>&#8203;(<span class="parameters"><a href="KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;VO&gt;&nbsp;other,
<a href="ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream">ValueJoiner</a>&lt;? super <a href="KTable.html" title="type parameter in KTable">V</a>,&#8203;? super VO,&#8203;? extends VR&gt;&nbsp;joiner)</span></div>
<div class="block">Join records of this <code>KTable</code> (left input) with another <code>KTable</code>'s (right input) records using
 non-windowed left equi join, with default serializers, deserializers, and state store.
 The join is a primary key join with join attribute <code>thisKTable.key == otherKTable.key</code>.
 In contrast to <a href="#join(org.apache.kafka.streams.kstream.KTable,org.apache.kafka.streams.kstream.ValueJoiner)"><code>inner-join</code></a>, all records from left <code>KTable</code> will produce
 an output record (cf. below).
 The result is an ever updating <code>KTable</code> that represents the <em>current</em> (i.e., processing time) result
 of the join.
 <p>
 The join is computed by (1) updating the internal state of one <code>KTable</code> and (2) performing a lookup for a
 matching record in the <em>current</em> (i.e., processing time) internal state of the other <code>KTable</code>.
 This happens in a symmetric way, i.e., for each update of either <code>this</code> or the <code>other</code> input
 <code>KTable</code> the result gets updated.
 <p>
 For each <code>KTable</code> record that finds a corresponding record in the other <code>KTable</code>'s state the
 provided <a href="ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueJoiner</code></a> will be called to compute a value (with arbitrary type) for the result record.
 Additionally, for each record of left <code>KTable</code> that does not find a corresponding record in the
 right <code>KTable</code>'s state the provided <a href="ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueJoiner</code></a> will be called with <code>rightValue =
 null</code> to compute a value (with arbitrary type) for the result record.
 The key of the result record is the same as for both joining input records.
 <p>
 Note that <a href="../KeyValue.html" title="class in org.apache.kafka.streams"><code>records</code></a> with <code>null</code> values (so-called tombstone records) have delete semantics.
 For example, for left input tombstones the provided value-joiner is not called but a tombstone record is
 forwarded directly to delete a record in the result <code>KTable</code> if required (i.e., if there is anything to be
 deleted).
 <p>
 Input records with <code>null</code> key will be dropped and no join computation is performed.
 <p>
 Example:
 <table border='1'>
 <tr>
 <th>thisKTable</th>
 <th>thisState</th>
 <th>otherKTable</th>
 <th>otherState</th>
 <th>result updated record</th>
 </tr>
 <tr>
 <td>&lt;K1:A&gt;</td>
 <td>&lt;K1:A&gt;</td>
 <td></td>
 <td></td>
 <td>&lt;K1:ValueJoiner(A,null)&gt;</td>
 </tr>
 <tr>
 <td></td>
 <td>&lt;K1:A&gt;</td>
 <td>&lt;K1:b&gt;</td>
 <td>&lt;K1:b&gt;</td>
 <td>&lt;K1:ValueJoiner(A,b)&gt;</td>
 </tr>
 <tr>
 <td>&lt;K1:null&gt;</td>
 <td></td>
 <td></td>
 <td>&lt;K1:b&gt;</td>
 <td>&lt;K1:null&gt;</td>
 </tr>
 <tr>
 <td></td>
 <td></td>
 <td>&lt;K1:null&gt;</td>
 <td></td>
 <td></td>
 </tr>
 </table>
 Both input streams (or to be more precise, their underlying source topics) need to have the same number of
 partitions.</div>
<dl class="notes">
<dt>Type Parameters:</dt>
<dd><code>VO</code> - the value type of the other <code>KTable</code></dd>
<dd><code>VR</code> - the value type of the result <code>KTable</code></dd>
<dt>Parameters:</dt>
<dd><code>other</code> - the other <code>KTable</code> to be joined with this <code>KTable</code></dd>
<dd><code>joiner</code> - a <a href="ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueJoiner</code></a> that computes the join result for a pair of matching records</dd>
<dt>Returns:</dt>
<dd>a <code>KTable</code> that contains join-records for each key and values computed by the given
 <a href="ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueJoiner</code></a>, one for each matched record-pair with the same key plus one for each non-matching record of
 left <code>KTable</code></dd>
<dt>See Also:</dt>
<dd><a href="#join(org.apache.kafka.streams.kstream.KTable,org.apache.kafka.streams.kstream.ValueJoiner)"><code>join(KTable, ValueJoiner)</code></a>, 
<a href="#outerJoin(org.apache.kafka.streams.kstream.KTable,org.apache.kafka.streams.kstream.ValueJoiner)"><code>outerJoin(KTable, ValueJoiner)</code></a></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="leftJoin(org.apache.kafka.streams.kstream.KTable,org.apache.kafka.streams.kstream.ValueJoiner,org.apache.kafka.streams.kstream.Named)">
<h3>leftJoin</h3>
<div class="member-signature"><span class="type-parameters">&lt;VO,&#8203;
VR&gt;</span>&nbsp;<span class="return-type"><a href="KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;VR&gt;</span>&nbsp;<span class="member-name">leftJoin</span>&#8203;(<span class="parameters"><a href="KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;VO&gt;&nbsp;other,
<a href="ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream">ValueJoiner</a>&lt;? super <a href="KTable.html" title="type parameter in KTable">V</a>,&#8203;? super VO,&#8203;? extends VR&gt;&nbsp;joiner,
<a href="Named.html" title="class in org.apache.kafka.streams.kstream">Named</a>&nbsp;named)</span></div>
<div class="block">Join records of this <code>KTable</code> (left input) with another <code>KTable</code>'s (right input) records using
 non-windowed left equi join, with default serializers, deserializers, and state store.
 The join is a primary key join with join attribute <code>thisKTable.key == otherKTable.key</code>.
 In contrast to <a href="#join(org.apache.kafka.streams.kstream.KTable,org.apache.kafka.streams.kstream.ValueJoiner)"><code>inner-join</code></a>, all records from left <code>KTable</code> will produce
 an output record (cf. below).
 The result is an ever updating <code>KTable</code> that represents the <em>current</em> (i.e., processing time) result
 of the join.
 <p>
 The join is computed by (1) updating the internal state of one <code>KTable</code> and (2) performing a lookup for a
 matching record in the <em>current</em> (i.e., processing time) internal state of the other <code>KTable</code>.
 This happens in a symmetric way, i.e., for each update of either <code>this</code> or the <code>other</code> input
 <code>KTable</code> the result gets updated.
 <p>
 For each <code>KTable</code> record that finds a corresponding record in the other <code>KTable</code>'s state the
 provided <a href="ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueJoiner</code></a> will be called to compute a value (with arbitrary type) for the result record.
 Additionally, for each record of left <code>KTable</code> that does not find a corresponding record in the
 right <code>KTable</code>'s state the provided <a href="ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueJoiner</code></a> will be called with <code>rightValue =
 null</code> to compute a value (with arbitrary type) for the result record.
 The key of the result record is the same as for both joining input records.
 <p>
 Note that <a href="../KeyValue.html" title="class in org.apache.kafka.streams"><code>records</code></a> with <code>null</code> values (so-called tombstone records) have delete semantics.
 For example, for left input tombstones the provided value-joiner is not called but a tombstone record is
 forwarded directly to delete a record in the result <code>KTable</code> if required (i.e., if there is anything to be
 deleted).
 <p>
 Input records with <code>null</code> key will be dropped and no join computation is performed.
 <p>
 Example:
 <table border='1'>
 <tr>
 <th>thisKTable</th>
 <th>thisState</th>
 <th>otherKTable</th>
 <th>otherState</th>
 <th>result updated record</th>
 </tr>
 <tr>
 <td>&lt;K1:A&gt;</td>
 <td>&lt;K1:A&gt;</td>
 <td></td>
 <td></td>
 <td>&lt;K1:ValueJoiner(A,null)&gt;</td>
 </tr>
 <tr>
 <td></td>
 <td>&lt;K1:A&gt;</td>
 <td>&lt;K1:b&gt;</td>
 <td>&lt;K1:b&gt;</td>
 <td>&lt;K1:ValueJoiner(A,b)&gt;</td>
 </tr>
 <tr>
 <td>&lt;K1:null&gt;</td>
 <td></td>
 <td></td>
 <td>&lt;K1:b&gt;</td>
 <td>&lt;K1:null&gt;</td>
 </tr>
 <tr>
 <td></td>
 <td></td>
 <td>&lt;K1:null&gt;</td>
 <td></td>
 <td></td>
 </tr>
 </table>
 Both input streams (or to be more precise, their underlying source topics) need to have the same number of
 partitions.</div>
<dl class="notes">
<dt>Type Parameters:</dt>
<dd><code>VO</code> - the value type of the other <code>KTable</code></dd>
<dd><code>VR</code> - the value type of the result <code>KTable</code></dd>
<dt>Parameters:</dt>
<dd><code>other</code> - the other <code>KTable</code> to be joined with this <code>KTable</code></dd>
<dd><code>joiner</code> - a <a href="ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueJoiner</code></a> that computes the join result for a pair of matching records</dd>
<dd><code>named</code> - a <a href="Named.html" title="class in org.apache.kafka.streams.kstream"><code>Named</code></a> config used to name the processor in the topology</dd>
<dt>Returns:</dt>
<dd>a <code>KTable</code> that contains join-records for each key and values computed by the given
 <a href="ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueJoiner</code></a>, one for each matched record-pair with the same key plus one for each non-matching record of
 left <code>KTable</code></dd>
<dt>See Also:</dt>
<dd><a href="#join(org.apache.kafka.streams.kstream.KTable,org.apache.kafka.streams.kstream.ValueJoiner)"><code>join(KTable, ValueJoiner)</code></a>, 
<a href="#outerJoin(org.apache.kafka.streams.kstream.KTable,org.apache.kafka.streams.kstream.ValueJoiner)"><code>outerJoin(KTable, ValueJoiner)</code></a></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="leftJoin(org.apache.kafka.streams.kstream.KTable,org.apache.kafka.streams.kstream.ValueJoiner,org.apache.kafka.streams.kstream.Materialized)">
<h3>leftJoin</h3>
<div class="member-signature"><span class="type-parameters">&lt;VO,&#8203;
VR&gt;</span>&nbsp;<span class="return-type"><a href="KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;VR&gt;</span>&nbsp;<span class="member-name">leftJoin</span>&#8203;(<span class="parameters"><a href="KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;VO&gt;&nbsp;other,
<a href="ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream">ValueJoiner</a>&lt;? super <a href="KTable.html" title="type parameter in KTable">V</a>,&#8203;? super VO,&#8203;? extends VR&gt;&nbsp;joiner,
<a href="Materialized.html" title="class in org.apache.kafka.streams.kstream">Materialized</a>&lt;<a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;VR,&#8203;<a href="../state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state">KeyValueStore</a>&lt;org.apache.kafka.common.utils.Bytes,&#8203;byte[]&gt;&gt;&nbsp;materialized)</span></div>
<div class="block">Join records of this <code>KTable</code> (left input) with another <code>KTable</code>'s (right input) records using
 non-windowed left equi join, with the <a href="Materialized.html" title="class in org.apache.kafka.streams.kstream"><code>Materialized</code></a> instance for configuration of the <a href="../../common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization"><code>key serde</code></a>,
 <a href="../../common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization"><code>the result table's value serde</code></a>, and <a href="../state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state"><code>state store</code></a>.
 The join is a primary key join with join attribute <code>thisKTable.key == otherKTable.key</code>.
 In contrast to <a href="#join(org.apache.kafka.streams.kstream.KTable,org.apache.kafka.streams.kstream.ValueJoiner)"><code>inner-join</code></a>, all records from left <code>KTable</code> will produce
 an output record (cf. below).
 The result is an ever updating <code>KTable</code> that represents the <em>current</em> (i.e., processing time) result
 of the join.
 <p>
 The join is computed by (1) updating the internal state of one <code>KTable</code> and (2) performing a lookup for a
 matching record in the <em>current</em> (i.e., processing time) internal state of the other <code>KTable</code>.
 This happens in a symmetric way, i.e., for each update of either <code>this</code> or the <code>other</code> input
 <code>KTable</code> the result gets updated.
 <p>
 For each <code>KTable</code> record that finds a corresponding record in the other <code>KTable</code>'s state the
 provided <a href="ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueJoiner</code></a> will be called to compute a value (with arbitrary type) for the result record.
 Additionally, for each record of left <code>KTable</code> that does not find a corresponding record in the
 right <code>KTable</code>'s state the provided <a href="ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueJoiner</code></a> will be called with <code>rightValue =
 null</code> to compute a value (with arbitrary type) for the result record.
 The key of the result record is the same as for both joining input records.
 <p>
 Note that <a href="../KeyValue.html" title="class in org.apache.kafka.streams"><code>records</code></a> with <code>null</code> values (so-called tombstone records) have delete semantics.
 For example, for left input tombstones the provided value-joiner is not called but a tombstone record is
 forwarded directly to delete a record in the result <code>KTable</code> if required (i.e., if there is anything to be
 deleted).
 <p>
 Input records with <code>null</code> key will be dropped and no join computation is performed.
 <p>
 Example:
 <table border='1'>
 <tr>
 <th>thisKTable</th>
 <th>thisState</th>
 <th>otherKTable</th>
 <th>otherState</th>
 <th>result updated record</th>
 </tr>
 <tr>
 <td>&lt;K1:A&gt;</td>
 <td>&lt;K1:A&gt;</td>
 <td></td>
 <td></td>
 <td>&lt;K1:ValueJoiner(A,null)&gt;</td>
 </tr>
 <tr>
 <td></td>
 <td>&lt;K1:A&gt;</td>
 <td>&lt;K1:b&gt;</td>
 <td>&lt;K1:b&gt;</td>
 <td>&lt;K1:ValueJoiner(A,b)&gt;</td>
 </tr>
 <tr>
 <td>&lt;K1:null&gt;</td>
 <td></td>
 <td></td>
 <td>&lt;K1:b&gt;</td>
 <td>&lt;K1:null&gt;</td>
 </tr>
 <tr>
 <td></td>
 <td></td>
 <td>&lt;K1:null&gt;</td>
 <td></td>
 <td></td>
 </tr>
 </table>
 Both input streams (or to be more precise, their underlying source topics) need to have the same number of
 partitions.</div>
<dl class="notes">
<dt>Type Parameters:</dt>
<dd><code>VO</code> - the value type of the other <code>KTable</code></dd>
<dd><code>VR</code> - the value type of the result <code>KTable</code></dd>
<dt>Parameters:</dt>
<dd><code>other</code> - the other <code>KTable</code> to be joined with this <code>KTable</code></dd>
<dd><code>joiner</code> - a <a href="ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueJoiner</code></a> that computes the join result for a pair of matching records</dd>
<dd><code>materialized</code> - an instance of <a href="Materialized.html" title="class in org.apache.kafka.streams.kstream"><code>Materialized</code></a> used to describe how the state store should be materialized.
                      Cannot be <code>null</code></dd>
<dt>Returns:</dt>
<dd>a <code>KTable</code> that contains join-records for each key and values computed by the given
 <a href="ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueJoiner</code></a>, one for each matched record-pair with the same key plus one for each non-matching record of
 left <code>KTable</code></dd>
<dt>See Also:</dt>
<dd><a href="#join(org.apache.kafka.streams.kstream.KTable,org.apache.kafka.streams.kstream.ValueJoiner,org.apache.kafka.streams.kstream.Materialized)"><code>join(KTable, ValueJoiner, Materialized)</code></a>, 
<a href="#outerJoin(org.apache.kafka.streams.kstream.KTable,org.apache.kafka.streams.kstream.ValueJoiner,org.apache.kafka.streams.kstream.Materialized)"><code>outerJoin(KTable, ValueJoiner, Materialized)</code></a></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="leftJoin(org.apache.kafka.streams.kstream.KTable,org.apache.kafka.streams.kstream.ValueJoiner,org.apache.kafka.streams.kstream.Named,org.apache.kafka.streams.kstream.Materialized)">
<h3>leftJoin</h3>
<div class="member-signature"><span class="type-parameters">&lt;VO,&#8203;
VR&gt;</span>&nbsp;<span class="return-type"><a href="KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;VR&gt;</span>&nbsp;<span class="member-name">leftJoin</span>&#8203;(<span class="parameters"><a href="KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;VO&gt;&nbsp;other,
<a href="ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream">ValueJoiner</a>&lt;? super <a href="KTable.html" title="type parameter in KTable">V</a>,&#8203;? super VO,&#8203;? extends VR&gt;&nbsp;joiner,
<a href="Named.html" title="class in org.apache.kafka.streams.kstream">Named</a>&nbsp;named,
<a href="Materialized.html" title="class in org.apache.kafka.streams.kstream">Materialized</a>&lt;<a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;VR,&#8203;<a href="../state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state">KeyValueStore</a>&lt;org.apache.kafka.common.utils.Bytes,&#8203;byte[]&gt;&gt;&nbsp;materialized)</span></div>
<div class="block">Join records of this <code>KTable</code> (left input) with another <code>KTable</code>'s (right input) records using
 non-windowed left equi join, with the <a href="Materialized.html" title="class in org.apache.kafka.streams.kstream"><code>Materialized</code></a> instance for configuration of the <a href="../../common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization"><code>key serde</code></a>,
 <a href="../../common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization"><code>the result table's value serde</code></a>, and <a href="../state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state"><code>state store</code></a>.
 The join is a primary key join with join attribute <code>thisKTable.key == otherKTable.key</code>.
 In contrast to <a href="#join(org.apache.kafka.streams.kstream.KTable,org.apache.kafka.streams.kstream.ValueJoiner)"><code>inner-join</code></a>, all records from left <code>KTable</code> will produce
 an output record (cf. below).
 The result is an ever updating <code>KTable</code> that represents the <em>current</em> (i.e., processing time) result
 of the join.
 <p>
 The join is computed by (1) updating the internal state of one <code>KTable</code> and (2) performing a lookup for a
 matching record in the <em>current</em> (i.e., processing time) internal state of the other <code>KTable</code>.
 This happens in a symmetric way, i.e., for each update of either <code>this</code> or the <code>other</code> input
 <code>KTable</code> the result gets updated.
 <p>
 For each <code>KTable</code> record that finds a corresponding record in the other <code>KTable</code>'s state the
 provided <a href="ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueJoiner</code></a> will be called to compute a value (with arbitrary type) for the result record.
 Additionally, for each record of left <code>KTable</code> that does not find a corresponding record in the
 right <code>KTable</code>'s state the provided <a href="ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueJoiner</code></a> will be called with <code>rightValue =
 null</code> to compute a value (with arbitrary type) for the result record.
 The key of the result record is the same as for both joining input records.
 <p>
 Note that <a href="../KeyValue.html" title="class in org.apache.kafka.streams"><code>records</code></a> with <code>null</code> values (so-called tombstone records) have delete semantics.
 For example, for left input tombstones the provided value-joiner is not called but a tombstone record is
 forwarded directly to delete a record in the result <code>KTable</code> if required (i.e., if there is anything to be
 deleted).
 <p>
 Input records with <code>null</code> key will be dropped and no join computation is performed.
 <p>
 Example:
 <table border='1'>
 <tr>
 <th>thisKTable</th>
 <th>thisState</th>
 <th>otherKTable</th>
 <th>otherState</th>
 <th>result updated record</th>
 </tr>
 <tr>
 <td>&lt;K1:A&gt;</td>
 <td>&lt;K1:A&gt;</td>
 <td></td>
 <td></td>
 <td>&lt;K1:ValueJoiner(A,null)&gt;</td>
 </tr>
 <tr>
 <td></td>
 <td>&lt;K1:A&gt;</td>
 <td>&lt;K1:b&gt;</td>
 <td>&lt;K1:b&gt;</td>
 <td>&lt;K1:ValueJoiner(A,b)&gt;</td>
 </tr>
 <tr>
 <td>&lt;K1:null&gt;</td>
 <td></td>
 <td></td>
 <td>&lt;K1:b&gt;</td>
 <td>&lt;K1:null&gt;</td>
 </tr>
 <tr>
 <td></td>
 <td></td>
 <td>&lt;K1:null&gt;</td>
 <td></td>
 <td></td>
 </tr>
 </table>
 Both input streams (or to be more precise, their underlying source topics) need to have the same number of
 partitions.</div>
<dl class="notes">
<dt>Type Parameters:</dt>
<dd><code>VO</code> - the value type of the other <code>KTable</code></dd>
<dd><code>VR</code> - the value type of the result <code>KTable</code></dd>
<dt>Parameters:</dt>
<dd><code>other</code> - the other <code>KTable</code> to be joined with this <code>KTable</code></dd>
<dd><code>joiner</code> - a <a href="ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueJoiner</code></a> that computes the join result for a pair of matching records</dd>
<dd><code>named</code> - a <a href="Named.html" title="class in org.apache.kafka.streams.kstream"><code>Named</code></a> config used to name the processor in the topology</dd>
<dd><code>materialized</code> - an instance of <a href="Materialized.html" title="class in org.apache.kafka.streams.kstream"><code>Materialized</code></a> used to describe how the state store should be materialized.
                      Cannot be <code>null</code></dd>
<dt>Returns:</dt>
<dd>a <code>KTable</code> that contains join-records for each key and values computed by the given
 <a href="ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueJoiner</code></a>, one for each matched record-pair with the same key plus one for each non-matching record of
 left <code>KTable</code></dd>
<dt>See Also:</dt>
<dd><a href="#join(org.apache.kafka.streams.kstream.KTable,org.apache.kafka.streams.kstream.ValueJoiner,org.apache.kafka.streams.kstream.Materialized)"><code>join(KTable, ValueJoiner, Materialized)</code></a>, 
<a href="#outerJoin(org.apache.kafka.streams.kstream.KTable,org.apache.kafka.streams.kstream.ValueJoiner,org.apache.kafka.streams.kstream.Materialized)"><code>outerJoin(KTable, ValueJoiner, Materialized)</code></a></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="outerJoin(org.apache.kafka.streams.kstream.KTable,org.apache.kafka.streams.kstream.ValueJoiner)">
<h3>outerJoin</h3>
<div class="member-signature"><span class="type-parameters">&lt;VO,&#8203;
VR&gt;</span>&nbsp;<span class="return-type"><a href="KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;VR&gt;</span>&nbsp;<span class="member-name">outerJoin</span>&#8203;(<span class="parameters"><a href="KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;VO&gt;&nbsp;other,
<a href="ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream">ValueJoiner</a>&lt;? super <a href="KTable.html" title="type parameter in KTable">V</a>,&#8203;? super VO,&#8203;? extends VR&gt;&nbsp;joiner)</span></div>
<div class="block">Join records of this <code>KTable</code> (left input) with another <code>KTable</code>'s (right input) records using
 non-windowed outer equi join, with default serializers, deserializers, and state store.
 The join is a primary key join with join attribute <code>thisKTable.key == otherKTable.key</code>.
 In contrast to <a href="#join(org.apache.kafka.streams.kstream.KTable,org.apache.kafka.streams.kstream.ValueJoiner)"><code>inner-join</code></a> or <a href="#leftJoin(org.apache.kafka.streams.kstream.KTable,org.apache.kafka.streams.kstream.ValueJoiner)"><code>left-join</code></a>,
 all records from both input <code>KTable</code>s will produce an output record (cf. below).
 The result is an ever updating <code>KTable</code> that represents the <em>current</em> (i.e., processing time) result
 of the join.
 <p>
 The join is computed by (1) updating the internal state of one <code>KTable</code> and (2) performing a lookup for a
 matching record in the <em>current</em> (i.e., processing time) internal state of the other <code>KTable</code>.
 This happens in a symmetric way, i.e., for each update of either <code>this</code> or the <code>other</code> input
 <code>KTable</code> the result gets updated.
 <p>
 For each <code>KTable</code> record that finds a corresponding record in the other <code>KTable</code>'s state the
 provided <a href="ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueJoiner</code></a> will be called to compute a value (with arbitrary type) for the result record.
 Additionally, for each record that does not find a corresponding record in the corresponding other
 <code>KTable</code>'s state the provided <a href="ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueJoiner</code></a> will be called with <code>null</code> value for the
 corresponding other value to compute a value (with arbitrary type) for the result record.
 The key of the result record is the same as for both joining input records.
 <p>
 Note that <a href="../KeyValue.html" title="class in org.apache.kafka.streams"><code>records</code></a> with <code>null</code> values (so-called tombstone records) have delete semantics.
 Thus, for input tombstones the provided value-joiner is not called but a tombstone record is forwarded directly
 to delete a record in the result <code>KTable</code> if required (i.e., if there is anything to be deleted).
 <p>
 Input records with <code>null</code> key will be dropped and no join computation is performed.
 <p>
 Example:
 <table border='1'>
 <tr>
 <th>thisKTable</th>
 <th>thisState</th>
 <th>otherKTable</th>
 <th>otherState</th>
 <th>result updated record</th>
 </tr>
 <tr>
 <td>&lt;K1:A&gt;</td>
 <td>&lt;K1:A&gt;</td>
 <td></td>
 <td></td>
 <td>&lt;K1:ValueJoiner(A,null)&gt;</td>
 </tr>
 <tr>
 <td></td>
 <td>&lt;K1:A&gt;</td>
 <td>&lt;K1:b&gt;</td>
 <td>&lt;K1:b&gt;</td>
 <td>&lt;K1:ValueJoiner(A,b)&gt;</td>
 </tr>
 <tr>
 <td>&lt;K1:null&gt;</td>
 <td></td>
 <td></td>
 <td>&lt;K1:b&gt;</td>
 <td>&lt;K1:ValueJoiner(null,b)&gt;</td>
 </tr>
 <tr>
 <td></td>
 <td></td>
 <td>&lt;K1:null&gt;</td>
 <td></td>
 <td>&lt;K1:null&gt;</td>
 </tr>
 </table>
 Both input streams (or to be more precise, their underlying source topics) need to have the same number of
 partitions.</div>
<dl class="notes">
<dt>Type Parameters:</dt>
<dd><code>VO</code> - the value type of the other <code>KTable</code></dd>
<dd><code>VR</code> - the value type of the result <code>KTable</code></dd>
<dt>Parameters:</dt>
<dd><code>other</code> - the other <code>KTable</code> to be joined with this <code>KTable</code></dd>
<dd><code>joiner</code> - a <a href="ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueJoiner</code></a> that computes the join result for a pair of matching records</dd>
<dt>Returns:</dt>
<dd>a <code>KTable</code> that contains join-records for each key and values computed by the given
 <a href="ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueJoiner</code></a>, one for each matched record-pair with the same key plus one for each non-matching record of
 both <code>KTable</code>s</dd>
<dt>See Also:</dt>
<dd><a href="#join(org.apache.kafka.streams.kstream.KTable,org.apache.kafka.streams.kstream.ValueJoiner)"><code>join(KTable, ValueJoiner)</code></a>, 
<a href="#leftJoin(org.apache.kafka.streams.kstream.KTable,org.apache.kafka.streams.kstream.ValueJoiner)"><code>leftJoin(KTable, ValueJoiner)</code></a></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="outerJoin(org.apache.kafka.streams.kstream.KTable,org.apache.kafka.streams.kstream.ValueJoiner,org.apache.kafka.streams.kstream.Named)">
<h3>outerJoin</h3>
<div class="member-signature"><span class="type-parameters">&lt;VO,&#8203;
VR&gt;</span>&nbsp;<span class="return-type"><a href="KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;VR&gt;</span>&nbsp;<span class="member-name">outerJoin</span>&#8203;(<span class="parameters"><a href="KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;VO&gt;&nbsp;other,
<a href="ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream">ValueJoiner</a>&lt;? super <a href="KTable.html" title="type parameter in KTable">V</a>,&#8203;? super VO,&#8203;? extends VR&gt;&nbsp;joiner,
<a href="Named.html" title="class in org.apache.kafka.streams.kstream">Named</a>&nbsp;named)</span></div>
<div class="block">Join records of this <code>KTable</code> (left input) with another <code>KTable</code>'s (right input) records using
 non-windowed outer equi join, with default serializers, deserializers, and state store.
 The join is a primary key join with join attribute <code>thisKTable.key == otherKTable.key</code>.
 In contrast to <a href="#join(org.apache.kafka.streams.kstream.KTable,org.apache.kafka.streams.kstream.ValueJoiner)"><code>inner-join</code></a> or <a href="#leftJoin(org.apache.kafka.streams.kstream.KTable,org.apache.kafka.streams.kstream.ValueJoiner)"><code>left-join</code></a>,
 all records from both input <code>KTable</code>s will produce an output record (cf. below).
 The result is an ever updating <code>KTable</code> that represents the <em>current</em> (i.e., processing time) result
 of the join.
 <p>
 The join is computed by (1) updating the internal state of one <code>KTable</code> and (2) performing a lookup for a
 matching record in the <em>current</em> (i.e., processing time) internal state of the other <code>KTable</code>.
 This happens in a symmetric way, i.e., for each update of either <code>this</code> or the <code>other</code> input
 <code>KTable</code> the result gets updated.
 <p>
 For each <code>KTable</code> record that finds a corresponding record in the other <code>KTable</code>'s state the
 provided <a href="ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueJoiner</code></a> will be called to compute a value (with arbitrary type) for the result record.
 Additionally, for each record that does not find a corresponding record in the corresponding other
 <code>KTable</code>'s state the provided <a href="ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueJoiner</code></a> will be called with <code>null</code> value for the
 corresponding other value to compute a value (with arbitrary type) for the result record.
 The key of the result record is the same as for both joining input records.
 <p>
 Note that <a href="../KeyValue.html" title="class in org.apache.kafka.streams"><code>records</code></a> with <code>null</code> values (so-called tombstone records) have delete semantics.
 Thus, for input tombstones the provided value-joiner is not called but a tombstone record is forwarded directly
 to delete a record in the result <code>KTable</code> if required (i.e., if there is anything to be deleted).
 <p>
 Input records with <code>null</code> key will be dropped and no join computation is performed.
 <p>
 Example:
 <table border='1'>
 <tr>
 <th>thisKTable</th>
 <th>thisState</th>
 <th>otherKTable</th>
 <th>otherState</th>
 <th>result updated record</th>
 </tr>
 <tr>
 <td>&lt;K1:A&gt;</td>
 <td>&lt;K1:A&gt;</td>
 <td></td>
 <td></td>
 <td>&lt;K1:ValueJoiner(A,null)&gt;</td>
 </tr>
 <tr>
 <td></td>
 <td>&lt;K1:A&gt;</td>
 <td>&lt;K1:b&gt;</td>
 <td>&lt;K1:b&gt;</td>
 <td>&lt;K1:ValueJoiner(A,b)&gt;</td>
 </tr>
 <tr>
 <td>&lt;K1:null&gt;</td>
 <td></td>
 <td></td>
 <td>&lt;K1:b&gt;</td>
 <td>&lt;K1:ValueJoiner(null,b)&gt;</td>
 </tr>
 <tr>
 <td></td>
 <td></td>
 <td>&lt;K1:null&gt;</td>
 <td></td>
 <td>&lt;K1:null&gt;</td>
 </tr>
 </table>
 Both input streams (or to be more precise, their underlying source topics) need to have the same number of
 partitions.</div>
<dl class="notes">
<dt>Type Parameters:</dt>
<dd><code>VO</code> - the value type of the other <code>KTable</code></dd>
<dd><code>VR</code> - the value type of the result <code>KTable</code></dd>
<dt>Parameters:</dt>
<dd><code>other</code> - the other <code>KTable</code> to be joined with this <code>KTable</code></dd>
<dd><code>joiner</code> - a <a href="ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueJoiner</code></a> that computes the join result for a pair of matching records</dd>
<dd><code>named</code> - a <a href="Named.html" title="class in org.apache.kafka.streams.kstream"><code>Named</code></a> config used to name the processor in the topology</dd>
<dt>Returns:</dt>
<dd>a <code>KTable</code> that contains join-records for each key and values computed by the given
 <a href="ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueJoiner</code></a>, one for each matched record-pair with the same key plus one for each non-matching record of
 both <code>KTable</code>s</dd>
<dt>See Also:</dt>
<dd><a href="#join(org.apache.kafka.streams.kstream.KTable,org.apache.kafka.streams.kstream.ValueJoiner)"><code>join(KTable, ValueJoiner)</code></a>, 
<a href="#leftJoin(org.apache.kafka.streams.kstream.KTable,org.apache.kafka.streams.kstream.ValueJoiner)"><code>leftJoin(KTable, ValueJoiner)</code></a></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="outerJoin(org.apache.kafka.streams.kstream.KTable,org.apache.kafka.streams.kstream.ValueJoiner,org.apache.kafka.streams.kstream.Materialized)">
<h3>outerJoin</h3>
<div class="member-signature"><span class="type-parameters">&lt;VO,&#8203;
VR&gt;</span>&nbsp;<span class="return-type"><a href="KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;VR&gt;</span>&nbsp;<span class="member-name">outerJoin</span>&#8203;(<span class="parameters"><a href="KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;VO&gt;&nbsp;other,
<a href="ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream">ValueJoiner</a>&lt;? super <a href="KTable.html" title="type parameter in KTable">V</a>,&#8203;? super VO,&#8203;? extends VR&gt;&nbsp;joiner,
<a href="Materialized.html" title="class in org.apache.kafka.streams.kstream">Materialized</a>&lt;<a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;VR,&#8203;<a href="../state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state">KeyValueStore</a>&lt;org.apache.kafka.common.utils.Bytes,&#8203;byte[]&gt;&gt;&nbsp;materialized)</span></div>
<div class="block">Join records of this <code>KTable</code> (left input) with another <code>KTable</code>'s (right input) records using
 non-windowed outer equi join, with the <a href="Materialized.html" title="class in org.apache.kafka.streams.kstream"><code>Materialized</code></a> instance for configuration of the <a href="../../common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization"><code>key serde</code></a>,
 <a href="../../common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization"><code>the result table's value serde</code></a>, and <a href="../state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state"><code>state store</code></a>.
 The join is a primary key join with join attribute <code>thisKTable.key == otherKTable.key</code>.
 In contrast to <a href="#join(org.apache.kafka.streams.kstream.KTable,org.apache.kafka.streams.kstream.ValueJoiner)"><code>inner-join</code></a> or <a href="#leftJoin(org.apache.kafka.streams.kstream.KTable,org.apache.kafka.streams.kstream.ValueJoiner)"><code>left-join</code></a>,
 all records from both input <code>KTable</code>s will produce an output record (cf. below).
 The result is an ever updating <code>KTable</code> that represents the <em>current</em> (i.e., processing time) result
 of the join.
 <p>
 The join is computed by (1) updating the internal state of one <code>KTable</code> and (2) performing a lookup for a
 matching record in the <em>current</em> (i.e., processing time) internal state of the other <code>KTable</code>.
 This happens in a symmetric way, i.e., for each update of either <code>this</code> or the <code>other</code> input
 <code>KTable</code> the result gets updated.
 <p>
 For each <code>KTable</code> record that finds a corresponding record in the other <code>KTable</code>'s state the
 provided <a href="ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueJoiner</code></a> will be called to compute a value (with arbitrary type) for the result record.
 Additionally, for each record that does not find a corresponding record in the corresponding other
 <code>KTable</code>'s state the provided <a href="ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueJoiner</code></a> will be called with <code>null</code> value for the
 corresponding other value to compute a value (with arbitrary type) for the result record.
 The key of the result record is the same as for both joining input records.
 <p>
 Note that <a href="../KeyValue.html" title="class in org.apache.kafka.streams"><code>records</code></a> with <code>null</code> values (so-called tombstone records) have delete semantics.
 Thus, for input tombstones the provided value-joiner is not called but a tombstone record is forwarded directly
 to delete a record in the result <code>KTable</code> if required (i.e., if there is anything to be deleted).
 <p>
 Input records with <code>null</code> key will be dropped and no join computation is performed.
 <p>
 Example:
 <table border='1'>
 <tr>
 <th>thisKTable</th>
 <th>thisState</th>
 <th>otherKTable</th>
 <th>otherState</th>
 <th>result updated record</th>
 </tr>
 <tr>
 <td>&lt;K1:A&gt;</td>
 <td>&lt;K1:A&gt;</td>
 <td></td>
 <td></td>
 <td>&lt;K1:ValueJoiner(A,null)&gt;</td>
 </tr>
 <tr>
 <td></td>
 <td>&lt;K1:A&gt;</td>
 <td>&lt;K1:b&gt;</td>
 <td>&lt;K1:b&gt;</td>
 <td>&lt;K1:ValueJoiner(A,b)&gt;</td>
 </tr>
 <tr>
 <td>&lt;K1:null&gt;</td>
 <td></td>
 <td></td>
 <td>&lt;K1:b&gt;</td>
 <td>&lt;K1:ValueJoiner(null,b)&gt;</td>
 </tr>
 <tr>
 <td></td>
 <td></td>
 <td>&lt;K1:null&gt;</td>
 <td></td>
 <td>&lt;K1:null&gt;</td>
 </tr>
 </table>
 Both input streams (or to be more precise, their underlying source topics) need to have the same number of
 partitions.</div>
<dl class="notes">
<dt>Type Parameters:</dt>
<dd><code>VO</code> - the value type of the other <code>KTable</code></dd>
<dd><code>VR</code> - the value type of the result <code>KTable</code></dd>
<dt>Parameters:</dt>
<dd><code>other</code> - the other <code>KTable</code> to be joined with this <code>KTable</code></dd>
<dd><code>joiner</code> - a <a href="ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueJoiner</code></a> that computes the join result for a pair of matching records</dd>
<dd><code>materialized</code> - an instance of <a href="Materialized.html" title="class in org.apache.kafka.streams.kstream"><code>Materialized</code></a> used to describe how the state store should be materialized.
                      Cannot be <code>null</code></dd>
<dt>Returns:</dt>
<dd>a <code>KTable</code> that contains join-records for each key and values computed by the given
 <a href="ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueJoiner</code></a>, one for each matched record-pair with the same key plus one for each non-matching record of
 both <code>KTable</code>s</dd>
<dt>See Also:</dt>
<dd><a href="#join(org.apache.kafka.streams.kstream.KTable,org.apache.kafka.streams.kstream.ValueJoiner)"><code>join(KTable, ValueJoiner)</code></a>, 
<a href="#leftJoin(org.apache.kafka.streams.kstream.KTable,org.apache.kafka.streams.kstream.ValueJoiner)"><code>leftJoin(KTable, ValueJoiner)</code></a></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="outerJoin(org.apache.kafka.streams.kstream.KTable,org.apache.kafka.streams.kstream.ValueJoiner,org.apache.kafka.streams.kstream.Named,org.apache.kafka.streams.kstream.Materialized)">
<h3>outerJoin</h3>
<div class="member-signature"><span class="type-parameters">&lt;VO,&#8203;
VR&gt;</span>&nbsp;<span class="return-type"><a href="KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;VR&gt;</span>&nbsp;<span class="member-name">outerJoin</span>&#8203;(<span class="parameters"><a href="KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;VO&gt;&nbsp;other,
<a href="ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream">ValueJoiner</a>&lt;? super <a href="KTable.html" title="type parameter in KTable">V</a>,&#8203;? super VO,&#8203;? extends VR&gt;&nbsp;joiner,
<a href="Named.html" title="class in org.apache.kafka.streams.kstream">Named</a>&nbsp;named,
<a href="Materialized.html" title="class in org.apache.kafka.streams.kstream">Materialized</a>&lt;<a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;VR,&#8203;<a href="../state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state">KeyValueStore</a>&lt;org.apache.kafka.common.utils.Bytes,&#8203;byte[]&gt;&gt;&nbsp;materialized)</span></div>
<div class="block">Join records of this <code>KTable</code> (left input) with another <code>KTable</code>'s (right input) records using
 non-windowed outer equi join, with the <a href="Materialized.html" title="class in org.apache.kafka.streams.kstream"><code>Materialized</code></a> instance for configuration of the <a href="../../common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization"><code>key serde</code></a>,
 <a href="../../common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization"><code>the result table's value serde</code></a>, and <a href="../state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state"><code>state store</code></a>.
 The join is a primary key join with join attribute <code>thisKTable.key == otherKTable.key</code>.
 In contrast to <a href="#join(org.apache.kafka.streams.kstream.KTable,org.apache.kafka.streams.kstream.ValueJoiner)"><code>inner-join</code></a> or <a href="#leftJoin(org.apache.kafka.streams.kstream.KTable,org.apache.kafka.streams.kstream.ValueJoiner)"><code>left-join</code></a>,
 all records from both input <code>KTable</code>s will produce an output record (cf. below).
 The result is an ever updating <code>KTable</code> that represents the <em>current</em> (i.e., processing time) result
 of the join.
 <p>
 The join is computed by (1) updating the internal state of one <code>KTable</code> and (2) performing a lookup for a
 matching record in the <em>current</em> (i.e., processing time) internal state of the other <code>KTable</code>.
 This happens in a symmetric way, i.e., for each update of either <code>this</code> or the <code>other</code> input
 <code>KTable</code> the result gets updated.
 <p>
 For each <code>KTable</code> record that finds a corresponding record in the other <code>KTable</code>'s state the
 provided <a href="ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueJoiner</code></a> will be called to compute a value (with arbitrary type) for the result record.
 Additionally, for each record that does not find a corresponding record in the corresponding other
 <code>KTable</code>'s state the provided <a href="ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueJoiner</code></a> will be called with <code>null</code> value for the
 corresponding other value to compute a value (with arbitrary type) for the result record.
 The key of the result record is the same as for both joining input records.
 <p>
 Note that <a href="../KeyValue.html" title="class in org.apache.kafka.streams"><code>records</code></a> with <code>null</code> values (so-called tombstone records) have delete semantics.
 Thus, for input tombstones the provided value-joiner is not called but a tombstone record is forwarded directly
 to delete a record in the result <code>KTable</code> if required (i.e., if there is anything to be deleted).
 <p>
 Input records with <code>null</code> key will be dropped and no join computation is performed.
 <p>
 Example:
 <table border='1'>
 <tr>
 <th>thisKTable</th>
 <th>thisState</th>
 <th>otherKTable</th>
 <th>otherState</th>
 <th>result updated record</th>
 </tr>
 <tr>
 <td>&lt;K1:A&gt;</td>
 <td>&lt;K1:A&gt;</td>
 <td></td>
 <td></td>
 <td>&lt;K1:ValueJoiner(A,null)&gt;</td>
 </tr>
 <tr>
 <td></td>
 <td>&lt;K1:A&gt;</td>
 <td>&lt;K1:b&gt;</td>
 <td>&lt;K1:b&gt;</td>
 <td>&lt;K1:ValueJoiner(A,b)&gt;</td>
 </tr>
 <tr>
 <td>&lt;K1:null&gt;</td>
 <td></td>
 <td></td>
 <td>&lt;K1:b&gt;</td>
 <td>&lt;K1:ValueJoiner(null,b)&gt;</td>
 </tr>
 <tr>
 <td></td>
 <td></td>
 <td>&lt;K1:null&gt;</td>
 <td></td>
 <td>&lt;K1:null&gt;</td>
 </tr>
 </table>
 Both input streams (or to be more precise, their underlying source topics) need to have the same number of
 partitions.</div>
<dl class="notes">
<dt>Type Parameters:</dt>
<dd><code>VO</code> - the value type of the other <code>KTable</code></dd>
<dd><code>VR</code> - the value type of the result <code>KTable</code></dd>
<dt>Parameters:</dt>
<dd><code>other</code> - the other <code>KTable</code> to be joined with this <code>KTable</code></dd>
<dd><code>joiner</code> - a <a href="ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueJoiner</code></a> that computes the join result for a pair of matching records</dd>
<dd><code>named</code> - a <a href="Named.html" title="class in org.apache.kafka.streams.kstream"><code>Named</code></a> config used to name the processor in the topology</dd>
<dd><code>materialized</code> - an instance of <a href="Materialized.html" title="class in org.apache.kafka.streams.kstream"><code>Materialized</code></a> used to describe how the state store should be materialized.
                      Cannot be <code>null</code></dd>
<dt>Returns:</dt>
<dd>a <code>KTable</code> that contains join-records for each key and values computed by the given
 <a href="ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueJoiner</code></a>, one for each matched record-pair with the same key plus one for each non-matching record of
 both <code>KTable</code>s</dd>
<dt>See Also:</dt>
<dd><a href="#join(org.apache.kafka.streams.kstream.KTable,org.apache.kafka.streams.kstream.ValueJoiner)"><code>join(KTable, ValueJoiner)</code></a>, 
<a href="#leftJoin(org.apache.kafka.streams.kstream.KTable,org.apache.kafka.streams.kstream.ValueJoiner)"><code>leftJoin(KTable, ValueJoiner)</code></a></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="join(org.apache.kafka.streams.kstream.KTable,java.util.function.Function,org.apache.kafka.streams.kstream.ValueJoiner)">
<h3>join</h3>
<div class="member-signature"><span class="type-parameters">&lt;VR,&#8203;
KO,&#8203;
VO&gt;</span>&nbsp;<span class="return-type"><a href="KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;VR&gt;</span>&nbsp;<span class="member-name">join</span>&#8203;(<span class="parameters"><a href="KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;KO,&#8203;VO&gt;&nbsp;other,
<a href="https://docs.oracle.com/en/java/javase/15/docs/api/java.base/java/util/function/Function.html" title="class or interface in java.util.function" class="external-link">Function</a>&lt;<a href="KTable.html" title="type parameter in KTable">V</a>,&#8203;KO&gt;&nbsp;foreignKeyExtractor,
<a href="ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream">ValueJoiner</a>&lt;<a href="KTable.html" title="type parameter in KTable">V</a>,&#8203;VO,&#8203;VR&gt;&nbsp;joiner)</span></div>
<div class="block">Join records of this <code>KTable</code> with another <code>KTable</code> using non-windowed inner join.
 <p>
 This is a foreign key join, where the joining key is determined by the <code>foreignKeyExtractor</code>.</div>
<dl class="notes">
<dt>Type Parameters:</dt>
<dd><code>VR</code> - the value type of the result <code>KTable</code></dd>
<dd><code>KO</code> - the key type of the other <code>KTable</code></dd>
<dd><code>VO</code> - the value type of the other <code>KTable</code></dd>
<dt>Parameters:</dt>
<dd><code>other</code> - the other <code>KTable</code> to be joined with this <code>KTable</code>. Keyed by KO.</dd>
<dd><code>foreignKeyExtractor</code> - a <a href="https://docs.oracle.com/en/java/javase/15/docs/api/java.base/java/util/function/Function.html" title="class or interface in java.util.function" class="external-link"><code>Function</code></a> that extracts the key (KO) from this table's value (V). If the
                            result is null, the update is ignored as invalid.</dd>
<dd><code>joiner</code> - a <a href="ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueJoiner</code></a> that computes the join result for a pair of matching records</dd>
<dt>Returns:</dt>
<dd>a <code>KTable</code> that contains the result of joining this table with <code>other</code></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="join(org.apache.kafka.streams.kstream.KTable,java.util.function.Function,org.apache.kafka.streams.kstream.ValueJoiner,org.apache.kafka.streams.kstream.Named)">
<h3>join</h3>
<div class="member-signature"><span class="type-parameters">&lt;VR,&#8203;
KO,&#8203;
VO&gt;</span>&nbsp;<span class="return-type"><a href="KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;VR&gt;</span>&nbsp;<span class="member-name">join</span>&#8203;(<span class="parameters"><a href="KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;KO,&#8203;VO&gt;&nbsp;other,
<a href="https://docs.oracle.com/en/java/javase/15/docs/api/java.base/java/util/function/Function.html" title="class or interface in java.util.function" class="external-link">Function</a>&lt;<a href="KTable.html" title="type parameter in KTable">V</a>,&#8203;KO&gt;&nbsp;foreignKeyExtractor,
<a href="ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream">ValueJoiner</a>&lt;<a href="KTable.html" title="type parameter in KTable">V</a>,&#8203;VO,&#8203;VR&gt;&nbsp;joiner,
<a href="Named.html" title="class in org.apache.kafka.streams.kstream">Named</a>&nbsp;named)</span></div>
<div class="block">Join records of this <code>KTable</code> with another <code>KTable</code> using non-windowed inner join.
 <p>
 This is a foreign key join, where the joining key is determined by the <code>foreignKeyExtractor</code>.</div>
<dl class="notes">
<dt>Type Parameters:</dt>
<dd><code>VR</code> - the value type of the result <code>KTable</code></dd>
<dd><code>KO</code> - the key type of the other <code>KTable</code></dd>
<dd><code>VO</code> - the value type of the other <code>KTable</code></dd>
<dt>Parameters:</dt>
<dd><code>other</code> - the other <code>KTable</code> to be joined with this <code>KTable</code>. Keyed by KO.</dd>
<dd><code>foreignKeyExtractor</code> - a <a href="https://docs.oracle.com/en/java/javase/15/docs/api/java.base/java/util/function/Function.html" title="class or interface in java.util.function" class="external-link"><code>Function</code></a> that extracts the key (KO) from this table's value (V). If the
                            result is null, the update is ignored as invalid.</dd>
<dd><code>joiner</code> - a <a href="ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueJoiner</code></a> that computes the join result for a pair of matching records</dd>
<dd><code>named</code> - a <a href="Named.html" title="class in org.apache.kafka.streams.kstream"><code>Named</code></a> config used to name the processor in the topology</dd>
<dt>Returns:</dt>
<dd>a <code>KTable</code> that contains the result of joining this table with <code>other</code></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="join(org.apache.kafka.streams.kstream.KTable,java.util.function.Function,org.apache.kafka.streams.kstream.ValueJoiner,org.apache.kafka.streams.kstream.Materialized)">
<h3>join</h3>
<div class="member-signature"><span class="type-parameters">&lt;VR,&#8203;
KO,&#8203;
VO&gt;</span>&nbsp;<span class="return-type"><a href="KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;VR&gt;</span>&nbsp;<span class="member-name">join</span>&#8203;(<span class="parameters"><a href="KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;KO,&#8203;VO&gt;&nbsp;other,
<a href="https://docs.oracle.com/en/java/javase/15/docs/api/java.base/java/util/function/Function.html" title="class or interface in java.util.function" class="external-link">Function</a>&lt;<a href="KTable.html" title="type parameter in KTable">V</a>,&#8203;KO&gt;&nbsp;foreignKeyExtractor,
<a href="ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream">ValueJoiner</a>&lt;<a href="KTable.html" title="type parameter in KTable">V</a>,&#8203;VO,&#8203;VR&gt;&nbsp;joiner,
<a href="Materialized.html" title="class in org.apache.kafka.streams.kstream">Materialized</a>&lt;<a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;VR,&#8203;<a href="../state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state">KeyValueStore</a>&lt;org.apache.kafka.common.utils.Bytes,&#8203;byte[]&gt;&gt;&nbsp;materialized)</span></div>
<div class="block">Join records of this <code>KTable</code> with another <code>KTable</code> using non-windowed inner join.
 <p>
 This is a foreign key join, where the joining key is determined by the <code>foreignKeyExtractor</code>.</div>
<dl class="notes">
<dt>Type Parameters:</dt>
<dd><code>VR</code> - the value type of the result <code>KTable</code></dd>
<dd><code>KO</code> - the key type of the other <code>KTable</code></dd>
<dd><code>VO</code> - the value type of the other <code>KTable</code></dd>
<dt>Parameters:</dt>
<dd><code>other</code> - the other <code>KTable</code> to be joined with this <code>KTable</code>. Keyed by KO.</dd>
<dd><code>foreignKeyExtractor</code> - a <a href="https://docs.oracle.com/en/java/javase/15/docs/api/java.base/java/util/function/Function.html" title="class or interface in java.util.function" class="external-link"><code>Function</code></a> that extracts the key (KO) from this table's value (V). If the
                            result is null, the update is ignored as invalid.</dd>
<dd><code>joiner</code> - a <a href="ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueJoiner</code></a> that computes the join result for a pair of matching records</dd>
<dd><code>materialized</code> - a <a href="Materialized.html" title="class in org.apache.kafka.streams.kstream"><code>Materialized</code></a> that describes how the <a href="../processor/StateStore.html" title="interface in org.apache.kafka.streams.processor"><code>StateStore</code></a> for the resulting <code>KTable</code>
                            should be materialized. Cannot be <code>null</code></dd>
<dt>Returns:</dt>
<dd>a <code>KTable</code> that contains the result of joining this table with <code>other</code></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="join(org.apache.kafka.streams.kstream.KTable,java.util.function.Function,org.apache.kafka.streams.kstream.ValueJoiner,org.apache.kafka.streams.kstream.Named,org.apache.kafka.streams.kstream.Materialized)">
<h3>join</h3>
<div class="member-signature"><span class="type-parameters">&lt;VR,&#8203;
KO,&#8203;
VO&gt;</span>&nbsp;<span class="return-type"><a href="KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;VR&gt;</span>&nbsp;<span class="member-name">join</span>&#8203;(<span class="parameters"><a href="KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;KO,&#8203;VO&gt;&nbsp;other,
<a href="https://docs.oracle.com/en/java/javase/15/docs/api/java.base/java/util/function/Function.html" title="class or interface in java.util.function" class="external-link">Function</a>&lt;<a href="KTable.html" title="type parameter in KTable">V</a>,&#8203;KO&gt;&nbsp;foreignKeyExtractor,
<a href="ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream">ValueJoiner</a>&lt;<a href="KTable.html" title="type parameter in KTable">V</a>,&#8203;VO,&#8203;VR&gt;&nbsp;joiner,
<a href="Named.html" title="class in org.apache.kafka.streams.kstream">Named</a>&nbsp;named,
<a href="Materialized.html" title="class in org.apache.kafka.streams.kstream">Materialized</a>&lt;<a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;VR,&#8203;<a href="../state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state">KeyValueStore</a>&lt;org.apache.kafka.common.utils.Bytes,&#8203;byte[]&gt;&gt;&nbsp;materialized)</span></div>
<div class="block">Join records of this <code>KTable</code> with another <code>KTable</code> using non-windowed inner join.
 <p>
 This is a foreign key join, where the joining key is determined by the <code>foreignKeyExtractor</code>.</div>
<dl class="notes">
<dt>Type Parameters:</dt>
<dd><code>VR</code> - the value type of the result <code>KTable</code></dd>
<dd><code>KO</code> - the key type of the other <code>KTable</code></dd>
<dd><code>VO</code> - the value type of the other <code>KTable</code></dd>
<dt>Parameters:</dt>
<dd><code>other</code> - the other <code>KTable</code> to be joined with this <code>KTable</code>. Keyed by KO.</dd>
<dd><code>foreignKeyExtractor</code> - a <a href="https://docs.oracle.com/en/java/javase/15/docs/api/java.base/java/util/function/Function.html" title="class or interface in java.util.function" class="external-link"><code>Function</code></a> that extracts the key (KO) from this table's value (V). If the
                            result is null, the update is ignored as invalid.</dd>
<dd><code>joiner</code> - a <a href="ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueJoiner</code></a> that computes the join result for a pair of matching records</dd>
<dd><code>named</code> - a <a href="Named.html" title="class in org.apache.kafka.streams.kstream"><code>Named</code></a> config used to name the processor in the topology</dd>
<dd><code>materialized</code> - a <a href="Materialized.html" title="class in org.apache.kafka.streams.kstream"><code>Materialized</code></a> that describes how the <a href="../processor/StateStore.html" title="interface in org.apache.kafka.streams.processor"><code>StateStore</code></a> for the resulting <code>KTable</code>
                            should be materialized. Cannot be <code>null</code></dd>
<dt>Returns:</dt>
<dd>a <code>KTable</code> that contains the result of joining this table with <code>other</code></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="leftJoin(org.apache.kafka.streams.kstream.KTable,java.util.function.Function,org.apache.kafka.streams.kstream.ValueJoiner)">
<h3>leftJoin</h3>
<div class="member-signature"><span class="type-parameters">&lt;VR,&#8203;
KO,&#8203;
VO&gt;</span>&nbsp;<span class="return-type"><a href="KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;VR&gt;</span>&nbsp;<span class="member-name">leftJoin</span>&#8203;(<span class="parameters"><a href="KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;KO,&#8203;VO&gt;&nbsp;other,
<a href="https://docs.oracle.com/en/java/javase/15/docs/api/java.base/java/util/function/Function.html" title="class or interface in java.util.function" class="external-link">Function</a>&lt;<a href="KTable.html" title="type parameter in KTable">V</a>,&#8203;KO&gt;&nbsp;foreignKeyExtractor,
<a href="ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream">ValueJoiner</a>&lt;<a href="KTable.html" title="type parameter in KTable">V</a>,&#8203;VO,&#8203;VR&gt;&nbsp;joiner)</span></div>
<div class="block">Join records of this <code>KTable</code> with another <code>KTable</code> using non-windowed left join.
 <p>
 This is a foreign key join, where the joining key is determined by the <code>foreignKeyExtractor</code>.</div>
<dl class="notes">
<dt>Type Parameters:</dt>
<dd><code>VR</code> - the value type of the result <code>KTable</code></dd>
<dd><code>KO</code> - the key type of the other <code>KTable</code></dd>
<dd><code>VO</code> - the value type of the other <code>KTable</code></dd>
<dt>Parameters:</dt>
<dd><code>other</code> - the other <code>KTable</code> to be joined with this <code>KTable</code>. Keyed by KO.</dd>
<dd><code>foreignKeyExtractor</code> - a <a href="https://docs.oracle.com/en/java/javase/15/docs/api/java.base/java/util/function/Function.html" title="class or interface in java.util.function" class="external-link"><code>Function</code></a> that extracts the key (KO) from this table's value (V). If the
                            result is null, the update is ignored as invalid.</dd>
<dd><code>joiner</code> - a <a href="ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueJoiner</code></a> that computes the join result for a pair of matching records</dd>
<dt>Returns:</dt>
<dd>a <code>KTable</code> that contains only those records that satisfy the given predicate</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="leftJoin(org.apache.kafka.streams.kstream.KTable,java.util.function.Function,org.apache.kafka.streams.kstream.ValueJoiner,org.apache.kafka.streams.kstream.Named)">
<h3>leftJoin</h3>
<div class="member-signature"><span class="type-parameters">&lt;VR,&#8203;
KO,&#8203;
VO&gt;</span>&nbsp;<span class="return-type"><a href="KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;VR&gt;</span>&nbsp;<span class="member-name">leftJoin</span>&#8203;(<span class="parameters"><a href="KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;KO,&#8203;VO&gt;&nbsp;other,
<a href="https://docs.oracle.com/en/java/javase/15/docs/api/java.base/java/util/function/Function.html" title="class or interface in java.util.function" class="external-link">Function</a>&lt;<a href="KTable.html" title="type parameter in KTable">V</a>,&#8203;KO&gt;&nbsp;foreignKeyExtractor,
<a href="ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream">ValueJoiner</a>&lt;<a href="KTable.html" title="type parameter in KTable">V</a>,&#8203;VO,&#8203;VR&gt;&nbsp;joiner,
<a href="Named.html" title="class in org.apache.kafka.streams.kstream">Named</a>&nbsp;named)</span></div>
<div class="block">Join records of this <code>KTable</code> with another <code>KTable</code> using non-windowed left join.
 <p>
 This is a foreign key join, where the joining key is determined by the <code>foreignKeyExtractor</code>.</div>
<dl class="notes">
<dt>Type Parameters:</dt>
<dd><code>VR</code> - the value type of the result <code>KTable</code></dd>
<dd><code>KO</code> - the key type of the other <code>KTable</code></dd>
<dd><code>VO</code> - the value type of the other <code>KTable</code></dd>
<dt>Parameters:</dt>
<dd><code>other</code> - the other <code>KTable</code> to be joined with this <code>KTable</code>. Keyed by KO.</dd>
<dd><code>foreignKeyExtractor</code> - a <a href="https://docs.oracle.com/en/java/javase/15/docs/api/java.base/java/util/function/Function.html" title="class or interface in java.util.function" class="external-link"><code>Function</code></a> that extracts the key (KO) from this table's value (V) If the
                            result is null, the update is ignored as invalid.</dd>
<dd><code>joiner</code> - a <a href="ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueJoiner</code></a> that computes the join result for a pair of matching records</dd>
<dd><code>named</code> - a <a href="Named.html" title="class in org.apache.kafka.streams.kstream"><code>Named</code></a> config used to name the processor in the topology</dd>
<dt>Returns:</dt>
<dd>a <code>KTable</code> that contains the result of joining this table with <code>other</code></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="leftJoin(org.apache.kafka.streams.kstream.KTable,java.util.function.Function,org.apache.kafka.streams.kstream.ValueJoiner,org.apache.kafka.streams.kstream.Materialized)">
<h3>leftJoin</h3>
<div class="member-signature"><span class="type-parameters">&lt;VR,&#8203;
KO,&#8203;
VO&gt;</span>&nbsp;<span class="return-type"><a href="KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;VR&gt;</span>&nbsp;<span class="member-name">leftJoin</span>&#8203;(<span class="parameters"><a href="KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;KO,&#8203;VO&gt;&nbsp;other,
<a href="https://docs.oracle.com/en/java/javase/15/docs/api/java.base/java/util/function/Function.html" title="class or interface in java.util.function" class="external-link">Function</a>&lt;<a href="KTable.html" title="type parameter in KTable">V</a>,&#8203;KO&gt;&nbsp;foreignKeyExtractor,
<a href="ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream">ValueJoiner</a>&lt;<a href="KTable.html" title="type parameter in KTable">V</a>,&#8203;VO,&#8203;VR&gt;&nbsp;joiner,
<a href="Materialized.html" title="class in org.apache.kafka.streams.kstream">Materialized</a>&lt;<a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;VR,&#8203;<a href="../state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state">KeyValueStore</a>&lt;org.apache.kafka.common.utils.Bytes,&#8203;byte[]&gt;&gt;&nbsp;materialized)</span></div>
<div class="block">Join records of this <code>KTable</code> with another <code>KTable</code> using non-windowed left join.
 <p>
 This is a foreign key join, where the joining key is determined by the <code>foreignKeyExtractor</code>.</div>
<dl class="notes">
<dt>Type Parameters:</dt>
<dd><code>VR</code> - the value type of the result <code>KTable</code></dd>
<dd><code>KO</code> - the key type of the other <code>KTable</code></dd>
<dd><code>VO</code> - the value type of the other <code>KTable</code></dd>
<dt>Parameters:</dt>
<dd><code>other</code> - the other <code>KTable</code> to be joined with this <code>KTable</code>. Keyed by KO.</dd>
<dd><code>foreignKeyExtractor</code> - a <a href="https://docs.oracle.com/en/java/javase/15/docs/api/java.base/java/util/function/Function.html" title="class or interface in java.util.function" class="external-link"><code>Function</code></a> that extracts the key (KO) from this table's value (V). If the
                            result is null, the update is ignored as invalid.</dd>
<dd><code>joiner</code> - a <a href="ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueJoiner</code></a> that computes the join result for a pair of matching records</dd>
<dd><code>materialized</code> - a <a href="Materialized.html" title="class in org.apache.kafka.streams.kstream"><code>Materialized</code></a> that describes how the <a href="../processor/StateStore.html" title="interface in org.apache.kafka.streams.processor"><code>StateStore</code></a> for the resulting <code>KTable</code>
                            should be materialized. Cannot be <code>null</code></dd>
<dt>Returns:</dt>
<dd>a <code>KTable</code> that contains the result of joining this table with <code>other</code></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="leftJoin(org.apache.kafka.streams.kstream.KTable,java.util.function.Function,org.apache.kafka.streams.kstream.ValueJoiner,org.apache.kafka.streams.kstream.Named,org.apache.kafka.streams.kstream.Materialized)">
<h3>leftJoin</h3>
<div class="member-signature"><span class="type-parameters">&lt;VR,&#8203;
KO,&#8203;
VO&gt;</span>&nbsp;<span class="return-type"><a href="KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;VR&gt;</span>&nbsp;<span class="member-name">leftJoin</span>&#8203;(<span class="parameters"><a href="KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;KO,&#8203;VO&gt;&nbsp;other,
<a href="https://docs.oracle.com/en/java/javase/15/docs/api/java.base/java/util/function/Function.html" title="class or interface in java.util.function" class="external-link">Function</a>&lt;<a href="KTable.html" title="type parameter in KTable">V</a>,&#8203;KO&gt;&nbsp;foreignKeyExtractor,
<a href="ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream">ValueJoiner</a>&lt;<a href="KTable.html" title="type parameter in KTable">V</a>,&#8203;VO,&#8203;VR&gt;&nbsp;joiner,
<a href="Named.html" title="class in org.apache.kafka.streams.kstream">Named</a>&nbsp;named,
<a href="Materialized.html" title="class in org.apache.kafka.streams.kstream">Materialized</a>&lt;<a href="KTable.html" title="type parameter in KTable">K</a>,&#8203;VR,&#8203;<a href="../state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state">KeyValueStore</a>&lt;org.apache.kafka.common.utils.Bytes,&#8203;byte[]&gt;&gt;&nbsp;materialized)</span></div>
<div class="block">Join records of this <code>KTable</code> with another <code>KTable</code> using non-windowed left join.
 <p>
 This is a foreign key join, where the joining key is determined by the <code>foreignKeyExtractor</code>.</div>
<dl class="notes">
<dt>Type Parameters:</dt>
<dd><code>VR</code> - the value type of the result <code>KTable</code></dd>
<dd><code>KO</code> - the key type of the other <code>KTable</code></dd>
<dd><code>VO</code> - the value type of the other <code>KTable</code></dd>
<dt>Parameters:</dt>
<dd><code>other</code> - the other <code>KTable</code> to be joined with this <code>KTable</code>. Keyed by KO.</dd>
<dd><code>foreignKeyExtractor</code> - a <a href="https://docs.oracle.com/en/java/javase/15/docs/api/java.base/java/util/function/Function.html" title="class or interface in java.util.function" class="external-link"><code>Function</code></a> that extracts the key (KO) from this table's value (V) If the
                            result is null, the update is ignored as invalid.</dd>
<dd><code>joiner</code> - a <a href="ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueJoiner</code></a> that computes the join result for a pair of matching records</dd>
<dd><code>named</code> - a <a href="Named.html" title="class in org.apache.kafka.streams.kstream"><code>Named</code></a> config used to name the processor in the topology</dd>
<dd><code>materialized</code> - a <a href="Materialized.html" title="class in org.apache.kafka.streams.kstream"><code>Materialized</code></a> that describes how the <a href="../processor/StateStore.html" title="interface in org.apache.kafka.streams.processor"><code>StateStore</code></a> for the resulting <code>KTable</code>
                            should be materialized. Cannot be <code>null</code></dd>
<dt>Returns:</dt>
<dd>a <code>KTable</code> that contains the result of joining this table with <code>other</code></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="queryableStoreName()">
<h3>queryableStoreName</h3>
<div class="member-signature"><span class="return-type"><a href="https://docs.oracle.com/en/java/javase/15/docs/api/java.base/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></span>&nbsp;<span class="member-name">queryableStoreName</span>()</div>
<div class="block">Get the name of the local state store used that can be used to query this <code>KTable</code>.</div>
<dl class="notes">
<dt>Returns:</dt>
<dd>the underlying state store name, or <code>null</code> if this <code>KTable</code> cannot be queried.</dd>
</dl>
</section>
</li>
</ul>
</section>
</li>
</ul>
</section>
<!-- ========= END OF CLASS DATA ========= -->
</main>
<footer role="contentinfo">
<nav role="navigation">
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottom-nav" id="navbar.bottom">
<div class="skip-nav"><a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a></div>
<ul id="navbar.bottom.firstrow" class="nav-list" title="Navigation">
<li><a href="../../../../../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="nav-bar-cell1-rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../../index-all.html">Index</a></li>
<li><a href="../../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="sub-nav">
<div>
<ul class="sub-nav-list">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="sub-nav-list">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
</div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
<span class="skip-nav" id="skip.navbar.bottom">
<!--   -->
</span></nav>
</footer>
</div>
</div>
</body>
</html>

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (9.0.1) on Tue Oct 23 23:20:00 IST 2018 -->
<title>KTable (kafka 2.0.0 API)</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="date" content="2018-10-23">
<link rel="stylesheet" type="text/css" href="../../../../../stylesheet.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../../../../jquery/jquery-ui.css" title="Style">
<script type="text/javascript" src="../../../../../script.js"></script>
<script type="text/javascript" src="../../../../../jquery/jszip/dist/jszip.min.js"></script>
<script type="text/javascript" src="../../../../../jquery/jszip-utils/dist/jszip-utils.min.js"></script>
<!--[if IE]>
<script type="text/javascript" src="../../../../../jquery/jszip-utils/dist/jszip-utils-ie.min.js"></script>
<![endif]-->
<script type="text/javascript" src="../../../../../jquery/jquery-1.10.2.js"></script>
<script type="text/javascript" src="../../../../../jquery/jquery-ui.js"></script>
</head>
<body>
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="KTable (kafka 2.0.0 API)";
        }
    }
    catch(err) {
    }
//-->
var methods = {"i0":6,"i1":6,"i2":6,"i3":6,"i4":6,"i5":6,"i6":6,"i7":6,"i8":6,"i9":6,"i10":6,"i11":6,"i12":6,"i13":6,"i14":6,"i15":6,"i16":6,"i17":6,"i18":6,"i19":6,"i20":6};
var tabs = {65535:["t0","All Methods"],2:["t2","Instance Methods"],4:["t3","Abstract Methods"]};
var altColor = "altColor";
var rowColor = "rowColor";
var tableTab = "tableTab";
var activeTableTab = "activeTableTab";
var pathtoroot = "../../../../../";loadScripts(document, 'script');</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<div class="fixedNav">
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a name="navbar.top">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<a name="navbar.top.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../../../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../../index-all.html">Index</a></li>
<li><a href="../../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="interface in org.apache.kafka.streams.kstream"><span class="typeNameLink">Prev&nbsp;Class</span></a></li>
<li><a href="../../../../../org/apache/kafka/streams/kstream/Materialized.html" title="class in org.apache.kafka.streams.kstream"><span class="typeNameLink">Next&nbsp;Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../../../../index.html?org/apache/kafka/streams/kstream/KTable.html" target="_top">Frames</a></li>
<li><a href="KTable.html" target="_top">No&nbsp;Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_top">
<li><a href="../../../../../allclasses-noframe.html">All&nbsp;Classes</a></li>
</ul>
<ul class="navListSearch">
<li><span>SEARCH:&nbsp;</span>
<input type="text" id="search" value=" " disabled="disabled">
<input type="reset" id="reset" value=" " disabled="disabled">
</li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a name="skip.navbar.top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
</div>
<div class="navPadding">&nbsp;</div>
<script type="text/javascript"><!--
$('.navPadding').css('padding-top', $('.fixedNav').css("height"));
//-->
</script>
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="subTitle"><span class="packageLabelInType">Package</span>&nbsp;<a href="../../../../../org/apache/kafka/streams/kstream/package-summary.html">org.apache.kafka.streams.kstream</a></div>
<h2 title="Interface KTable" class="title">Interface KTable&lt;K,V&gt;</h2>
</div>
<div class="contentContainer">
<div class="description">
<ul class="blockList">
<li class="blockList">
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>K</code> - Type of primary keys</dd>
<dd><code>V</code> - Type of value changes</dd>
</dl>
<hr>
<br>
<pre><a href="../../../../../org/apache/kafka/common/annotation/InterfaceStability.Evolving.html" title="annotation in org.apache.kafka.common.annotation">@Evolving</a>
public interface <span class="typeNameLabel">KTable&lt;K,V&gt;</span></pre>
<div class="block"><code>KTable</code> is an abstraction of a <i>changelog stream</i> from a primary-keyed table.
 Each record in this changelog stream is an update on the primary-keyed table with the record key as the primary key.
 <p>
 A <code>KTable</code> is either <a href="../../../../../org/apache/kafka/streams/StreamsBuilder.html#table-java.lang.String-"><code>defined from a single Kafka topic</code></a> that is
 consumed message by message or the result of a <code>KTable</code> transformation.
 An aggregation of a <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="interface in org.apache.kafka.streams.kstream"><code>KStream</code></a> also yields a <code>KTable</code>.
 <p>
 A <code>KTable</code> can be transformed record by record, joined with another <code>KTable</code> or <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="interface in org.apache.kafka.streams.kstream"><code>KStream</code></a>, or
 can be re-partitioned and aggregated into a new <code>KTable</code>.
 <p>
 Some <code>KTable</code>s have an internal state (a <a href="../../../../../org/apache/kafka/streams/state/ReadOnlyKeyValueStore.html" title="interface in org.apache.kafka.streams.state"><code>ReadOnlyKeyValueStore</code></a>) and are therefore queryable via the
 interactive queries API.
 For example:
 <pre><code>
     final KTable table = ...
     ...
     final KafkaStreams streams = ...;
     streams.start()
     ...
     final String queryableStoreName = table.queryableStoreName(); // returns null if KTable is not queryable
     ReadOnlyKeyValueStore view = streams.store(queryableStoreName, QueryableStoreTypes.keyValueStore());
     view.get(key);
</code></pre>
<p>
 Records from the source topic that have null keys are dropped.</div>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="interface in org.apache.kafka.streams.kstream"><code>KStream</code></a>, 
<a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KGroupedTable</code></a>, 
<a href="../../../../../org/apache/kafka/streams/kstream/GlobalKTable.html" title="interface in org.apache.kafka.streams.kstream"><code>GlobalKTable</code></a>, 
<a href="../../../../../org/apache/kafka/streams/StreamsBuilder.html#table-java.lang.String-"><code>StreamsBuilder.table(String)</code></a></dd>
</dl>
</li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- ========== METHOD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="method.summary">
<!--   -->
</a>
<h3>Method Summary</h3>
<table class="memberSummary" summary="Method Summary table, listing methods, and an explanation">
<caption><span id="t0" class="activeTableTab"><span>All Methods</span><span class="tabEnd">&nbsp;</span></span><span id="t2" class="tableTab"><span><a href="javascript:show(2);">Instance Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t3" class="tableTab"><span><a href="javascript:show(4);">Abstract Methods</a></span><span class="tabEnd">&nbsp;</span></span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colSecond" scope="col">Method</th>
<th class="colLast" scope="col">Description</th>
</tr>
<tr id="i0" class="altColor">
<td class="colFirst"><code><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#filter-org.apache.kafka.streams.kstream.Predicate-">filter</a></span>&#8203;(<a href="../../../../../org/apache/kafka/streams/kstream/Predicate.html" title="interface in org.apache.kafka.streams.kstream">Predicate</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,? super <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>&gt;&nbsp;predicate)</code></th>
<td class="colLast">
<div class="block">Create a new <code>KTable</code> that consists of all records of this <code>KTable</code> which satisfy the given
 predicate, with default serializers, deserializers, and state store.</div>
</td>
</tr>
<tr id="i1" class="rowColor">
<td class="colFirst"><code><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#filter-org.apache.kafka.streams.kstream.Predicate-org.apache.kafka.streams.kstream.Materialized-">filter</a></span>&#8203;(<a href="../../../../../org/apache/kafka/streams/kstream/Predicate.html" title="interface in org.apache.kafka.streams.kstream">Predicate</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,? super <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>&gt;&nbsp;predicate,
      <a href="../../../../../org/apache/kafka/streams/kstream/Materialized.html" title="class in org.apache.kafka.streams.kstream">Materialized</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>,<a href="../../../../../org/apache/kafka/streams/state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state">KeyValueStore</a>&lt;org.apache.kafka.common.utils.Bytes,byte[]&gt;&gt;&nbsp;materialized)</code></th>
<td class="colLast">
<div class="block">Create a new <code>KTable</code> that consists of all records of this <code>KTable</code> which satisfy the given
 predicate, with the <a href="../../../../../org/apache/kafka/common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization"><code>key serde</code></a>, <a href="../../../../../org/apache/kafka/common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization"><code>value serde</code></a>, and the underlying
 <a href="../../../../../org/apache/kafka/streams/state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state"><code>materialized state storage</code></a> configured in the <a href="../../../../../org/apache/kafka/streams/kstream/Materialized.html" title="class in org.apache.kafka.streams.kstream"><code>Materialized</code></a> instance.</div>
</td>
</tr>
<tr id="i2" class="altColor">
<td class="colFirst"><code><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#filterNot-org.apache.kafka.streams.kstream.Predicate-">filterNot</a></span>&#8203;(<a href="../../../../../org/apache/kafka/streams/kstream/Predicate.html" title="interface in org.apache.kafka.streams.kstream">Predicate</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,? super <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>&gt;&nbsp;predicate)</code></th>
<td class="colLast">
<div class="block">Create a new <code>KTable</code> that consists all records of this <code>KTable</code> which do <em>not</em> satisfy the
 given predicate, with default serializers, deserializers, and state store.</div>
</td>
</tr>
<tr id="i3" class="rowColor">
<td class="colFirst"><code><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#filterNot-org.apache.kafka.streams.kstream.Predicate-org.apache.kafka.streams.kstream.Materialized-">filterNot</a></span>&#8203;(<a href="../../../../../org/apache/kafka/streams/kstream/Predicate.html" title="interface in org.apache.kafka.streams.kstream">Predicate</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,? super <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>&gt;&nbsp;predicate,
         <a href="../../../../../org/apache/kafka/streams/kstream/Materialized.html" title="class in org.apache.kafka.streams.kstream">Materialized</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>,<a href="../../../../../org/apache/kafka/streams/state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state">KeyValueStore</a>&lt;org.apache.kafka.common.utils.Bytes,byte[]&gt;&gt;&nbsp;materialized)</code></th>
<td class="colLast">
<div class="block">Create a new <code>KTable</code> that consists all records of this <code>KTable</code> which do <em>not</em> satisfy the
 given predicate, with the <a href="../../../../../org/apache/kafka/common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization"><code>key serde</code></a>, <a href="../../../../../org/apache/kafka/common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization"><code>value serde</code></a>, and the underlying
 <a href="../../../../../org/apache/kafka/streams/state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state"><code>materialized state storage</code></a> configured in the <a href="../../../../../org/apache/kafka/streams/kstream/Materialized.html" title="class in org.apache.kafka.streams.kstream"><code>Materialized</code></a> instance.</div>
</td>
</tr>
<tr id="i4" class="altColor">
<td class="colFirst"><code>&lt;KR,VR&gt;&nbsp;<a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html" title="interface in org.apache.kafka.streams.kstream">KGroupedTable</a>&lt;KR,VR&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#groupBy-org.apache.kafka.streams.kstream.KeyValueMapper-">groupBy</a></span>&#8203;(<a href="../../../../../org/apache/kafka/streams/kstream/KeyValueMapper.html" title="interface in org.apache.kafka.streams.kstream">KeyValueMapper</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,? super <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>,<a href="../../../../../org/apache/kafka/streams/KeyValue.html" title="class in org.apache.kafka.streams">KeyValue</a>&lt;KR,VR&gt;&gt;&nbsp;selector)</code></th>
<td class="colLast">
<div class="block">Re-groups the records of this <code>KTable</code> using the provided <a href="../../../../../org/apache/kafka/streams/kstream/KeyValueMapper.html" title="interface in org.apache.kafka.streams.kstream"><code>KeyValueMapper</code></a> and default serializers
 and deserializers.</div>
</td>
</tr>
<tr id="i5" class="rowColor">
<td class="colFirst"><code>&lt;KR,VR&gt;&nbsp;<a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html" title="interface in org.apache.kafka.streams.kstream">KGroupedTable</a>&lt;KR,VR&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#groupBy-org.apache.kafka.streams.kstream.KeyValueMapper-org.apache.kafka.streams.kstream.Serialized-">groupBy</a></span>&#8203;(<a href="../../../../../org/apache/kafka/streams/kstream/KeyValueMapper.html" title="interface in org.apache.kafka.streams.kstream">KeyValueMapper</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,? super <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>,<a href="../../../../../org/apache/kafka/streams/KeyValue.html" title="class in org.apache.kafka.streams">KeyValue</a>&lt;KR,VR&gt;&gt;&nbsp;selector,
       <a href="../../../../../org/apache/kafka/streams/kstream/Serialized.html" title="class in org.apache.kafka.streams.kstream">Serialized</a>&lt;KR,VR&gt;&nbsp;serialized)</code></th>
<td class="colLast">
<div class="block">Re-groups the records of this <code>KTable</code> using the provided <a href="../../../../../org/apache/kafka/streams/kstream/KeyValueMapper.html" title="interface in org.apache.kafka.streams.kstream"><code>KeyValueMapper</code></a>
 and <a href="../../../../../org/apache/kafka/common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization"><code>Serde</code></a>s as specified by <a href="../../../../../org/apache/kafka/streams/kstream/Serialized.html" title="class in org.apache.kafka.streams.kstream"><code>Serialized</code></a>.</div>
</td>
</tr>
<tr id="i6" class="altColor">
<td class="colFirst"><code>&lt;VO,VR&gt;&nbsp;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,VR&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#join-org.apache.kafka.streams.kstream.KTable-org.apache.kafka.streams.kstream.ValueJoiner-">join</a></span>&#8203;(<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,VO&gt;&nbsp;other,
    <a href="../../../../../org/apache/kafka/streams/kstream/ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream">ValueJoiner</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>,? super VO,? extends VR&gt;&nbsp;joiner)</code></th>
<td class="colLast">
<div class="block">Join records of this <code>KTable</code> with another <code>KTable</code>'s records using non-windowed inner equi join,
 with default serializers, deserializers, and state store.</div>
</td>
</tr>
<tr id="i7" class="rowColor">
<td class="colFirst"><code>&lt;VO,VR&gt;&nbsp;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,VR&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#join-org.apache.kafka.streams.kstream.KTable-org.apache.kafka.streams.kstream.ValueJoiner-org.apache.kafka.streams.kstream.Materialized-">join</a></span>&#8203;(<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,VO&gt;&nbsp;other,
    <a href="../../../../../org/apache/kafka/streams/kstream/ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream">ValueJoiner</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>,? super VO,? extends VR&gt;&nbsp;joiner,
    <a href="../../../../../org/apache/kafka/streams/kstream/Materialized.html" title="class in org.apache.kafka.streams.kstream">Materialized</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,VR,<a href="../../../../../org/apache/kafka/streams/state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state">KeyValueStore</a>&lt;org.apache.kafka.common.utils.Bytes,byte[]&gt;&gt;&nbsp;materialized)</code></th>
<td class="colLast">
<div class="block">Join records of this <code>KTable</code> with another <code>KTable</code>'s records using non-windowed inner equi join,
 with the <a href="../../../../../org/apache/kafka/streams/kstream/Materialized.html" title="class in org.apache.kafka.streams.kstream"><code>Materialized</code></a> instance for configuration of the <a href="../../../../../org/apache/kafka/common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization"><code>key serde</code></a>,
 <a href="../../../../../org/apache/kafka/common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization"><code>the result table's value serde</code></a>, and <a href="../../../../../org/apache/kafka/streams/state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state"><code>state store</code></a>.</div>
</td>
</tr>
<tr id="i8" class="altColor">
<td class="colFirst"><code>&lt;VO,VR&gt;&nbsp;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,VR&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#leftJoin-org.apache.kafka.streams.kstream.KTable-org.apache.kafka.streams.kstream.ValueJoiner-">leftJoin</a></span>&#8203;(<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,VO&gt;&nbsp;other,
        <a href="../../../../../org/apache/kafka/streams/kstream/ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream">ValueJoiner</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>,? super VO,? extends VR&gt;&nbsp;joiner)</code></th>
<td class="colLast">
<div class="block">Join records of this <code>KTable</code> (left input) with another <code>KTable</code>'s (right input) records using
 non-windowed left equi join, with default serializers, deserializers, and state store.</div>
</td>
</tr>
<tr id="i9" class="rowColor">
<td class="colFirst"><code>&lt;VO,VR&gt;&nbsp;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,VR&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#leftJoin-org.apache.kafka.streams.kstream.KTable-org.apache.kafka.streams.kstream.ValueJoiner-org.apache.kafka.streams.kstream.Materialized-">leftJoin</a></span>&#8203;(<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,VO&gt;&nbsp;other,
        <a href="../../../../../org/apache/kafka/streams/kstream/ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream">ValueJoiner</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>,? super VO,? extends VR&gt;&nbsp;joiner,
        <a href="../../../../../org/apache/kafka/streams/kstream/Materialized.html" title="class in org.apache.kafka.streams.kstream">Materialized</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,VR,<a href="../../../../../org/apache/kafka/streams/state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state">KeyValueStore</a>&lt;org.apache.kafka.common.utils.Bytes,byte[]&gt;&gt;&nbsp;materialized)</code></th>
<td class="colLast">
<div class="block">Join records of this <code>KTable</code> (left input) with another <code>KTable</code>'s (right input) records using
 non-windowed left equi join, with the <a href="../../../../../org/apache/kafka/streams/kstream/Materialized.html" title="class in org.apache.kafka.streams.kstream"><code>Materialized</code></a> instance for configuration of the <a href="../../../../../org/apache/kafka/common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization"><code>key serde</code></a>,
 <a href="../../../../../org/apache/kafka/common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization"><code>the result table's value serde</code></a>, and <a href="../../../../../org/apache/kafka/streams/state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state"><code>state store</code></a>.</div>
</td>
</tr>
<tr id="i10" class="altColor">
<td class="colFirst"><code>&lt;VR&gt;&nbsp;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,VR&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#mapValues-org.apache.kafka.streams.kstream.ValueMapper-">mapValues</a></span>&#8203;(<a href="../../../../../org/apache/kafka/streams/kstream/ValueMapper.html" title="interface in org.apache.kafka.streams.kstream">ValueMapper</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>,? extends VR&gt;&nbsp;mapper)</code></th>
<td class="colLast">
<div class="block">Create a new <code>KTable</code> by transforming the value of each record in this <code>KTable</code> into a new value
 (with possibly a new type) in the new <code>KTable</code>, with default serializers, deserializers, and state store.</div>
</td>
</tr>
<tr id="i11" class="rowColor">
<td class="colFirst"><code>&lt;VR&gt;&nbsp;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,VR&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#mapValues-org.apache.kafka.streams.kstream.ValueMapper-org.apache.kafka.streams.kstream.Materialized-">mapValues</a></span>&#8203;(<a href="../../../../../org/apache/kafka/streams/kstream/ValueMapper.html" title="interface in org.apache.kafka.streams.kstream">ValueMapper</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>,? extends VR&gt;&nbsp;mapper,
         <a href="../../../../../org/apache/kafka/streams/kstream/Materialized.html" title="class in org.apache.kafka.streams.kstream">Materialized</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,VR,<a href="../../../../../org/apache/kafka/streams/state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state">KeyValueStore</a>&lt;org.apache.kafka.common.utils.Bytes,byte[]&gt;&gt;&nbsp;materialized)</code></th>
<td class="colLast">
<div class="block">Create a new <code>KTable</code> by transforming the value of each record in this <code>KTable</code> into a new value
 (with possibly a new type) in the new <code>KTable</code>, with the <a href="../../../../../org/apache/kafka/common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization"><code>key serde</code></a>, <a href="../../../../../org/apache/kafka/common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization"><code>value serde</code></a>,
 and the underlying <a href="../../../../../org/apache/kafka/streams/state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state"><code>materialized state storage</code></a> configured in the <a href="../../../../../org/apache/kafka/streams/kstream/Materialized.html" title="class in org.apache.kafka.streams.kstream"><code>Materialized</code></a>
 instance.</div>
</td>
</tr>
<tr id="i12" class="altColor">
<td class="colFirst"><code>&lt;VR&gt;&nbsp;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,VR&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#mapValues-org.apache.kafka.streams.kstream.ValueMapperWithKey-">mapValues</a></span>&#8203;(<a href="../../../../../org/apache/kafka/streams/kstream/ValueMapperWithKey.html" title="interface in org.apache.kafka.streams.kstream">ValueMapperWithKey</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,? super <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>,? extends VR&gt;&nbsp;mapper)</code></th>
<td class="colLast">
<div class="block">Create a new <code>KTable</code> by transforming the value of each record in this <code>KTable</code> into a new value
 (with possibly a new type) in the new <code>KTable</code>, with default serializers, deserializers, and state store.</div>
</td>
</tr>
<tr id="i13" class="rowColor">
<td class="colFirst"><code>&lt;VR&gt;&nbsp;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,VR&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#mapValues-org.apache.kafka.streams.kstream.ValueMapperWithKey-org.apache.kafka.streams.kstream.Materialized-">mapValues</a></span>&#8203;(<a href="../../../../../org/apache/kafka/streams/kstream/ValueMapperWithKey.html" title="interface in org.apache.kafka.streams.kstream">ValueMapperWithKey</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,? super <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>,? extends VR&gt;&nbsp;mapper,
         <a href="../../../../../org/apache/kafka/streams/kstream/Materialized.html" title="class in org.apache.kafka.streams.kstream">Materialized</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,VR,<a href="../../../../../org/apache/kafka/streams/state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state">KeyValueStore</a>&lt;org.apache.kafka.common.utils.Bytes,byte[]&gt;&gt;&nbsp;materialized)</code></th>
<td class="colLast">
<div class="block">Create a new <code>KTable</code> by transforming the value of each record in this <code>KTable</code> into a new value
 (with possibly a new type) in the new <code>KTable</code>, with the <a href="../../../../../org/apache/kafka/common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization"><code>key serde</code></a>, <a href="../../../../../org/apache/kafka/common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization"><code>value serde</code></a>,
 and the underlying <a href="../../../../../org/apache/kafka/streams/state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state"><code>materialized state storage</code></a> configured in the <a href="../../../../../org/apache/kafka/streams/kstream/Materialized.html" title="class in org.apache.kafka.streams.kstream"><code>Materialized</code></a>
 instance.</div>
</td>
</tr>
<tr id="i14" class="altColor">
<td class="colFirst"><code>&lt;VO,VR&gt;&nbsp;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,VR&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#outerJoin-org.apache.kafka.streams.kstream.KTable-org.apache.kafka.streams.kstream.ValueJoiner-">outerJoin</a></span>&#8203;(<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,VO&gt;&nbsp;other,
         <a href="../../../../../org/apache/kafka/streams/kstream/ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream">ValueJoiner</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>,? super VO,? extends VR&gt;&nbsp;joiner)</code></th>
<td class="colLast">
<div class="block">Join records of this <code>KTable</code> (left input) with another <code>KTable</code>'s (right input) records using
 non-windowed outer equi join, with default serializers, deserializers, and state store.</div>
</td>
</tr>
<tr id="i15" class="rowColor">
<td class="colFirst"><code>&lt;VO,VR&gt;&nbsp;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,VR&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#outerJoin-org.apache.kafka.streams.kstream.KTable-org.apache.kafka.streams.kstream.ValueJoiner-org.apache.kafka.streams.kstream.Materialized-">outerJoin</a></span>&#8203;(<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,VO&gt;&nbsp;other,
         <a href="../../../../../org/apache/kafka/streams/kstream/ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream">ValueJoiner</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>,? super VO,? extends VR&gt;&nbsp;joiner,
         <a href="../../../../../org/apache/kafka/streams/kstream/Materialized.html" title="class in org.apache.kafka.streams.kstream">Materialized</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,VR,<a href="../../../../../org/apache/kafka/streams/state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state">KeyValueStore</a>&lt;org.apache.kafka.common.utils.Bytes,byte[]&gt;&gt;&nbsp;materialized)</code></th>
<td class="colLast">
<div class="block">Join records of this <code>KTable</code> (left input) with another <code>KTable</code>'s (right input) records using
 non-windowed outer equi join, with the <a href="../../../../../org/apache/kafka/streams/kstream/Materialized.html" title="class in org.apache.kafka.streams.kstream"><code>Materialized</code></a> instance for configuration of the <a href="../../../../../org/apache/kafka/common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization"><code>key serde</code></a>,
 <a href="../../../../../org/apache/kafka/common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization"><code>the result table's value serde</code></a>, and <a href="../../../../../org/apache/kafka/streams/state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state"><code>state store</code></a>.</div>
</td>
</tr>
<tr id="i16" class="altColor">
<td class="colFirst"><code>java.lang.String</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#queryableStoreName--">queryableStoreName</a></span>&#8203;()</code></th>
<td class="colLast">
<div class="block">Get the name of the local state store used that can be used to query this <code>KTable</code>.</div>
</td>
</tr>
<tr id="i17" class="rowColor">
<td class="colFirst"><code><a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="interface in org.apache.kafka.streams.kstream">KStream</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#toStream--">toStream</a></span>&#8203;()</code></th>
<td class="colLast">
<div class="block">Convert this changelog stream to a <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="interface in org.apache.kafka.streams.kstream"><code>KStream</code></a>.</div>
</td>
</tr>
<tr id="i18" class="altColor">
<td class="colFirst"><code>&lt;KR&gt;&nbsp;<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="interface in org.apache.kafka.streams.kstream">KStream</a>&lt;KR,<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#toStream-org.apache.kafka.streams.kstream.KeyValueMapper-">toStream</a></span>&#8203;(<a href="../../../../../org/apache/kafka/streams/kstream/KeyValueMapper.html" title="interface in org.apache.kafka.streams.kstream">KeyValueMapper</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,? super <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>,? extends KR&gt;&nbsp;mapper)</code></th>
<td class="colLast">
<div class="block">Convert this changelog stream to a <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="interface in org.apache.kafka.streams.kstream"><code>KStream</code></a> using the given <a href="../../../../../org/apache/kafka/streams/kstream/KeyValueMapper.html" title="interface in org.apache.kafka.streams.kstream"><code>KeyValueMapper</code></a> to select the new key.</div>
</td>
</tr>
<tr id="i19" class="rowColor">
<td class="colFirst"><code>&lt;VR&gt;&nbsp;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,VR&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#transformValues-org.apache.kafka.streams.kstream.ValueTransformerWithKeySupplier-java.lang.String...-">transformValues</a></span>&#8203;(<a href="../../../../../org/apache/kafka/streams/kstream/ValueTransformerWithKeySupplier.html" title="interface in org.apache.kafka.streams.kstream">ValueTransformerWithKeySupplier</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,? super <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>,? extends VR&gt;&nbsp;transformerSupplier,
               java.lang.String...&nbsp;stateStoreNames)</code></th>
<td class="colLast">
<div class="block">Create a new <code>KTable</code> by transforming the value of each record in this <code>KTable</code> into a new value
 (with possibly a new type), with default serializers, deserializers, and state store.</div>
</td>
</tr>
<tr id="i20" class="altColor">
<td class="colFirst"><code>&lt;VR&gt;&nbsp;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,VR&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#transformValues-org.apache.kafka.streams.kstream.ValueTransformerWithKeySupplier-org.apache.kafka.streams.kstream.Materialized-java.lang.String...-">transformValues</a></span>&#8203;(<a href="../../../../../org/apache/kafka/streams/kstream/ValueTransformerWithKeySupplier.html" title="interface in org.apache.kafka.streams.kstream">ValueTransformerWithKeySupplier</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,? super <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>,? extends VR&gt;&nbsp;transformerSupplier,
               <a href="../../../../../org/apache/kafka/streams/kstream/Materialized.html" title="class in org.apache.kafka.streams.kstream">Materialized</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,VR,<a href="../../../../../org/apache/kafka/streams/state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state">KeyValueStore</a>&lt;org.apache.kafka.common.utils.Bytes,byte[]&gt;&gt;&nbsp;materialized,
               java.lang.String...&nbsp;stateStoreNames)</code></th>
<td class="colLast">
<div class="block">Create a new <code>KTable</code> by transforming the value of each record in this <code>KTable</code> into a new value
 (with possibly a new type), with the <a href="../../../../../org/apache/kafka/common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization"><code>key serde</code></a>, <a href="../../../../../org/apache/kafka/common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization"><code>value serde</code></a>, and the underlying
 <a href="../../../../../org/apache/kafka/streams/state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state"><code>materialized state storage</code></a> configured in the <a href="../../../../../org/apache/kafka/streams/kstream/Materialized.html" title="class in org.apache.kafka.streams.kstream"><code>Materialized</code></a> instance.</div>
</td>
</tr>
</table>
</li>
</ul>
</li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ============ METHOD DETAIL ========== -->
<ul class="blockList">
<li class="blockList"><a name="method.detail">
<!--   -->
</a>
<h3>Method Detail</h3>
<a name="filter-org.apache.kafka.streams.kstream.Predicate-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>filter</h4>
<pre><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>&gt;&nbsp;filter&#8203;(<a href="../../../../../org/apache/kafka/streams/kstream/Predicate.html" title="interface in org.apache.kafka.streams.kstream">Predicate</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,? super <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>&gt;&nbsp;predicate)</pre>
<div class="block">Create a new <code>KTable</code> that consists of all records of this <code>KTable</code> which satisfy the given
 predicate, with default serializers, deserializers, and state store.
 All records that do not satisfy the predicate are dropped.
 For each <code>KTable</code> update, the filter is evaluated based on the current update
 record and then an update record is produced for the result <code>KTable</code>.
 This is a stateless record-by-record operation.
 <p>
 Note that <code>filter</code> for a <i>changelog stream</i> works differently than <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#filter-org.apache.kafka.streams.kstream.Predicate-"><code>record stream filters</code></a>, because <a href="../../../../../org/apache/kafka/streams/KeyValue.html" title="class in org.apache.kafka.streams"><code>records</code></a> with <code>null</code> values (so-called tombstone records)
 have delete semantics.
 Thus, for tombstones the provided filter predicate is not evaluated but the tombstone record is forwarded
 directly if required (i.e., if there is anything to be deleted).
 Furthermore, for each record that gets dropped (i.e., does not satisfy the given predicate) a tombstone record
 is forwarded.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>predicate</code> - a filter <a href="../../../../../org/apache/kafka/streams/kstream/Predicate.html" title="interface in org.apache.kafka.streams.kstream"><code>Predicate</code></a> that is applied to each record</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a <code>KTable</code> that contains only those records that satisfy the given predicate</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#filterNot-org.apache.kafka.streams.kstream.Predicate-"><code>filterNot(Predicate)</code></a></dd>
</dl>
</li>
</ul>
<a name="filter-org.apache.kafka.streams.kstream.Predicate-org.apache.kafka.streams.kstream.Materialized-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>filter</h4>
<pre><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>&gt;&nbsp;filter&#8203;(<a href="../../../../../org/apache/kafka/streams/kstream/Predicate.html" title="interface in org.apache.kafka.streams.kstream">Predicate</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,? super <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>&gt;&nbsp;predicate,
                   <a href="../../../../../org/apache/kafka/streams/kstream/Materialized.html" title="class in org.apache.kafka.streams.kstream">Materialized</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>,<a href="../../../../../org/apache/kafka/streams/state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state">KeyValueStore</a>&lt;org.apache.kafka.common.utils.Bytes,byte[]&gt;&gt;&nbsp;materialized)</pre>
<div class="block">Create a new <code>KTable</code> that consists of all records of this <code>KTable</code> which satisfy the given
 predicate, with the <a href="../../../../../org/apache/kafka/common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization"><code>key serde</code></a>, <a href="../../../../../org/apache/kafka/common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization"><code>value serde</code></a>, and the underlying
 <a href="../../../../../org/apache/kafka/streams/state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state"><code>materialized state storage</code></a> configured in the <a href="../../../../../org/apache/kafka/streams/kstream/Materialized.html" title="class in org.apache.kafka.streams.kstream"><code>Materialized</code></a> instance.
 All records that do not satisfy the predicate are dropped.
 For each <code>KTable</code> update, the filter is evaluated based on the current update
 record and then an update record is produced for the result <code>KTable</code>.
 This is a stateless record-by-record operation.
 <p>
 Note that <code>filter</code> for a <i>changelog stream</i> works differently than <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#filter-org.apache.kafka.streams.kstream.Predicate-"><code>record stream filters</code></a>, because <a href="../../../../../org/apache/kafka/streams/KeyValue.html" title="class in org.apache.kafka.streams"><code>records</code></a> with <code>null</code> values (so-called tombstone records)
 have delete semantics.
 Thus, for tombstones the provided filter predicate is not evaluated but the tombstone record is forwarded
 directly if required (i.e., if there is anything to be deleted).
 Furthermore, for each record that gets dropped (i.e., does not satisfy the given predicate) a tombstone record
 is forwarded.
 <p>
 To query the local <a href="../../../../../org/apache/kafka/streams/state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state"><code>KeyValueStore</code></a> it must be obtained via
 <a href="../../../../../org/apache/kafka/streams/KafkaStreams.html#store-java.lang.String-org.apache.kafka.streams.state.QueryableStoreType-"><code>KafkaStreams#store(...)</code></a>:
 <pre><code>
 KafkaStreams streams = ... // filtering words
 ReadOnlyKeyValueStore&lt;K,V&gt; localStore = streams.store(queryableStoreName, QueryableStoreTypes.&lt;K, V&gt;keyValueStore());
 K key = "some-word";
 V valueForKey = localStore.get(key); // key must be local (application state is shared over all running Kafka Streams instances)
 </code></pre>
 For non-local keys, a custom RPC mechanism must be implemented using <a href="../../../../../org/apache/kafka/streams/KafkaStreams.html#allMetadata--"><code>KafkaStreams.allMetadata()</code></a> to
 query the value of the key on a parallel running instance of your Kafka Streams application.
 The store name to query with is specified by <a href="../../../../../org/apache/kafka/streams/kstream/Materialized.html#as-java.lang.String-"><code>Materialized.as(String)</code></a> or <a href="../../../../../org/apache/kafka/streams/kstream/Materialized.html#as-org.apache.kafka.streams.state.KeyValueBytesStoreSupplier-"><code>Materialized.as(KeyValueBytesStoreSupplier)</code></a>.
 <p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>predicate</code> - a filter <a href="../../../../../org/apache/kafka/streams/kstream/Predicate.html" title="interface in org.apache.kafka.streams.kstream"><code>Predicate</code></a> that is applied to each record</dd>
<dd><code>materialized</code> - a <a href="../../../../../org/apache/kafka/streams/kstream/Materialized.html" title="class in org.apache.kafka.streams.kstream"><code>Materialized</code></a> that describes how the <a href="../../../../../org/apache/kafka/streams/processor/StateStore.html" title="interface in org.apache.kafka.streams.processor"><code>StateStore</code></a> for the resulting <code>KTable</code>
                      should be materialized. Cannot be <code>null</code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a <code>KTable</code> that contains only those records that satisfy the given predicate</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#filterNot-org.apache.kafka.streams.kstream.Predicate-org.apache.kafka.streams.kstream.Materialized-"><code>filterNot(Predicate, Materialized)</code></a></dd>
</dl>
</li>
</ul>
<a name="filterNot-org.apache.kafka.streams.kstream.Predicate-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>filterNot</h4>
<pre><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>&gt;&nbsp;filterNot&#8203;(<a href="../../../../../org/apache/kafka/streams/kstream/Predicate.html" title="interface in org.apache.kafka.streams.kstream">Predicate</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,? super <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>&gt;&nbsp;predicate)</pre>
<div class="block">Create a new <code>KTable</code> that consists all records of this <code>KTable</code> which do <em>not</em> satisfy the
 given predicate, with default serializers, deserializers, and state store.
 All records that <em>do</em> satisfy the predicate are dropped.
 For each <code>KTable</code> update, the filter is evaluated based on the current update
 record and then an update record is produced for the result <code>KTable</code>.
 This is a stateless record-by-record operation.
 <p>
 Note that <code>filterNot</code> for a <i>changelog stream</i> works differently than <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#filterNot-org.apache.kafka.streams.kstream.Predicate-"><code>record stream filters</code></a>, because <a href="../../../../../org/apache/kafka/streams/KeyValue.html" title="class in org.apache.kafka.streams"><code>records</code></a> with <code>null</code> values (so-called tombstone records)
 have delete semantics.
 Thus, for tombstones the provided filter predicate is not evaluated but the tombstone record is forwarded
 directly if required (i.e., if there is anything to be deleted).
 Furthermore, for each record that gets dropped (i.e., does satisfy the given predicate) a tombstone record is
 forwarded.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>predicate</code> - a filter <a href="../../../../../org/apache/kafka/streams/kstream/Predicate.html" title="interface in org.apache.kafka.streams.kstream"><code>Predicate</code></a> that is applied to each record</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a <code>KTable</code> that contains only those records that do <em>not</em> satisfy the given predicate</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#filter-org.apache.kafka.streams.kstream.Predicate-"><code>filter(Predicate)</code></a></dd>
</dl>
</li>
</ul>
<a name="filterNot-org.apache.kafka.streams.kstream.Predicate-org.apache.kafka.streams.kstream.Materialized-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>filterNot</h4>
<pre><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>&gt;&nbsp;filterNot&#8203;(<a href="../../../../../org/apache/kafka/streams/kstream/Predicate.html" title="interface in org.apache.kafka.streams.kstream">Predicate</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,? super <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>&gt;&nbsp;predicate,
                      <a href="../../../../../org/apache/kafka/streams/kstream/Materialized.html" title="class in org.apache.kafka.streams.kstream">Materialized</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>,<a href="../../../../../org/apache/kafka/streams/state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state">KeyValueStore</a>&lt;org.apache.kafka.common.utils.Bytes,byte[]&gt;&gt;&nbsp;materialized)</pre>
<div class="block">Create a new <code>KTable</code> that consists all records of this <code>KTable</code> which do <em>not</em> satisfy the
 given predicate, with the <a href="../../../../../org/apache/kafka/common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization"><code>key serde</code></a>, <a href="../../../../../org/apache/kafka/common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization"><code>value serde</code></a>, and the underlying
 <a href="../../../../../org/apache/kafka/streams/state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state"><code>materialized state storage</code></a> configured in the <a href="../../../../../org/apache/kafka/streams/kstream/Materialized.html" title="class in org.apache.kafka.streams.kstream"><code>Materialized</code></a> instance.
 All records that <em>do</em> satisfy the predicate are dropped.
 For each <code>KTable</code> update, the filter is evaluated based on the current update
 record and then an update record is produced for the result <code>KTable</code>.
 This is a stateless record-by-record operation.
 <p>
 Note that <code>filterNot</code> for a <i>changelog stream</i> works differently than <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#filterNot-org.apache.kafka.streams.kstream.Predicate-"><code>record stream filters</code></a>, because <a href="../../../../../org/apache/kafka/streams/KeyValue.html" title="class in org.apache.kafka.streams"><code>records</code></a> with <code>null</code> values (so-called tombstone records)
 have delete semantics.
 Thus, for tombstones the provided filter predicate is not evaluated but the tombstone record is forwarded
 directly if required (i.e., if there is anything to be deleted).
 Furthermore, for each record that gets dropped (i.e., does satisfy the given predicate) a tombstone record is
 forwarded.
 <p>
 To query the local <a href="../../../../../org/apache/kafka/streams/state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state"><code>KeyValueStore</code></a> it must be obtained via
 <a href="../../../../../org/apache/kafka/streams/KafkaStreams.html#store-java.lang.String-org.apache.kafka.streams.state.QueryableStoreType-"><code>KafkaStreams#store(...)</code></a>:
 <pre><code>
 KafkaStreams streams = ... // filtering words
 ReadOnlyKeyValueStore&lt;K,V&gt; localStore = streams.store(queryableStoreName, QueryableStoreTypes.&lt;K, V&gt;keyValueStore());
 K key = "some-word";
 V valueForKey = localStore.get(key); // key must be local (application state is shared over all running Kafka Streams instances)
 </code></pre>
 For non-local keys, a custom RPC mechanism must be implemented using <a href="../../../../../org/apache/kafka/streams/KafkaStreams.html#allMetadata--"><code>KafkaStreams.allMetadata()</code></a> to
 query the value of the key on a parallel running instance of your Kafka Streams application.
 The store name to query with is specified by <a href="../../../../../org/apache/kafka/streams/kstream/Materialized.html#as-java.lang.String-"><code>Materialized.as(String)</code></a> or <a href="../../../../../org/apache/kafka/streams/kstream/Materialized.html#as-org.apache.kafka.streams.state.KeyValueBytesStoreSupplier-"><code>Materialized.as(KeyValueBytesStoreSupplier)</code></a>.
 <p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>predicate</code> - a filter <a href="../../../../../org/apache/kafka/streams/kstream/Predicate.html" title="interface in org.apache.kafka.streams.kstream"><code>Predicate</code></a> that is applied to each record</dd>
<dd><code>materialized</code> - a <a href="../../../../../org/apache/kafka/streams/kstream/Materialized.html" title="class in org.apache.kafka.streams.kstream"><code>Materialized</code></a> that describes how the <a href="../../../../../org/apache/kafka/streams/processor/StateStore.html" title="interface in org.apache.kafka.streams.processor"><code>StateStore</code></a> for the resulting <code>KTable</code>
                      should be materialized. Cannot be <code>null</code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a <code>KTable</code> that contains only those records that do <em>not</em> satisfy the given predicate</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#filter-org.apache.kafka.streams.kstream.Predicate-org.apache.kafka.streams.kstream.Materialized-"><code>filter(Predicate, Materialized)</code></a></dd>
</dl>
</li>
</ul>
<a name="mapValues-org.apache.kafka.streams.kstream.ValueMapper-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>mapValues</h4>
<pre>&lt;VR&gt;&nbsp;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,VR&gt;&nbsp;mapValues&#8203;(<a href="../../../../../org/apache/kafka/streams/kstream/ValueMapper.html" title="interface in org.apache.kafka.streams.kstream">ValueMapper</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>,? extends VR&gt;&nbsp;mapper)</pre>
<div class="block">Create a new <code>KTable</code> by transforming the value of each record in this <code>KTable</code> into a new value
 (with possibly a new type) in the new <code>KTable</code>, with default serializers, deserializers, and state store.
 For each <code>KTable</code> update the provided <a href="../../../../../org/apache/kafka/streams/kstream/ValueMapper.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueMapper</code></a> is applied to the value of the updated record and
 computes a new value for it, resulting in an updated record for the result <code>KTable</code>.
 Thus, an input record <code>&lt;K,V&gt;</code> can be transformed into an output record <code>&lt;K:V'&gt;</code>.
 This is a stateless record-by-record operation.
 <p>
 The example below counts the number of token of the value string.
 <pre><code>
 KTable&lt;String, String&gt; inputTable = builder.table("topic");
 KTable&lt;String, Integer&gt; outputTable = inputTable.mapValue(new ValueMapper&lt;String, Integer&gt; {
     Integer apply(String value) {
         return value.split(" ").length;
     }
 });
 </code></pre>
 <p>
 This operation preserves data co-location with respect to the key.
 Thus, <em>no</em> internal data redistribution is required if a key based operator (like a join) is applied to
 the result <code>KTable</code>.
 <p>
 Note that <code>mapValues</code> for a <i>changelog stream</i> works differently than <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#mapValues-org.apache.kafka.streams.kstream.ValueMapper-"><code>record stream filters</code></a>, because <a href="../../../../../org/apache/kafka/streams/KeyValue.html" title="class in org.apache.kafka.streams"><code>records</code></a> with <code>null</code> values (so-called tombstone records)
 have delete semantics.
 Thus, for tombstones the provided value-mapper is not evaluated but the tombstone record is forwarded directly to
 delete the corresponding record in the result <code>KTable</code>.</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>VR</code> - the value type of the result <code>KTable</code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>mapper</code> - a <a href="../../../../../org/apache/kafka/streams/kstream/ValueMapper.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueMapper</code></a> that computes a new output value</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a <code>KTable</code> that contains records with unmodified keys and new values (possibly of different type)</dd>
</dl>
</li>
</ul>
<a name="mapValues-org.apache.kafka.streams.kstream.ValueMapperWithKey-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>mapValues</h4>
<pre>&lt;VR&gt;&nbsp;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,VR&gt;&nbsp;mapValues&#8203;(<a href="../../../../../org/apache/kafka/streams/kstream/ValueMapperWithKey.html" title="interface in org.apache.kafka.streams.kstream">ValueMapperWithKey</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,? super <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>,? extends VR&gt;&nbsp;mapper)</pre>
<div class="block">Create a new <code>KTable</code> by transforming the value of each record in this <code>KTable</code> into a new value
 (with possibly a new type) in the new <code>KTable</code>, with default serializers, deserializers, and state store.
 For each <code>KTable</code> update the provided <a href="../../../../../org/apache/kafka/streams/kstream/ValueMapperWithKey.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueMapperWithKey</code></a> is applied to the value of the update
 record and computes a new value for it, resulting in an updated record for the result <code>KTable</code>.
 Thus, an input record <code>&lt;K,V&gt;</code> can be transformed into an output record <code>&lt;K:V'&gt;</code>.
 This is a stateless record-by-record operation.
 <p>
 The example below counts the number of token of value and key strings.
 <pre><code>
 KTable&lt;String, String&gt; inputTable = builder.table("topic");
 KTable&lt;String, Integer&gt; outputTable = inputTable.mapValue(new ValueMapperWithKey&lt;String, String, Integer&gt; {
     Integer apply(String readOnlyKey, String value) {
          return readOnlyKey.split(" ").length + value.split(" ").length;
     }
 });
 </code></pre>
 <p>
 Note that the key is read-only and should not be modified, as this can lead to corrupt partitioning.
 This operation preserves data co-location with respect to the key.
 Thus, <em>no</em> internal data redistribution is required if a key based operator (like a join) is applied to
 the result <code>KTable</code>.
 <p>
 Note that <code>mapValues</code> for a <i>changelog stream</i> works differently than <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#mapValues-org.apache.kafka.streams.kstream.ValueMapperWithKey-"><code>record stream filters</code></a>, because <a href="../../../../../org/apache/kafka/streams/KeyValue.html" title="class in org.apache.kafka.streams"><code>records</code></a> with <code>null</code> values (so-called tombstone records)
 have delete semantics.
 Thus, for tombstones the provided value-mapper is not evaluated but the tombstone record is forwarded directly to
 delete the corresponding record in the result <code>KTable</code>.</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>VR</code> - the value type of the result <code>KTable</code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>mapper</code> - a <a href="../../../../../org/apache/kafka/streams/kstream/ValueMapperWithKey.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueMapperWithKey</code></a> that computes a new output value</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a <code>KTable</code> that contains records with unmodified keys and new values (possibly of different type)</dd>
</dl>
</li>
</ul>
<a name="mapValues-org.apache.kafka.streams.kstream.ValueMapper-org.apache.kafka.streams.kstream.Materialized-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>mapValues</h4>
<pre>&lt;VR&gt;&nbsp;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,VR&gt;&nbsp;mapValues&#8203;(<a href="../../../../../org/apache/kafka/streams/kstream/ValueMapper.html" title="interface in org.apache.kafka.streams.kstream">ValueMapper</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>,? extends VR&gt;&nbsp;mapper,
                            <a href="../../../../../org/apache/kafka/streams/kstream/Materialized.html" title="class in org.apache.kafka.streams.kstream">Materialized</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,VR,<a href="../../../../../org/apache/kafka/streams/state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state">KeyValueStore</a>&lt;org.apache.kafka.common.utils.Bytes,byte[]&gt;&gt;&nbsp;materialized)</pre>
<div class="block">Create a new <code>KTable</code> by transforming the value of each record in this <code>KTable</code> into a new value
 (with possibly a new type) in the new <code>KTable</code>, with the <a href="../../../../../org/apache/kafka/common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization"><code>key serde</code></a>, <a href="../../../../../org/apache/kafka/common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization"><code>value serde</code></a>,
 and the underlying <a href="../../../../../org/apache/kafka/streams/state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state"><code>materialized state storage</code></a> configured in the <a href="../../../../../org/apache/kafka/streams/kstream/Materialized.html" title="class in org.apache.kafka.streams.kstream"><code>Materialized</code></a>
 instance.
 For each <code>KTable</code> update the provided <a href="../../../../../org/apache/kafka/streams/kstream/ValueMapper.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueMapper</code></a> is applied to the value of the updated record and
 computes a new value for it, resulting in an updated record for the result <code>KTable</code>.
 Thus, an input record <code>&lt;K,V&gt;</code> can be transformed into an output record <code>&lt;K:V'&gt;</code>.
 This is a stateless record-by-record operation.
 <p>
 The example below counts the number of token of the value string.
 <pre><code>
 KTable&lt;String, String&gt; inputTable = builder.table("topic");
 KTable&lt;String, Integer&gt; outputTable = inputTable.mapValue(new ValueMapper&lt;String, Integer&gt; {
     Integer apply(String value) {
         return value.split(" ").length;
     }
 });
 </code></pre>
 <p>
 To query the local <a href="../../../../../org/apache/kafka/streams/state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state"><code>KeyValueStore</code></a> representing outputTable above it must be obtained via
 <a href="../../../../../org/apache/kafka/streams/KafkaStreams.html#store-java.lang.String-org.apache.kafka.streams.state.QueryableStoreType-"><code>KafkaStreams#store(...)</code></a>:
 For non-local keys, a custom RPC mechanism must be implemented using <a href="../../../../../org/apache/kafka/streams/KafkaStreams.html#allMetadata--"><code>KafkaStreams.allMetadata()</code></a> to
 query the value of the key on a parallel running instance of your Kafka Streams application.
 The store name to query with is specified by <a href="../../../../../org/apache/kafka/streams/kstream/Materialized.html#as-java.lang.String-"><code>Materialized.as(String)</code></a> or <a href="../../../../../org/apache/kafka/streams/kstream/Materialized.html#as-org.apache.kafka.streams.state.KeyValueBytesStoreSupplier-"><code>Materialized.as(KeyValueBytesStoreSupplier)</code></a>.
 <p>
 This operation preserves data co-location with respect to the key.
 Thus, <em>no</em> internal data redistribution is required if a key based operator (like a join) is applied to
 the result <code>KTable</code>.
 <p>
 Note that <code>mapValues</code> for a <i>changelog stream</i> works differently than <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#mapValues-org.apache.kafka.streams.kstream.ValueMapper-"><code>record stream filters</code></a>, because <a href="../../../../../org/apache/kafka/streams/KeyValue.html" title="class in org.apache.kafka.streams"><code>records</code></a> with <code>null</code> values (so-called tombstone records)
 have delete semantics.
 Thus, for tombstones the provided value-mapper is not evaluated but the tombstone record is forwarded directly to
 delete the corresponding record in the result <code>KTable</code>.</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>VR</code> - the value type of the result <code>KTable</code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>mapper</code> - a <a href="../../../../../org/apache/kafka/streams/kstream/ValueMapper.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueMapper</code></a> that computes a new output value</dd>
<dd><code>materialized</code> - a <a href="../../../../../org/apache/kafka/streams/kstream/Materialized.html" title="class in org.apache.kafka.streams.kstream"><code>Materialized</code></a> that describes how the <a href="../../../../../org/apache/kafka/streams/processor/StateStore.html" title="interface in org.apache.kafka.streams.processor"><code>StateStore</code></a> for the resulting <code>KTable</code>
                      should be materialized. Cannot be <code>null</code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a <code>KTable</code> that contains records with unmodified keys and new values (possibly of different type)</dd>
</dl>
</li>
</ul>
<a name="mapValues-org.apache.kafka.streams.kstream.ValueMapperWithKey-org.apache.kafka.streams.kstream.Materialized-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>mapValues</h4>
<pre>&lt;VR&gt;&nbsp;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,VR&gt;&nbsp;mapValues&#8203;(<a href="../../../../../org/apache/kafka/streams/kstream/ValueMapperWithKey.html" title="interface in org.apache.kafka.streams.kstream">ValueMapperWithKey</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,? super <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>,? extends VR&gt;&nbsp;mapper,
                            <a href="../../../../../org/apache/kafka/streams/kstream/Materialized.html" title="class in org.apache.kafka.streams.kstream">Materialized</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,VR,<a href="../../../../../org/apache/kafka/streams/state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state">KeyValueStore</a>&lt;org.apache.kafka.common.utils.Bytes,byte[]&gt;&gt;&nbsp;materialized)</pre>
<div class="block">Create a new <code>KTable</code> by transforming the value of each record in this <code>KTable</code> into a new value
 (with possibly a new type) in the new <code>KTable</code>, with the <a href="../../../../../org/apache/kafka/common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization"><code>key serde</code></a>, <a href="../../../../../org/apache/kafka/common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization"><code>value serde</code></a>,
 and the underlying <a href="../../../../../org/apache/kafka/streams/state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state"><code>materialized state storage</code></a> configured in the <a href="../../../../../org/apache/kafka/streams/kstream/Materialized.html" title="class in org.apache.kafka.streams.kstream"><code>Materialized</code></a>
 instance.
 For each <code>KTable</code> update the provided <a href="../../../../../org/apache/kafka/streams/kstream/ValueMapperWithKey.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueMapperWithKey</code></a> is applied to the value of the update
 record and computes a new value for it, resulting in an updated record for the result <code>KTable</code>.
 Thus, an input record <code>&lt;K,V&gt;</code> can be transformed into an output record <code>&lt;K:V'&gt;</code>.
 This is a stateless record-by-record operation.
 <p>
 The example below counts the number of token of value and key strings.
 <pre><code>
 KTable&lt;String, String&gt; inputTable = builder.table("topic");
 KTable&lt;String, Integer&gt; outputTable = inputTable.mapValue(new ValueMapperWithKey&lt;String, String, Integer&gt; {
     Integer apply(String readOnlyKey, String value) {
          return readOnlyKey.split(" ").length + value.split(" ").length;
     }
 });
 </code></pre>
 <p>
 To query the local <a href="../../../../../org/apache/kafka/streams/state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state"><code>KeyValueStore</code></a> representing outputTable above it must be obtained via
 <a href="../../../../../org/apache/kafka/streams/KafkaStreams.html#store-java.lang.String-org.apache.kafka.streams.state.QueryableStoreType-"><code>KafkaStreams#store(...)</code></a>:
 For non-local keys, a custom RPC mechanism must be implemented using <a href="../../../../../org/apache/kafka/streams/KafkaStreams.html#allMetadata--"><code>KafkaStreams.allMetadata()</code></a> to
 query the value of the key on a parallel running instance of your Kafka Streams application.
 The store name to query with is specified by <a href="../../../../../org/apache/kafka/streams/kstream/Materialized.html#as-java.lang.String-"><code>Materialized.as(String)</code></a> or <a href="../../../../../org/apache/kafka/streams/kstream/Materialized.html#as-org.apache.kafka.streams.state.KeyValueBytesStoreSupplier-"><code>Materialized.as(KeyValueBytesStoreSupplier)</code></a>.
 <p>
 Note that the key is read-only and should not be modified, as this can lead to corrupt partitioning.
 This operation preserves data co-location with respect to the key.
 Thus, <em>no</em> internal data redistribution is required if a key based operator (like a join) is applied to
 the result <code>KTable</code>.
 <p>
 Note that <code>mapValues</code> for a <i>changelog stream</i> works differently than <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#mapValues-org.apache.kafka.streams.kstream.ValueMapper-"><code>record stream filters</code></a>, because <a href="../../../../../org/apache/kafka/streams/KeyValue.html" title="class in org.apache.kafka.streams"><code>records</code></a> with <code>null</code> values (so-called tombstone records)
 have delete semantics.
 Thus, for tombstones the provided value-mapper is not evaluated but the tombstone record is forwarded directly to
 delete the corresponding record in the result <code>KTable</code>.</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>VR</code> - the value type of the result <code>KTable</code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>mapper</code> - a <a href="../../../../../org/apache/kafka/streams/kstream/ValueMapperWithKey.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueMapperWithKey</code></a> that computes a new output value</dd>
<dd><code>materialized</code> - a <a href="../../../../../org/apache/kafka/streams/kstream/Materialized.html" title="class in org.apache.kafka.streams.kstream"><code>Materialized</code></a> that describes how the <a href="../../../../../org/apache/kafka/streams/processor/StateStore.html" title="interface in org.apache.kafka.streams.processor"><code>StateStore</code></a> for the resulting <code>KTable</code>
                      should be materialized. Cannot be <code>null</code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a <code>KTable</code> that contains records with unmodified keys and new values (possibly of different type)</dd>
</dl>
</li>
</ul>
<a name="toStream--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>toStream</h4>
<pre><a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="interface in org.apache.kafka.streams.kstream">KStream</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>&gt;&nbsp;toStream&#8203;()</pre>
<div class="block">Convert this changelog stream to a <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="interface in org.apache.kafka.streams.kstream"><code>KStream</code></a>.
 <p>
 Note that this is a logical operation and only changes the "interpretation" of the stream, i.e., each record of
 this changelog stream is no longer treated as an updated record (cf. <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="interface in org.apache.kafka.streams.kstream"><code>KStream</code></a> vs <code>KTable</code>).</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="interface in org.apache.kafka.streams.kstream"><code>KStream</code></a> that contains the same records as this <code>KTable</code></dd>
</dl>
</li>
</ul>
<a name="toStream-org.apache.kafka.streams.kstream.KeyValueMapper-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>toStream</h4>
<pre>&lt;KR&gt;&nbsp;<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="interface in org.apache.kafka.streams.kstream">KStream</a>&lt;KR,<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>&gt;&nbsp;toStream&#8203;(<a href="../../../../../org/apache/kafka/streams/kstream/KeyValueMapper.html" title="interface in org.apache.kafka.streams.kstream">KeyValueMapper</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,? super <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>,? extends KR&gt;&nbsp;mapper)</pre>
<div class="block">Convert this changelog stream to a <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="interface in org.apache.kafka.streams.kstream"><code>KStream</code></a> using the given <a href="../../../../../org/apache/kafka/streams/kstream/KeyValueMapper.html" title="interface in org.apache.kafka.streams.kstream"><code>KeyValueMapper</code></a> to select the new key.
 <p>
 For example, you can compute the new key as the length of the value string.
 <pre><code>
 KTable&lt;String, String&gt; table = builder.table("topic");
 KTable&lt;Integer, String&gt; keyedStream = table.toStream(new KeyValueMapper&lt;String, String, Integer&gt; {
     Integer apply(String key, String value) {
         return value.length();
     }
 });
 </code></pre>
 Setting a new key might result in an internal data redistribution if a key based operator (like an aggregation or
 join) is applied to the result <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="interface in org.apache.kafka.streams.kstream"><code>KStream</code></a>.
 <p>
 This operation is equivalent to calling
 <code>table.</code><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#toStream--"><code>toStream</code></a><code>().</code><a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#selectKey-org.apache.kafka.streams.kstream.KeyValueMapper-"><code>selectKey(KeyValueMapper)</code></a>.
 <p>
 Note that <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#toStream--"><code>toStream()</code></a> is a logical operation and only changes the "interpretation" of the stream, i.e.,
 each record of this changelog stream is no longer treated as an updated record (cf. <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="interface in org.apache.kafka.streams.kstream"><code>KStream</code></a> vs <code>KTable</code>).</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>KR</code> - the new key type of the result stream</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>mapper</code> - a <a href="../../../../../org/apache/kafka/streams/kstream/KeyValueMapper.html" title="interface in org.apache.kafka.streams.kstream"><code>KeyValueMapper</code></a> that computes a new key for each record</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="interface in org.apache.kafka.streams.kstream"><code>KStream</code></a> that contains the same records as this <code>KTable</code></dd>
</dl>
</li>
</ul>
<a name="transformValues-org.apache.kafka.streams.kstream.ValueTransformerWithKeySupplier-java.lang.String...-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>transformValues</h4>
<pre>&lt;VR&gt;&nbsp;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,VR&gt;&nbsp;transformValues&#8203;(<a href="../../../../../org/apache/kafka/streams/kstream/ValueTransformerWithKeySupplier.html" title="interface in org.apache.kafka.streams.kstream">ValueTransformerWithKeySupplier</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,? super <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>,? extends VR&gt;&nbsp;transformerSupplier,
                                  java.lang.String...&nbsp;stateStoreNames)</pre>
<div class="block">Create a new <code>KTable</code> by transforming the value of each record in this <code>KTable</code> into a new value
 (with possibly a new type), with default serializers, deserializers, and state store.
 A <a href="../../../../../org/apache/kafka/streams/kstream/ValueTransformerWithKey.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueTransformerWithKey</code></a> (provided by the given <a href="../../../../../org/apache/kafka/streams/kstream/ValueTransformerWithKeySupplier.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueTransformerWithKeySupplier</code></a>) is applied to each input
 record value and computes a new value for it.
 Thus, an input record <code>&lt;K,V&gt;</code> can be transformed into an output record <code>&lt;K:V'&gt;</code>.
 This is similar to <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#mapValues-org.apache.kafka.streams.kstream.ValueMapperWithKey-"><code>mapValues(ValueMapperWithKey)</code></a>, but more flexible, allowing access to additional state-stores,
 and access to the <a href="../../../../../org/apache/kafka/streams/processor/ProcessorContext.html" title="interface in org.apache.kafka.streams.processor"><code>ProcessorContext</code></a>.
 Furthermore, via <a href="../../../../../org/apache/kafka/streams/processor/Punctuator.html#punctuate-long-"><code>Punctuator.punctuate(long)</code></a> the processing progress can be observed and additional
 periodic actions can be performed.
 <p>
 If the downstream topology uses aggregation functions, (e.g. <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html#reduce-org.apache.kafka.streams.kstream.Reducer-org.apache.kafka.streams.kstream.Reducer-org.apache.kafka.streams.kstream.Materialized-"><code>KGroupedTable.reduce(org.apache.kafka.streams.kstream.Reducer&lt;V&gt;, org.apache.kafka.streams.kstream.Reducer&lt;V&gt;, org.apache.kafka.streams.kstream.Materialized&lt;K, V, org.apache.kafka.streams.state.KeyValueStore&lt;org.apache.kafka.common.utils.Bytes, byte[]&gt;&gt;)</code></a>, <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html#aggregate-org.apache.kafka.streams.kstream.Initializer-org.apache.kafka.streams.kstream.Aggregator-org.apache.kafka.streams.kstream.Aggregator-org.apache.kafka.streams.kstream.Materialized-"><code>KGroupedTable.aggregate(org.apache.kafka.streams.kstream.Initializer&lt;VR&gt;, org.apache.kafka.streams.kstream.Aggregator&lt;? super K, ? super V, VR&gt;, org.apache.kafka.streams.kstream.Aggregator&lt;? super K, ? super V, VR&gt;, org.apache.kafka.streams.kstream.Materialized&lt;K, VR, org.apache.kafka.streams.state.KeyValueStore&lt;org.apache.kafka.common.utils.Bytes, byte[]&gt;&gt;)</code></a>, etc),
 care must be taken when dealing with state, (either held in state-stores or transformer instances), to ensure correct aggregate results.
 In contrast, if the resulting KTable is materialized, (cf. <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#transformValues-org.apache.kafka.streams.kstream.ValueTransformerWithKeySupplier-org.apache.kafka.streams.kstream.Materialized-java.lang.String...-"><code>transformValues(ValueTransformerWithKeySupplier, Materialized, String...)</code></a>),
 such concerns are handled for you.
 <p>
 In order to assign a state, the state must be created and registered beforehand:
 <pre><code>
 // create store
 StoreBuilder&lt;KeyValueStore&lt;String,String&gt;&gt; keyValueStoreBuilder =
         Stores.keyValueStoreBuilder(Stores.persistentKeyValueStore("myValueTransformState"),
                 Serdes.String(),
                 Serdes.String());
 // register store
 builder.addStateStore(keyValueStoreBuilder);

 KTable outputTable = inputTable.transformValues(new ValueTransformerWithKeySupplier() { ... }, "myValueTransformState");
 </code></pre>
 <p>
 Within the <a href="../../../../../org/apache/kafka/streams/kstream/ValueTransformerWithKey.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueTransformerWithKey</code></a>, the state is obtained via the
 <a href="../../../../../org/apache/kafka/streams/processor/ProcessorContext.html" title="interface in org.apache.kafka.streams.processor"><code>ProcessorContext</code></a>.
 To trigger periodic actions via <a href="../../../../../org/apache/kafka/streams/processor/Punctuator.html#punctuate-long-"><code>punctuate()</code></a>,
 a schedule must be registered.
 <pre><code>
 new ValueTransformerWithKeySupplier() {
     ValueTransformerWithKey get() {
         return new ValueTransformerWithKey() {
             private KeyValueStore&lt;String, String&gt; state;

             void init(ProcessorContext context) {
                 this.state = (KeyValueStore&lt;String, String&gt;)context.getStateStore("myValueTransformState");
                 context.schedule(1000, PunctuationType.WALL_CLOCK_TIME, new Punctuator(..)); // punctuate each 1000ms, can access this.state
             }

             NewValueType transform(K readOnlyKey, V value) {
                 // can access this.state and use read-only key
                 return new NewValueType(readOnlyKey); // or null
             }

             void close() {
                 // can access this.state
             }
         }
     }
 }
 </code></pre>
 <p>
 Note that the key is read-only and should not be modified, as this can lead to corrupt partitioning.
 Setting a new value preserves data co-location with respect to the key.</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>VR</code> - the value type of the result table</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>transformerSupplier</code> - a instance of <a href="../../../../../org/apache/kafka/streams/kstream/ValueTransformerWithKeySupplier.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueTransformerWithKeySupplier</code></a> that generates a
                            <a href="../../../../../org/apache/kafka/streams/kstream/ValueTransformerWithKey.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueTransformerWithKey</code></a>.
                            At least one transformer instance will be created per streaming task.
                            Transformers do not need to be thread-safe.</dd>
<dd><code>stateStoreNames</code> - the names of the state stores used by the processor</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a <code>KTable</code> that contains records with unmodified key and new values (possibly of different type)</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#mapValues-org.apache.kafka.streams.kstream.ValueMapper-"><code>mapValues(ValueMapper)</code></a>, 
<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#mapValues-org.apache.kafka.streams.kstream.ValueMapperWithKey-"><code>mapValues(ValueMapperWithKey)</code></a></dd>
</dl>
</li>
</ul>
<a name="transformValues-org.apache.kafka.streams.kstream.ValueTransformerWithKeySupplier-org.apache.kafka.streams.kstream.Materialized-java.lang.String...-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>transformValues</h4>
<pre>&lt;VR&gt;&nbsp;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,VR&gt;&nbsp;transformValues&#8203;(<a href="../../../../../org/apache/kafka/streams/kstream/ValueTransformerWithKeySupplier.html" title="interface in org.apache.kafka.streams.kstream">ValueTransformerWithKeySupplier</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,? super <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>,? extends VR&gt;&nbsp;transformerSupplier,
                                  <a href="../../../../../org/apache/kafka/streams/kstream/Materialized.html" title="class in org.apache.kafka.streams.kstream">Materialized</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,VR,<a href="../../../../../org/apache/kafka/streams/state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state">KeyValueStore</a>&lt;org.apache.kafka.common.utils.Bytes,byte[]&gt;&gt;&nbsp;materialized,
                                  java.lang.String...&nbsp;stateStoreNames)</pre>
<div class="block">Create a new <code>KTable</code> by transforming the value of each record in this <code>KTable</code> into a new value
 (with possibly a new type), with the <a href="../../../../../org/apache/kafka/common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization"><code>key serde</code></a>, <a href="../../../../../org/apache/kafka/common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization"><code>value serde</code></a>, and the underlying
 <a href="../../../../../org/apache/kafka/streams/state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state"><code>materialized state storage</code></a> configured in the <a href="../../../../../org/apache/kafka/streams/kstream/Materialized.html" title="class in org.apache.kafka.streams.kstream"><code>Materialized</code></a> instance.
 A <a href="../../../../../org/apache/kafka/streams/kstream/ValueTransformerWithKey.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueTransformerWithKey</code></a> (provided by the given <a href="../../../../../org/apache/kafka/streams/kstream/ValueTransformerWithKeySupplier.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueTransformerWithKeySupplier</code></a>) is applied to each input
 record value and computes a new value for it.
 This is similar to <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#mapValues-org.apache.kafka.streams.kstream.ValueMapperWithKey-"><code>mapValues(ValueMapperWithKey)</code></a>, but more flexible, allowing stateful, rather than stateless,
 record-by-record operation, access to additional state-stores, and access to the <a href="../../../../../org/apache/kafka/streams/processor/ProcessorContext.html" title="interface in org.apache.kafka.streams.processor"><code>ProcessorContext</code></a>.
 Furthermore, via <a href="../../../../../org/apache/kafka/streams/processor/Punctuator.html#punctuate-long-"><code>Punctuator.punctuate(long)</code></a> the processing progress can be observed and additional
 periodic actions can be performed.
 The resulting <code>KTable</code> is materialized into another state store (additional to the provided state store names)
 as specified by the user via <a href="../../../../../org/apache/kafka/streams/kstream/Materialized.html" title="class in org.apache.kafka.streams.kstream"><code>Materialized</code></a> parameter, and is queryable through its given name.
 <p>
 In order to assign a state, the state must be created and registered beforehand:
 <pre><code>
 // create store
 StoreBuilder&lt;KeyValueStore&lt;String,String&gt;&gt; keyValueStoreBuilder =
         Stores.keyValueStoreBuilder(Stores.persistentKeyValueStore("myValueTransformState"),
                 Serdes.String(),
                 Serdes.String());
 // register store
 builder.addStateStore(keyValueStoreBuilder);

 KTable outputTable = inputTable.transformValues(
     new ValueTransformerWithKeySupplier() { ... },
     Materialized.&lt;String, String, KeyValueStore&lt;Bytes, byte[]&gt;&gt;as("outputTable")
                                 .withKeySerde(Serdes.String())
                                 .withValueSerde(Serdes.String()),
     "myValueTransformState");
 </code></pre>
 <p>
 Within the <a href="../../../../../org/apache/kafka/streams/kstream/ValueTransformerWithKey.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueTransformerWithKey</code></a>, the state is obtained via the
 <a href="../../../../../org/apache/kafka/streams/processor/ProcessorContext.html" title="interface in org.apache.kafka.streams.processor"><code>ProcessorContext</code></a>.
 To trigger periodic actions via <a href="../../../../../org/apache/kafka/streams/processor/Punctuator.html#punctuate-long-"><code>punctuate()</code></a>,
 a schedule must be registered.
 <pre><code>
 new ValueTransformerWithKeySupplier() {
     ValueTransformerWithKey get() {
         return new ValueTransformerWithKey() {
             private KeyValueStore&lt;String, String&gt; state;

             void init(ProcessorContext context) {
                 this.state = (KeyValueStore&lt;String, String&gt;)context.getStateStore("myValueTransformState");
                 context.schedule(1000, PunctuationType.WALL_CLOCK_TIME, new Punctuator(..)); // punctuate each 1000ms, can access this.state
             }

             NewValueType transform(K readOnlyKey, V value) {
                 // can access this.state and use read-only key
                 return new NewValueType(readOnlyKey); // or null
             }

             void close() {
                 // can access this.state
             }
         }
     }
 }
 </code></pre>
 <p>
 Note that the key is read-only and should not be modified, as this can lead to corrupt partitioning.
 Setting a new value preserves data co-location with respect to the key.</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>VR</code> - the value type of the result table</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>transformerSupplier</code> - a instance of <a href="../../../../../org/apache/kafka/streams/kstream/ValueTransformerWithKeySupplier.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueTransformerWithKeySupplier</code></a> that generates a
                            <a href="../../../../../org/apache/kafka/streams/kstream/ValueTransformerWithKey.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueTransformerWithKey</code></a>.
                            At least one transformer instance will be created per streaming task.
                            Transformers do not need to be thread-safe.</dd>
<dd><code>materialized</code> - an instance of <a href="../../../../../org/apache/kafka/streams/kstream/Materialized.html" title="class in org.apache.kafka.streams.kstream"><code>Materialized</code></a> used to describe how the state store of the
                            resulting table should be materialized.
                            Cannot be <code>null</code></dd>
<dd><code>stateStoreNames</code> - the names of the state stores used by the processor</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a <code>KTable</code> that contains records with unmodified key and new values (possibly of different type)</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#mapValues-org.apache.kafka.streams.kstream.ValueMapper-"><code>mapValues(ValueMapper)</code></a>, 
<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#mapValues-org.apache.kafka.streams.kstream.ValueMapperWithKey-"><code>mapValues(ValueMapperWithKey)</code></a></dd>
</dl>
</li>
</ul>
<a name="groupBy-org.apache.kafka.streams.kstream.KeyValueMapper-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>groupBy</h4>
<pre>&lt;KR,VR&gt;&nbsp;<a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html" title="interface in org.apache.kafka.streams.kstream">KGroupedTable</a>&lt;KR,VR&gt;&nbsp;groupBy&#8203;(<a href="../../../../../org/apache/kafka/streams/kstream/KeyValueMapper.html" title="interface in org.apache.kafka.streams.kstream">KeyValueMapper</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,? super <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>,<a href="../../../../../org/apache/kafka/streams/KeyValue.html" title="class in org.apache.kafka.streams">KeyValue</a>&lt;KR,VR&gt;&gt;&nbsp;selector)</pre>
<div class="block">Re-groups the records of this <code>KTable</code> using the provided <a href="../../../../../org/apache/kafka/streams/kstream/KeyValueMapper.html" title="interface in org.apache.kafka.streams.kstream"><code>KeyValueMapper</code></a> and default serializers
 and deserializers.
 Each <a href="../../../../../org/apache/kafka/streams/KeyValue.html" title="class in org.apache.kafka.streams"><code>KeyValue</code></a> pair of this <code>KTable</code> is mapped to a new <a href="../../../../../org/apache/kafka/streams/KeyValue.html" title="class in org.apache.kafka.streams"><code>KeyValue</code></a> pair by applying the
 provided <a href="../../../../../org/apache/kafka/streams/kstream/KeyValueMapper.html" title="interface in org.apache.kafka.streams.kstream"><code>KeyValueMapper</code></a>.
 Re-grouping a <code>KTable</code> is required before an aggregation operator can be applied to the data
 (cf. <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KGroupedTable</code></a>).
 The <a href="../../../../../org/apache/kafka/streams/kstream/KeyValueMapper.html" title="interface in org.apache.kafka.streams.kstream"><code>KeyValueMapper</code></a> selects a new key and value (with should both have unmodified type).
 If the new record key is <code>null</code> the record will not be included in the resulting <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KGroupedTable</code></a>
 <p>
 Because a new key is selected, an internal repartitioning topic will be created in Kafka.
 This topic will be named "${applicationId}-XXX-repartition", where "applicationId" is user-specified in
 <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html" title="class in org.apache.kafka.streams"><code>StreamsConfig</code></a> via parameter <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html#APPLICATION_ID_CONFIG"><code>APPLICATION_ID_CONFIG</code></a>, "XXX" is
 an internally generated name, and "-repartition" is a fixed suffix.

 You can retrieve all generated internal topic names via <a href="../../../../../org/apache/kafka/streams/Topology.html#describe--"><code>Topology.describe()</code></a>.

 <p>
 All data of this <code>KTable</code> will be redistributed through the repartitioning topic by writing all update
 records to and rereading all updated records from it, such that the resulting <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KGroupedTable</code></a> is partitioned
 on the new key.
 <p>
 If the key or value type is changed, it is recommended to use <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#groupBy-org.apache.kafka.streams.kstream.KeyValueMapper-org.apache.kafka.streams.kstream.Serialized-"><code>groupBy(KeyValueMapper, Serialized)</code></a>
 instead.</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>KR</code> - the key type of the result <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KGroupedTable</code></a></dd>
<dd><code>VR</code> - the value type of the result <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KGroupedTable</code></a></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>selector</code> - a <a href="../../../../../org/apache/kafka/streams/kstream/KeyValueMapper.html" title="interface in org.apache.kafka.streams.kstream"><code>KeyValueMapper</code></a> that computes a new grouping key and value to be aggregated</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KGroupedTable</code></a> that contains the re-grouped records of the original <code>KTable</code></dd>
</dl>
</li>
</ul>
<a name="groupBy-org.apache.kafka.streams.kstream.KeyValueMapper-org.apache.kafka.streams.kstream.Serialized-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>groupBy</h4>
<pre>&lt;KR,VR&gt;&nbsp;<a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html" title="interface in org.apache.kafka.streams.kstream">KGroupedTable</a>&lt;KR,VR&gt;&nbsp;groupBy&#8203;(<a href="../../../../../org/apache/kafka/streams/kstream/KeyValueMapper.html" title="interface in org.apache.kafka.streams.kstream">KeyValueMapper</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,? super <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>,<a href="../../../../../org/apache/kafka/streams/KeyValue.html" title="class in org.apache.kafka.streams">KeyValue</a>&lt;KR,VR&gt;&gt;&nbsp;selector,
                                     <a href="../../../../../org/apache/kafka/streams/kstream/Serialized.html" title="class in org.apache.kafka.streams.kstream">Serialized</a>&lt;KR,VR&gt;&nbsp;serialized)</pre>
<div class="block">Re-groups the records of this <code>KTable</code> using the provided <a href="../../../../../org/apache/kafka/streams/kstream/KeyValueMapper.html" title="interface in org.apache.kafka.streams.kstream"><code>KeyValueMapper</code></a>
 and <a href="../../../../../org/apache/kafka/common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization"><code>Serde</code></a>s as specified by <a href="../../../../../org/apache/kafka/streams/kstream/Serialized.html" title="class in org.apache.kafka.streams.kstream"><code>Serialized</code></a>.
 Each <a href="../../../../../org/apache/kafka/streams/KeyValue.html" title="class in org.apache.kafka.streams"><code>KeyValue</code></a> pair of this <code>KTable</code> is mapped to a new <a href="../../../../../org/apache/kafka/streams/KeyValue.html" title="class in org.apache.kafka.streams"><code>KeyValue</code></a> pair by applying the
 provided <a href="../../../../../org/apache/kafka/streams/kstream/KeyValueMapper.html" title="interface in org.apache.kafka.streams.kstream"><code>KeyValueMapper</code></a>.
 Re-grouping a <code>KTable</code> is required before an aggregation operator can be applied to the data
 (cf. <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KGroupedTable</code></a>).
 The <a href="../../../../../org/apache/kafka/streams/kstream/KeyValueMapper.html" title="interface in org.apache.kafka.streams.kstream"><code>KeyValueMapper</code></a> selects a new key and value (with should both have unmodified type).
 If the new record key is <code>null</code> the record will not be included in the resulting <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KGroupedTable</code></a>
 <p>
 Because a new key is selected, an internal repartitioning topic will be created in Kafka.
 This topic will be named "${applicationId}-XXX-repartition", where "applicationId" is user-specified in
 <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html" title="class in org.apache.kafka.streams"><code>StreamsConfig</code></a> via parameter <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html#APPLICATION_ID_CONFIG"><code>APPLICATION_ID_CONFIG</code></a>, "XXX" is
 an internally generated name, and "-repartition" is a fixed suffix.

 You can retrieve all generated internal topic names via <a href="../../../../../org/apache/kafka/streams/Topology.html#describe--"><code>Topology.describe()</code></a>.

 <p>
 All data of this <code>KTable</code> will be redistributed through the repartitioning topic by writing all update
 records to and rereading all updated records from it, such that the resulting <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KGroupedTable</code></a> is partitioned
 on the new key.</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>KR</code> - the key type of the result <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KGroupedTable</code></a></dd>
<dd><code>VR</code> - the value type of the result <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KGroupedTable</code></a></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>selector</code> - a <a href="../../../../../org/apache/kafka/streams/kstream/KeyValueMapper.html" title="interface in org.apache.kafka.streams.kstream"><code>KeyValueMapper</code></a> that computes a new grouping key and value to be aggregated</dd>
<dd><code>serialized</code> - the <a href="../../../../../org/apache/kafka/streams/kstream/Serialized.html" title="class in org.apache.kafka.streams.kstream"><code>Serialized</code></a> instance used to specify <a href="../../../../../org/apache/kafka/common/serialization/Serdes.html" title="class in org.apache.kafka.common.serialization"><code>Serdes</code></a></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KGroupedTable</code></a> that contains the re-grouped records of the original <code>KTable</code></dd>
</dl>
</li>
</ul>
<a name="join-org.apache.kafka.streams.kstream.KTable-org.apache.kafka.streams.kstream.ValueJoiner-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>join</h4>
<pre>&lt;VO,VR&gt;&nbsp;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,VR&gt;&nbsp;join&#8203;(<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,VO&gt;&nbsp;other,
                          <a href="../../../../../org/apache/kafka/streams/kstream/ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream">ValueJoiner</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>,? super VO,? extends VR&gt;&nbsp;joiner)</pre>
<div class="block">Join records of this <code>KTable</code> with another <code>KTable</code>'s records using non-windowed inner equi join,
 with default serializers, deserializers, and state store.
 The join is a primary key join with join attribute <code>thisKTable.key == otherKTable.key</code>.
 The result is an ever updating <code>KTable</code> that represents the <em>current</em> (i.e., processing time) result
 of the join.
 <p>
 The join is computed by (1) updating the internal state of one <code>KTable</code> and (2) performing a lookup for a
 matching record in the <em>current</em> (i.e., processing time) internal state of the other <code>KTable</code>.
 This happens in a symmetric way, i.e., for each update of either <code>this</code> or the <code>other</code> input
 <code>KTable</code> the result gets updated.
 <p>
 For each <code>KTable</code> record that finds a corresponding record in the other <code>KTable</code> the provided
 <a href="../../../../../org/apache/kafka/streams/kstream/ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueJoiner</code></a> will be called to compute a value (with arbitrary type) for the result record.
 The key of the result record is the same as for both joining input records.
 <p>
 Note that <a href="../../../../../org/apache/kafka/streams/KeyValue.html" title="class in org.apache.kafka.streams"><code>records</code></a> with <code>null</code> values (so-called tombstone records) have delete semantics.
 Thus, for input tombstones the provided value-joiner is not called but a tombstone record is forwarded
 directly to delete a record in the result <code>KTable</code> if required (i.e., if there is anything to be deleted).
 <p>
 Input records with <code>null</code> key will be dropped and no join computation is performed.
 <p>
 Example:
 <table border='1'>
 <tr>
 <th>thisKTable</th>
 <th>thisState</th>
 <th>otherKTable</th>
 <th>otherState</th>
 <th>result updated record</th>
 </tr>
 <tr>
 <td>&lt;K1:A&gt;</td>
 <td>&lt;K1:A&gt;</td>
 <td></td>
 <td></td>
 <td></td>
 </tr>
 <tr>
 <td></td>
 <td>&lt;K1:A&gt;</td>
 <td>&lt;K1:b&gt;</td>
 <td>&lt;K1:b&gt;</td>
 <td>&lt;K1:ValueJoiner(A,b)&gt;</td>
 </tr>
 <tr>
 <td>&lt;K1:C&gt;</td>
 <td>&lt;K1:C&gt;</td>
 <td></td>
 <td>&lt;K1:b&gt;</td>
 <td>&lt;K1:ValueJoiner(C,b)&gt;</td>
 </tr>
 <tr>
 <td></td>
 <td>&lt;K1:C&gt;</td>
 <td>&lt;K1:null&gt;</td>
 <td></td>
 <td>&lt;K1:null&gt;</td>
 </tr>
 </table>
 Both input streams (or to be more precise, their underlying source topics) need to have the same number of
 partitions.</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>VO</code> - the value type of the other <code>KTable</code></dd>
<dd><code>VR</code> - the value type of the result <code>KTable</code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>other</code> - the other <code>KTable</code> to be joined with this <code>KTable</code></dd>
<dd><code>joiner</code> - a <a href="../../../../../org/apache/kafka/streams/kstream/ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueJoiner</code></a> that computes the join result for a pair of matching records</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a <code>KTable</code> that contains join-records for each key and values computed by the given
 <a href="../../../../../org/apache/kafka/streams/kstream/ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueJoiner</code></a>, one for each matched record-pair with the same key</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#leftJoin-org.apache.kafka.streams.kstream.KTable-org.apache.kafka.streams.kstream.ValueJoiner-"><code>leftJoin(KTable, ValueJoiner)</code></a>, 
<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#outerJoin-org.apache.kafka.streams.kstream.KTable-org.apache.kafka.streams.kstream.ValueJoiner-"><code>outerJoin(KTable, ValueJoiner)</code></a></dd>
</dl>
</li>
</ul>
<a name="join-org.apache.kafka.streams.kstream.KTable-org.apache.kafka.streams.kstream.ValueJoiner-org.apache.kafka.streams.kstream.Materialized-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>join</h4>
<pre>&lt;VO,VR&gt;&nbsp;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,VR&gt;&nbsp;join&#8203;(<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,VO&gt;&nbsp;other,
                          <a href="../../../../../org/apache/kafka/streams/kstream/ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream">ValueJoiner</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>,? super VO,? extends VR&gt;&nbsp;joiner,
                          <a href="../../../../../org/apache/kafka/streams/kstream/Materialized.html" title="class in org.apache.kafka.streams.kstream">Materialized</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,VR,<a href="../../../../../org/apache/kafka/streams/state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state">KeyValueStore</a>&lt;org.apache.kafka.common.utils.Bytes,byte[]&gt;&gt;&nbsp;materialized)</pre>
<div class="block">Join records of this <code>KTable</code> with another <code>KTable</code>'s records using non-windowed inner equi join,
 with the <a href="../../../../../org/apache/kafka/streams/kstream/Materialized.html" title="class in org.apache.kafka.streams.kstream"><code>Materialized</code></a> instance for configuration of the <a href="../../../../../org/apache/kafka/common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization"><code>key serde</code></a>,
 <a href="../../../../../org/apache/kafka/common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization"><code>the result table's value serde</code></a>, and <a href="../../../../../org/apache/kafka/streams/state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state"><code>state store</code></a>.
 The join is a primary key join with join attribute <code>thisKTable.key == otherKTable.key</code>.
 The result is an ever updating <code>KTable</code> that represents the <em>current</em> (i.e., processing time) result
 of the join.
 <p>
 The join is computed by (1) updating the internal state of one <code>KTable</code> and (2) performing a lookup for a
 matching record in the <em>current</em> (i.e., processing time) internal state of the other <code>KTable</code>.
 This happens in a symmetric way, i.e., for each update of either <code>this</code> or the <code>other</code> input
 <code>KTable</code> the result gets updated.
 <p>
 For each <code>KTable</code> record that finds a corresponding record in the other <code>KTable</code> the provided
 <a href="../../../../../org/apache/kafka/streams/kstream/ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueJoiner</code></a> will be called to compute a value (with arbitrary type) for the result record.
 The key of the result record is the same as for both joining input records.
 <p>
 Note that <a href="../../../../../org/apache/kafka/streams/KeyValue.html" title="class in org.apache.kafka.streams"><code>records</code></a> with <code>null</code> values (so-called tombstone records) have delete semantics.
 Thus, for input tombstones the provided value-joiner is not called but a tombstone record is forwarded
 directly to delete a record in the result <code>KTable</code> if required (i.e., if there is anything to be deleted).
 <p>
 Input records with <code>null</code> key will be dropped and no join computation is performed.
 <p>
 Example:
 <table border='1'>
 <tr>
 <th>thisKTable</th>
 <th>thisState</th>
 <th>otherKTable</th>
 <th>otherState</th>
 <th>result updated record</th>
 </tr>
 <tr>
 <td>&lt;K1:A&gt;</td>
 <td>&lt;K1:A&gt;</td>
 <td></td>
 <td></td>
 <td></td>
 </tr>
 <tr>
 <td></td>
 <td>&lt;K1:A&gt;</td>
 <td>&lt;K1:b&gt;</td>
 <td>&lt;K1:b&gt;</td>
 <td>&lt;K1:ValueJoiner(A,b)&gt;</td>
 </tr>
 <tr>
 <td>&lt;K1:C&gt;</td>
 <td>&lt;K1:C&gt;</td>
 <td></td>
 <td>&lt;K1:b&gt;</td>
 <td>&lt;K1:ValueJoiner(C,b)&gt;</td>
 </tr>
 <tr>
 <td></td>
 <td>&lt;K1:C&gt;</td>
 <td>&lt;K1:null&gt;</td>
 <td></td>
 <td>&lt;K1:null&gt;</td>
 </tr>
 </table>
 Both input streams (or to be more precise, their underlying source topics) need to have the same number of
 partitions.</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>VO</code> - the value type of the other <code>KTable</code></dd>
<dd><code>VR</code> - the value type of the result <code>KTable</code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>other</code> - the other <code>KTable</code> to be joined with this <code>KTable</code></dd>
<dd><code>joiner</code> - a <a href="../../../../../org/apache/kafka/streams/kstream/ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueJoiner</code></a> that computes the join result for a pair of matching records</dd>
<dd><code>materialized</code> - an instance of <a href="../../../../../org/apache/kafka/streams/kstream/Materialized.html" title="class in org.apache.kafka.streams.kstream"><code>Materialized</code></a> used to describe how the state store should be materialized.
                      Cannot be <code>null</code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a <code>KTable</code> that contains join-records for each key and values computed by the given
 <a href="../../../../../org/apache/kafka/streams/kstream/ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueJoiner</code></a>, one for each matched record-pair with the same key</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#leftJoin-org.apache.kafka.streams.kstream.KTable-org.apache.kafka.streams.kstream.ValueJoiner-org.apache.kafka.streams.kstream.Materialized-"><code>leftJoin(KTable, ValueJoiner, Materialized)</code></a>, 
<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#outerJoin-org.apache.kafka.streams.kstream.KTable-org.apache.kafka.streams.kstream.ValueJoiner-org.apache.kafka.streams.kstream.Materialized-"><code>outerJoin(KTable, ValueJoiner, Materialized)</code></a></dd>
</dl>
</li>
</ul>
<a name="leftJoin-org.apache.kafka.streams.kstream.KTable-org.apache.kafka.streams.kstream.ValueJoiner-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>leftJoin</h4>
<pre>&lt;VO,VR&gt;&nbsp;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,VR&gt;&nbsp;leftJoin&#8203;(<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,VO&gt;&nbsp;other,
                              <a href="../../../../../org/apache/kafka/streams/kstream/ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream">ValueJoiner</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>,? super VO,? extends VR&gt;&nbsp;joiner)</pre>
<div class="block">Join records of this <code>KTable</code> (left input) with another <code>KTable</code>'s (right input) records using
 non-windowed left equi join, with default serializers, deserializers, and state store.
 The join is a primary key join with join attribute <code>thisKTable.key == otherKTable.key</code>.
 In contrast to <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#join-org.apache.kafka.streams.kstream.KTable-org.apache.kafka.streams.kstream.ValueJoiner-"><code>inner-join</code></a>, all records from left <code>KTable</code> will produce
 an output record (cf. below).
 The result is an ever updating <code>KTable</code> that represents the <em>current</em> (i.e., processing time) result
 of the join.
 <p>
 The join is computed by (1) updating the internal state of one <code>KTable</code> and (2) performing a lookup for a
 matching record in the <em>current</em> (i.e., processing time) internal state of the other <code>KTable</code>.
 This happens in a symmetric way, i.e., for each update of either <code>this</code> or the <code>other</code> input
 <code>KTable</code> the result gets updated.
 <p>
 For each <code>KTable</code> record that finds a corresponding record in the other <code>KTable</code>'s state the
 provided <a href="../../../../../org/apache/kafka/streams/kstream/ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueJoiner</code></a> will be called to compute a value (with arbitrary type) for the result record.
 Additionally, for each record of left <code>KTable</code> that does not find a corresponding record in the
 right <code>KTable</code>'s state the provided <a href="../../../../../org/apache/kafka/streams/kstream/ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueJoiner</code></a> will be called with <code>rightValue =
 null</code> to compute a value (with arbitrary type) for the result record.
 The key of the result record is the same as for both joining input records.
 <p>
 Note that <a href="../../../../../org/apache/kafka/streams/KeyValue.html" title="class in org.apache.kafka.streams"><code>records</code></a> with <code>null</code> values (so-called tombstone records) have delete semantics.
 For example, for left input tombstones the provided value-joiner is not called but a tombstone record is
 forwarded directly to delete a record in the result <code>KTable</code> if required (i.e., if there is anything to be
 deleted).
 <p>
 Input records with <code>null</code> key will be dropped and no join computation is performed.
 <p>
 Example:
 <table border='1'>
 <tr>
 <th>thisKTable</th>
 <th>thisState</th>
 <th>otherKTable</th>
 <th>otherState</th>
 <th>result updated record</th>
 </tr>
 <tr>
 <td>&lt;K1:A&gt;</td>
 <td>&lt;K1:A&gt;</td>
 <td></td>
 <td></td>
 <td>&lt;K1:ValueJoiner(A,null)&gt;</td>
 </tr>
 <tr>
 <td></td>
 <td>&lt;K1:A&gt;</td>
 <td>&lt;K1:b&gt;</td>
 <td>&lt;K1:b&gt;</td>
 <td>&lt;K1:ValueJoiner(A,b)&gt;</td>
 </tr>
 <tr>
 <td>&lt;K1:null&gt;</td>
 <td></td>
 <td></td>
 <td>&lt;K1:b&gt;</td>
 <td>&lt;K1:null&gt;</td>
 </tr>
 <tr>
 <td></td>
 <td></td>
 <td>&lt;K1:null&gt;</td>
 <td></td>
 <td></td>
 </tr>
 </table>
 Both input streams (or to be more precise, their underlying source topics) need to have the same number of
 partitions.</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>VO</code> - the value type of the other <code>KTable</code></dd>
<dd><code>VR</code> - the value type of the result <code>KTable</code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>other</code> - the other <code>KTable</code> to be joined with this <code>KTable</code></dd>
<dd><code>joiner</code> - a <a href="../../../../../org/apache/kafka/streams/kstream/ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueJoiner</code></a> that computes the join result for a pair of matching records</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a <code>KTable</code> that contains join-records for each key and values computed by the given
 <a href="../../../../../org/apache/kafka/streams/kstream/ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueJoiner</code></a>, one for each matched record-pair with the same key plus one for each non-matching record of
 left <code>KTable</code></dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#join-org.apache.kafka.streams.kstream.KTable-org.apache.kafka.streams.kstream.ValueJoiner-"><code>join(KTable, ValueJoiner)</code></a>, 
<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#outerJoin-org.apache.kafka.streams.kstream.KTable-org.apache.kafka.streams.kstream.ValueJoiner-"><code>outerJoin(KTable, ValueJoiner)</code></a></dd>
</dl>
</li>
</ul>
<a name="leftJoin-org.apache.kafka.streams.kstream.KTable-org.apache.kafka.streams.kstream.ValueJoiner-org.apache.kafka.streams.kstream.Materialized-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>leftJoin</h4>
<pre>&lt;VO,VR&gt;&nbsp;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,VR&gt;&nbsp;leftJoin&#8203;(<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,VO&gt;&nbsp;other,
                              <a href="../../../../../org/apache/kafka/streams/kstream/ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream">ValueJoiner</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>,? super VO,? extends VR&gt;&nbsp;joiner,
                              <a href="../../../../../org/apache/kafka/streams/kstream/Materialized.html" title="class in org.apache.kafka.streams.kstream">Materialized</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,VR,<a href="../../../../../org/apache/kafka/streams/state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state">KeyValueStore</a>&lt;org.apache.kafka.common.utils.Bytes,byte[]&gt;&gt;&nbsp;materialized)</pre>
<div class="block">Join records of this <code>KTable</code> (left input) with another <code>KTable</code>'s (right input) records using
 non-windowed left equi join, with the <a href="../../../../../org/apache/kafka/streams/kstream/Materialized.html" title="class in org.apache.kafka.streams.kstream"><code>Materialized</code></a> instance for configuration of the <a href="../../../../../org/apache/kafka/common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization"><code>key serde</code></a>,
 <a href="../../../../../org/apache/kafka/common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization"><code>the result table's value serde</code></a>, and <a href="../../../../../org/apache/kafka/streams/state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state"><code>state store</code></a>.
 The join is a primary key join with join attribute <code>thisKTable.key == otherKTable.key</code>.
 In contrast to <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#join-org.apache.kafka.streams.kstream.KTable-org.apache.kafka.streams.kstream.ValueJoiner-"><code>inner-join</code></a>, all records from left <code>KTable</code> will produce
 an output record (cf. below).
 The result is an ever updating <code>KTable</code> that represents the <em>current</em> (i.e., processing time) result
 of the join.
 <p>
 The join is computed by (1) updating the internal state of one <code>KTable</code> and (2) performing a lookup for a
 matching record in the <em>current</em> (i.e., processing time) internal state of the other <code>KTable</code>.
 This happens in a symmetric way, i.e., for each update of either <code>this</code> or the <code>other</code> input
 <code>KTable</code> the result gets updated.
 <p>
 For each <code>KTable</code> record that finds a corresponding record in the other <code>KTable</code>'s state the
 provided <a href="../../../../../org/apache/kafka/streams/kstream/ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueJoiner</code></a> will be called to compute a value (with arbitrary type) for the result record.
 Additionally, for each record of left <code>KTable</code> that does not find a corresponding record in the
 right <code>KTable</code>'s state the provided <a href="../../../../../org/apache/kafka/streams/kstream/ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueJoiner</code></a> will be called with <code>rightValue =
 null</code> to compute a value (with arbitrary type) for the result record.
 The key of the result record is the same as for both joining input records.
 <p>
 Note that <a href="../../../../../org/apache/kafka/streams/KeyValue.html" title="class in org.apache.kafka.streams"><code>records</code></a> with <code>null</code> values (so-called tombstone records) have delete semantics.
 For example, for left input tombstones the provided value-joiner is not called but a tombstone record is
 forwarded directly to delete a record in the result <code>KTable</code> if required (i.e., if there is anything to be
 deleted).
 <p>
 Input records with <code>null</code> key will be dropped and no join computation is performed.
 <p>
 Example:
 <table border='1'>
 <tr>
 <th>thisKTable</th>
 <th>thisState</th>
 <th>otherKTable</th>
 <th>otherState</th>
 <th>result updated record</th>
 </tr>
 <tr>
 <td>&lt;K1:A&gt;</td>
 <td>&lt;K1:A&gt;</td>
 <td></td>
 <td></td>
 <td>&lt;K1:ValueJoiner(A,null)&gt;</td>
 </tr>
 <tr>
 <td></td>
 <td>&lt;K1:A&gt;</td>
 <td>&lt;K1:b&gt;</td>
 <td>&lt;K1:b&gt;</td>
 <td>&lt;K1:ValueJoiner(A,b)&gt;</td>
 </tr>
 <tr>
 <td>&lt;K1:null&gt;</td>
 <td></td>
 <td></td>
 <td>&lt;K1:b&gt;</td>
 <td>&lt;K1:null&gt;</td>
 </tr>
 <tr>
 <td></td>
 <td></td>
 <td>&lt;K1:null&gt;</td>
 <td></td>
 <td></td>
 </tr>
 </table>
 Both input streams (or to be more precise, their underlying source topics) need to have the same number of
 partitions.</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>VO</code> - the value type of the other <code>KTable</code></dd>
<dd><code>VR</code> - the value type of the result <code>KTable</code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>other</code> - the other <code>KTable</code> to be joined with this <code>KTable</code></dd>
<dd><code>joiner</code> - a <a href="../../../../../org/apache/kafka/streams/kstream/ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueJoiner</code></a> that computes the join result for a pair of matching records</dd>
<dd><code>materialized</code> - an instance of <a href="../../../../../org/apache/kafka/streams/kstream/Materialized.html" title="class in org.apache.kafka.streams.kstream"><code>Materialized</code></a> used to describe how the state store should be materialized.
                      Cannot be <code>null</code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a <code>KTable</code> that contains join-records for each key and values computed by the given
 <a href="../../../../../org/apache/kafka/streams/kstream/ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueJoiner</code></a>, one for each matched record-pair with the same key plus one for each non-matching record of
 left <code>KTable</code></dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#join-org.apache.kafka.streams.kstream.KTable-org.apache.kafka.streams.kstream.ValueJoiner-org.apache.kafka.streams.kstream.Materialized-"><code>join(KTable, ValueJoiner, Materialized)</code></a>, 
<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#outerJoin-org.apache.kafka.streams.kstream.KTable-org.apache.kafka.streams.kstream.ValueJoiner-org.apache.kafka.streams.kstream.Materialized-"><code>outerJoin(KTable, ValueJoiner, Materialized)</code></a></dd>
</dl>
</li>
</ul>
<a name="outerJoin-org.apache.kafka.streams.kstream.KTable-org.apache.kafka.streams.kstream.ValueJoiner-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>outerJoin</h4>
<pre>&lt;VO,VR&gt;&nbsp;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,VR&gt;&nbsp;outerJoin&#8203;(<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,VO&gt;&nbsp;other,
                               <a href="../../../../../org/apache/kafka/streams/kstream/ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream">ValueJoiner</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>,? super VO,? extends VR&gt;&nbsp;joiner)</pre>
<div class="block">Join records of this <code>KTable</code> (left input) with another <code>KTable</code>'s (right input) records using
 non-windowed outer equi join, with default serializers, deserializers, and state store.
 The join is a primary key join with join attribute <code>thisKTable.key == otherKTable.key</code>.
 In contrast to <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#join-org.apache.kafka.streams.kstream.KTable-org.apache.kafka.streams.kstream.ValueJoiner-"><code>inner-join</code></a> or <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#leftJoin-org.apache.kafka.streams.kstream.KTable-org.apache.kafka.streams.kstream.ValueJoiner-"><code>left-join</code></a>,
 all records from both input <code>KTable</code>s will produce an output record (cf. below).
 The result is an ever updating <code>KTable</code> that represents the <em>current</em> (i.e., processing time) result
 of the join.
 <p>
 The join is computed by (1) updating the internal state of one <code>KTable</code> and (2) performing a lookup for a
 matching record in the <em>current</em> (i.e., processing time) internal state of the other <code>KTable</code>.
 This happens in a symmetric way, i.e., for each update of either <code>this</code> or the <code>other</code> input
 <code>KTable</code> the result gets updated.
 <p>
 For each <code>KTable</code> record that finds a corresponding record in the other <code>KTable</code>'s state the
 provided <a href="../../../../../org/apache/kafka/streams/kstream/ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueJoiner</code></a> will be called to compute a value (with arbitrary type) for the result record.
 Additionally, for each record that does not find a corresponding record in the corresponding other
 <code>KTable</code>'s state the provided <a href="../../../../../org/apache/kafka/streams/kstream/ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueJoiner</code></a> will be called with <code>null</code> value for the
 corresponding other value to compute a value (with arbitrary type) for the result record.
 The key of the result record is the same as for both joining input records.
 <p>
 Note that <a href="../../../../../org/apache/kafka/streams/KeyValue.html" title="class in org.apache.kafka.streams"><code>records</code></a> with <code>null</code> values (so-called tombstone records) have delete semantics.
 Thus, for input tombstones the provided value-joiner is not called but a tombstone record is forwarded directly
 to delete a record in the result <code>KTable</code> if required (i.e., if there is anything to be deleted).
 <p>
 Input records with <code>null</code> key will be dropped and no join computation is performed.
 <p>
 Example:
 <table border='1'>
 <tr>
 <th>thisKTable</th>
 <th>thisState</th>
 <th>otherKTable</th>
 <th>otherState</th>
 <th>result updated record</th>
 </tr>
 <tr>
 <td>&lt;K1:A&gt;</td>
 <td>&lt;K1:A&gt;</td>
 <td></td>
 <td></td>
 <td>&lt;K1:ValueJoiner(A,null)&gt;</td>
 </tr>
 <tr>
 <td></td>
 <td>&lt;K1:A&gt;</td>
 <td>&lt;K1:b&gt;</td>
 <td>&lt;K1:b&gt;</td>
 <td>&lt;K1:ValueJoiner(A,b)&gt;</td>
 </tr>
 <tr>
 <td>&lt;K1:null&gt;</td>
 <td></td>
 <td></td>
 <td>&lt;K1:b&gt;</td>
 <td>&lt;K1:ValueJoiner(null,b)&gt;</td>
 </tr>
 <tr>
 <td></td>
 <td></td>
 <td>&lt;K1:null&gt;</td>
 <td></td>
 <td>&lt;K1:null&gt;</td>
 </tr>
 </table>
 Both input streams (or to be more precise, their underlying source topics) need to have the same number of
 partitions.</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>VO</code> - the value type of the other <code>KTable</code></dd>
<dd><code>VR</code> - the value type of the result <code>KTable</code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>other</code> - the other <code>KTable</code> to be joined with this <code>KTable</code></dd>
<dd><code>joiner</code> - a <a href="../../../../../org/apache/kafka/streams/kstream/ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueJoiner</code></a> that computes the join result for a pair of matching records</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a <code>KTable</code> that contains join-records for each key and values computed by the given
 <a href="../../../../../org/apache/kafka/streams/kstream/ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueJoiner</code></a>, one for each matched record-pair with the same key plus one for each non-matching record of
 both <code>KTable</code>s</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#join-org.apache.kafka.streams.kstream.KTable-org.apache.kafka.streams.kstream.ValueJoiner-"><code>join(KTable, ValueJoiner)</code></a>, 
<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#leftJoin-org.apache.kafka.streams.kstream.KTable-org.apache.kafka.streams.kstream.ValueJoiner-"><code>leftJoin(KTable, ValueJoiner)</code></a></dd>
</dl>
</li>
</ul>
<a name="outerJoin-org.apache.kafka.streams.kstream.KTable-org.apache.kafka.streams.kstream.ValueJoiner-org.apache.kafka.streams.kstream.Materialized-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>outerJoin</h4>
<pre>&lt;VO,VR&gt;&nbsp;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,VR&gt;&nbsp;outerJoin&#8203;(<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,VO&gt;&nbsp;other,
                               <a href="../../../../../org/apache/kafka/streams/kstream/ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream">ValueJoiner</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>,? super VO,? extends VR&gt;&nbsp;joiner,
                               <a href="../../../../../org/apache/kafka/streams/kstream/Materialized.html" title="class in org.apache.kafka.streams.kstream">Materialized</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,VR,<a href="../../../../../org/apache/kafka/streams/state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state">KeyValueStore</a>&lt;org.apache.kafka.common.utils.Bytes,byte[]&gt;&gt;&nbsp;materialized)</pre>
<div class="block">Join records of this <code>KTable</code> (left input) with another <code>KTable</code>'s (right input) records using
 non-windowed outer equi join, with the <a href="../../../../../org/apache/kafka/streams/kstream/Materialized.html" title="class in org.apache.kafka.streams.kstream"><code>Materialized</code></a> instance for configuration of the <a href="../../../../../org/apache/kafka/common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization"><code>key serde</code></a>,
 <a href="../../../../../org/apache/kafka/common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization"><code>the result table's value serde</code></a>, and <a href="../../../../../org/apache/kafka/streams/state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state"><code>state store</code></a>.
 The join is a primary key join with join attribute <code>thisKTable.key == otherKTable.key</code>.
 In contrast to <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#join-org.apache.kafka.streams.kstream.KTable-org.apache.kafka.streams.kstream.ValueJoiner-"><code>inner-join</code></a> or <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#leftJoin-org.apache.kafka.streams.kstream.KTable-org.apache.kafka.streams.kstream.ValueJoiner-"><code>left-join</code></a>,
 all records from both input <code>KTable</code>s will produce an output record (cf. below).
 The result is an ever updating <code>KTable</code> that represents the <em>current</em> (i.e., processing time) result
 of the join.
 <p>
 The join is computed by (1) updating the internal state of one <code>KTable</code> and (2) performing a lookup for a
 matching record in the <em>current</em> (i.e., processing time) internal state of the other <code>KTable</code>.
 This happens in a symmetric way, i.e., for each update of either <code>this</code> or the <code>other</code> input
 <code>KTable</code> the result gets updated.
 <p>
 For each <code>KTable</code> record that finds a corresponding record in the other <code>KTable</code>'s state the
 provided <a href="../../../../../org/apache/kafka/streams/kstream/ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueJoiner</code></a> will be called to compute a value (with arbitrary type) for the result record.
 Additionally, for each record that does not find a corresponding record in the corresponding other
 <code>KTable</code>'s state the provided <a href="../../../../../org/apache/kafka/streams/kstream/ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueJoiner</code></a> will be called with <code>null</code> value for the
 corresponding other value to compute a value (with arbitrary type) for the result record.
 The key of the result record is the same as for both joining input records.
 <p>
 Note that <a href="../../../../../org/apache/kafka/streams/KeyValue.html" title="class in org.apache.kafka.streams"><code>records</code></a> with <code>null</code> values (so-called tombstone records) have delete semantics.
 Thus, for input tombstones the provided value-joiner is not called but a tombstone record is forwarded directly
 to delete a record in the result <code>KTable</code> if required (i.e., if there is anything to be deleted).
 <p>
 Input records with <code>null</code> key will be dropped and no join computation is performed.
 <p>
 Example:
 <table border='1'>
 <tr>
 <th>thisKTable</th>
 <th>thisState</th>
 <th>otherKTable</th>
 <th>otherState</th>
 <th>result updated record</th>
 </tr>
 <tr>
 <td>&lt;K1:A&gt;</td>
 <td>&lt;K1:A&gt;</td>
 <td></td>
 <td></td>
 <td>&lt;K1:ValueJoiner(A,null)&gt;</td>
 </tr>
 <tr>
 <td></td>
 <td>&lt;K1:A&gt;</td>
 <td>&lt;K1:b&gt;</td>
 <td>&lt;K1:b&gt;</td>
 <td>&lt;K1:ValueJoiner(A,b)&gt;</td>
 </tr>
 <tr>
 <td>&lt;K1:null&gt;</td>
 <td></td>
 <td></td>
 <td>&lt;K1:b&gt;</td>
 <td>&lt;K1:ValueJoiner(null,b)&gt;</td>
 </tr>
 <tr>
 <td></td>
 <td></td>
 <td>&lt;K1:null&gt;</td>
 <td></td>
 <td>&lt;K1:null&gt;</td>
 </tr>
 </table>
 Both input streams (or to be more precise, their underlying source topics) need to have the same number of
 partitions.</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>VO</code> - the value type of the other <code>KTable</code></dd>
<dd><code>VR</code> - the value type of the result <code>KTable</code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>other</code> - the other <code>KTable</code> to be joined with this <code>KTable</code></dd>
<dd><code>joiner</code> - a <a href="../../../../../org/apache/kafka/streams/kstream/ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueJoiner</code></a> that computes the join result for a pair of matching records</dd>
<dd><code>materialized</code> - an instance of <a href="../../../../../org/apache/kafka/streams/kstream/Materialized.html" title="class in org.apache.kafka.streams.kstream"><code>Materialized</code></a> used to describe how the state store should be materialized.
                      Cannot be <code>null</code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a <code>KTable</code> that contains join-records for each key and values computed by the given
 <a href="../../../../../org/apache/kafka/streams/kstream/ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueJoiner</code></a>, one for each matched record-pair with the same key plus one for each non-matching record of
 both <code>KTable</code>s</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#join-org.apache.kafka.streams.kstream.KTable-org.apache.kafka.streams.kstream.ValueJoiner-"><code>join(KTable, ValueJoiner)</code></a>, 
<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#leftJoin-org.apache.kafka.streams.kstream.KTable-org.apache.kafka.streams.kstream.ValueJoiner-"><code>leftJoin(KTable, ValueJoiner)</code></a></dd>
</dl>
</li>
</ul>
<a name="queryableStoreName--">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>queryableStoreName</h4>
<pre>java.lang.String&nbsp;queryableStoreName&#8203;()</pre>
<div class="block">Get the name of the local state store used that can be used to query this <code>KTable</code>.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the underlying state store name, or <code>null</code> if this <code>KTable</code> cannot be queried.</dd>
</dl>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<!-- ========= END OF CLASS DATA ========= -->
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a name="navbar.bottom">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a></div>
<a name="navbar.bottom.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../../../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../../index-all.html">Index</a></li>
<li><a href="../../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="interface in org.apache.kafka.streams.kstream"><span class="typeNameLink">Prev&nbsp;Class</span></a></li>
<li><a href="../../../../../org/apache/kafka/streams/kstream/Materialized.html" title="class in org.apache.kafka.streams.kstream"><span class="typeNameLink">Next&nbsp;Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../../../../index.html?org/apache/kafka/streams/kstream/KTable.html" target="_top">Frames</a></li>
<li><a href="KTable.html" target="_top">No&nbsp;Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="../../../../../allclasses-noframe.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a name="skip.navbar.bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
</body>
</html>

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (9) on Wed Mar 28 12:13:00 BST 2018 -->
<title>KGroupedTable (kafka 1.1.0 API)</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="date" content="2018-03-28">
<link rel="stylesheet" type="text/css" href="../../../../../stylesheet.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../../../../jquery/jquery-ui.css" title="Style">
<script type="text/javascript" src="../../../../../script.js"></script>
<script type="text/javascript" src="../../../../../jquery/jszip/dist/jszip.min.js"></script>
<script type="text/javascript" src="../../../../../jquery/jszip-utils/dist/jszip-utils.min.js"></script>
<!--[if IE]>
<script type="text/javascript" src="../../../../../jquery/jszip-utils/dist/jszip-utils-ie.min.js"></script>
<![endif]-->
<script type="text/javascript" src="../../../../../jquery/jquery-1.10.2.js"></script>
<script type="text/javascript" src="../../../../../jquery/jquery-ui.js"></script>
</head>
<body>
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="KGroupedTable (kafka 1.1.0 API)";
        }
    }
    catch(err) {
    }
//-->
var methods = {"i0":6,"i1":38,"i2":38,"i3":38,"i4":6,"i5":38,"i6":6,"i7":38,"i8":6,"i9":38,"i10":6,"i11":38,"i12":6,"i13":38};
var tabs = {65535:["t0","All Methods"],2:["t2","Instance Methods"],4:["t3","Abstract Methods"],32:["t6","Deprecated Methods"]};
var altColor = "altColor";
var rowColor = "rowColor";
var tableTab = "tableTab";
var activeTableTab = "activeTableTab";
var pathtoroot = "../../../../../";loadScripts(document, 'script');</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<div class="fixedNav">
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a name="navbar.top">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<a name="navbar.top.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../../../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../../index-all.html">Index</a></li>
<li><a href="../../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html" title="interface in org.apache.kafka.streams.kstream"><span class="typeNameLink">Prev&nbsp;Class</span></a></li>
<li><a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="interface in org.apache.kafka.streams.kstream"><span class="typeNameLink">Next&nbsp;Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../../../../index.html?org/apache/kafka/streams/kstream/KGroupedTable.html" target="_top">Frames</a></li>
<li><a href="KGroupedTable.html" target="_top">No&nbsp;Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_top">
<li><a href="../../../../../allclasses-noframe.html">All&nbsp;Classes</a></li>
</ul>
<ul class="navListSearch">
<li><span>SEARCH:&nbsp;</span>
<input type="text" id="search" value=" " disabled="disabled">
<input type="reset" id="reset" value=" " disabled="disabled">
</li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a name="skip.navbar.top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
</div>
<div class="navPadding">&nbsp;</div>
<script type="text/javascript"><!--
$('.navPadding').css('padding-top', $('.fixedNav').css("height"));
//-->
</script>
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="subTitle"><span class="packageLabelInType">Package</span>&nbsp;<a href="../../../../../org/apache/kafka/streams/kstream/package-summary.html">org.apache.kafka.streams.kstream</a></div>
<h2 title="Interface KGroupedTable" class="title">Interface KGroupedTable&lt;K,V&gt;</h2>
</div>
<div class="contentContainer">
<div class="description">
<ul class="blockList">
<li class="blockList">
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>K</code> - Type of keys</dd>
<dd><code>V</code> - Type of values</dd>
</dl>
<hr>
<br>
<pre><a href="../../../../../org/apache/kafka/common/annotation/InterfaceStability.Evolving.html" title="annotation in org.apache.kafka.common.annotation">@Evolving</a>
public interface <span class="typeNameLabel">KGroupedTable&lt;K,V&gt;</span></pre>
<div class="block"><code>KGroupedTable</code> is an abstraction of a <i>re-grouped changelog stream</i> from a primary-keyed table,
 usually on a different grouping key than the original primary key.
 <p>
 It is an intermediate representation after a re-grouping of a <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> before an aggregation is applied to the
 new partitions resulting in a new <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a>.
 <p>
 A <code>KGroupedTable</code> must be obtained from a <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> via <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#groupBy-org.apache.kafka.streams.kstream.KeyValueMapper-"><code>groupBy(...)</code></a>.</div>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a></dd>
</dl>
</li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- ========== METHOD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="method.summary">
<!--   -->
</a>
<h3>Method Summary</h3>
<table class="memberSummary" summary="Method Summary table, listing methods, and an explanation">
<caption><span id="t0" class="activeTableTab"><span>All Methods</span><span class="tabEnd">&nbsp;</span></span><span id="t2" class="tableTab"><span><a href="javascript:show(2);">Instance Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t3" class="tableTab"><span><a href="javascript:show(4);">Abstract Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t6" class="tableTab"><span><a href="javascript:show(32);">Deprecated Methods</a></span><span class="tabEnd">&nbsp;</span></span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colSecond" scope="col">Method</th>
<th class="colLast" scope="col">Description</th>
</tr>
<tr id="i0" class="altColor">
<td class="colFirst"><code>&lt;VR&gt;&nbsp;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html" title="type parameter in KGroupedTable">K</a>,VR&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html#aggregate-org.apache.kafka.streams.kstream.Initializer-org.apache.kafka.streams.kstream.Aggregator-org.apache.kafka.streams.kstream.Aggregator-">aggregate</a></span>&#8203;(<a href="../../../../../org/apache/kafka/streams/kstream/Initializer.html" title="interface in org.apache.kafka.streams.kstream">Initializer</a>&lt;VR&gt;&nbsp;initializer,
         <a href="../../../../../org/apache/kafka/streams/kstream/Aggregator.html" title="interface in org.apache.kafka.streams.kstream">Aggregator</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html" title="type parameter in KGroupedTable">K</a>,? super <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html" title="type parameter in KGroupedTable">V</a>,VR&gt;&nbsp;adder,
         <a href="../../../../../org/apache/kafka/streams/kstream/Aggregator.html" title="interface in org.apache.kafka.streams.kstream">Aggregator</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html" title="type parameter in KGroupedTable">K</a>,? super <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html" title="type parameter in KGroupedTable">V</a>,VR&gt;&nbsp;subtractor)</code></th>
<td class="colLast">
<div class="block">Aggregate the value of records of the original <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> that got <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#groupBy-org.apache.kafka.streams.kstream.KeyValueMapper-"><code>mapped</code></a> to the same key into a new instance of <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> using default serializers and deserializers.</div>
</td>
</tr>
<tr id="i1" class="rowColor">
<td class="colFirst"><code>&lt;VR&gt;&nbsp;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html" title="type parameter in KGroupedTable">K</a>,VR&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html#aggregate-org.apache.kafka.streams.kstream.Initializer-org.apache.kafka.streams.kstream.Aggregator-org.apache.kafka.streams.kstream.Aggregator-java.lang.String-">aggregate</a></span>&#8203;(<a href="../../../../../org/apache/kafka/streams/kstream/Initializer.html" title="interface in org.apache.kafka.streams.kstream">Initializer</a>&lt;VR&gt;&nbsp;initializer,
         <a href="../../../../../org/apache/kafka/streams/kstream/Aggregator.html" title="interface in org.apache.kafka.streams.kstream">Aggregator</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html" title="type parameter in KGroupedTable">K</a>,? super <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html" title="type parameter in KGroupedTable">V</a>,VR&gt;&nbsp;adder,
         <a href="../../../../../org/apache/kafka/streams/kstream/Aggregator.html" title="interface in org.apache.kafka.streams.kstream">Aggregator</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html" title="type parameter in KGroupedTable">K</a>,? super <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html" title="type parameter in KGroupedTable">V</a>,VR&gt;&nbsp;subtractor,
         java.lang.String&nbsp;queryableStoreName)</code></th>
<td class="colLast">
<div class="block"><span class="deprecatedLabel">Deprecated.</span>&nbsp;
<div class="block"><span class="deprecationComment">use <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html#aggregate-org.apache.kafka.streams.kstream.Initializer-org.apache.kafka.streams.kstream.Aggregator-org.apache.kafka.streams.kstream.Aggregator-org.apache.kafka.streams.kstream.Materialized-"><code>aggregate(initializer, adder, subtractor, Materialized.as(queryableStoreName))</code></a></span></div>
</div>
</td>
</tr>
<tr id="i2" class="altColor">
<td class="colFirst"><code>&lt;VR&gt;&nbsp;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html" title="type parameter in KGroupedTable">K</a>,VR&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html#aggregate-org.apache.kafka.streams.kstream.Initializer-org.apache.kafka.streams.kstream.Aggregator-org.apache.kafka.streams.kstream.Aggregator-org.apache.kafka.common.serialization.Serde-">aggregate</a></span>&#8203;(<a href="../../../../../org/apache/kafka/streams/kstream/Initializer.html" title="interface in org.apache.kafka.streams.kstream">Initializer</a>&lt;VR&gt;&nbsp;initializer,
         <a href="../../../../../org/apache/kafka/streams/kstream/Aggregator.html" title="interface in org.apache.kafka.streams.kstream">Aggregator</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html" title="type parameter in KGroupedTable">K</a>,? super <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html" title="type parameter in KGroupedTable">V</a>,VR&gt;&nbsp;adder,
         <a href="../../../../../org/apache/kafka/streams/kstream/Aggregator.html" title="interface in org.apache.kafka.streams.kstream">Aggregator</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html" title="type parameter in KGroupedTable">K</a>,? super <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html" title="type parameter in KGroupedTable">V</a>,VR&gt;&nbsp;subtractor,
         <a href="../../../../../org/apache/kafka/common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization">Serde</a>&lt;VR&gt;&nbsp;aggValueSerde)</code></th>
<td class="colLast">
<div class="block"><span class="deprecatedLabel">Deprecated.</span>&nbsp;
<div class="block"><span class="deprecationComment">use <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html#aggregate-org.apache.kafka.streams.kstream.Initializer-org.apache.kafka.streams.kstream.Aggregator-org.apache.kafka.streams.kstream.Aggregator-org.apache.kafka.streams.kstream.Materialized-"><code>aggregate(initializer, adder, subtractor, Materialized.with(null, aggValueSerde))</code></a></span></div>
</div>
</td>
</tr>
<tr id="i3" class="rowColor">
<td class="colFirst"><code>&lt;VR&gt;&nbsp;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html" title="type parameter in KGroupedTable">K</a>,VR&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html#aggregate-org.apache.kafka.streams.kstream.Initializer-org.apache.kafka.streams.kstream.Aggregator-org.apache.kafka.streams.kstream.Aggregator-org.apache.kafka.common.serialization.Serde-java.lang.String-">aggregate</a></span>&#8203;(<a href="../../../../../org/apache/kafka/streams/kstream/Initializer.html" title="interface in org.apache.kafka.streams.kstream">Initializer</a>&lt;VR&gt;&nbsp;initializer,
         <a href="../../../../../org/apache/kafka/streams/kstream/Aggregator.html" title="interface in org.apache.kafka.streams.kstream">Aggregator</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html" title="type parameter in KGroupedTable">K</a>,? super <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html" title="type parameter in KGroupedTable">V</a>,VR&gt;&nbsp;adder,
         <a href="../../../../../org/apache/kafka/streams/kstream/Aggregator.html" title="interface in org.apache.kafka.streams.kstream">Aggregator</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html" title="type parameter in KGroupedTable">K</a>,? super <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html" title="type parameter in KGroupedTable">V</a>,VR&gt;&nbsp;subtractor,
         <a href="../../../../../org/apache/kafka/common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization">Serde</a>&lt;VR&gt;&nbsp;aggValueSerde,
         java.lang.String&nbsp;queryableStoreName)</code></th>
<td class="colLast">
<div class="block"><span class="deprecatedLabel">Deprecated.</span>&nbsp;
<div class="block"><span class="deprecationComment">use <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html#aggregate-org.apache.kafka.streams.kstream.Initializer-org.apache.kafka.streams.kstream.Aggregator-org.apache.kafka.streams.kstream.Aggregator-org.apache.kafka.streams.kstream.Materialized-"><code>aggregate(initializer, adder, subtractor, Materialized.as(queryableStoreName).withValueSerde(aggValueSerde))</code></a></span></div>
</div>
</td>
</tr>
<tr id="i4" class="altColor">
<td class="colFirst"><code>&lt;VR&gt;&nbsp;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html" title="type parameter in KGroupedTable">K</a>,VR&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html#aggregate-org.apache.kafka.streams.kstream.Initializer-org.apache.kafka.streams.kstream.Aggregator-org.apache.kafka.streams.kstream.Aggregator-org.apache.kafka.streams.kstream.Materialized-">aggregate</a></span>&#8203;(<a href="../../../../../org/apache/kafka/streams/kstream/Initializer.html" title="interface in org.apache.kafka.streams.kstream">Initializer</a>&lt;VR&gt;&nbsp;initializer,
         <a href="../../../../../org/apache/kafka/streams/kstream/Aggregator.html" title="interface in org.apache.kafka.streams.kstream">Aggregator</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html" title="type parameter in KGroupedTable">K</a>,? super <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html" title="type parameter in KGroupedTable">V</a>,VR&gt;&nbsp;adder,
         <a href="../../../../../org/apache/kafka/streams/kstream/Aggregator.html" title="interface in org.apache.kafka.streams.kstream">Aggregator</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html" title="type parameter in KGroupedTable">K</a>,? super <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html" title="type parameter in KGroupedTable">V</a>,VR&gt;&nbsp;subtractor,
         <a href="../../../../../org/apache/kafka/streams/kstream/Materialized.html" title="class in org.apache.kafka.streams.kstream">Materialized</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html" title="type parameter in KGroupedTable">K</a>,VR,<a href="../../../../../org/apache/kafka/streams/state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state">KeyValueStore</a>&lt;org.apache.kafka.common.utils.Bytes,byte[]&gt;&gt;&nbsp;materialized)</code></th>
<td class="colLast">
<div class="block">Aggregate the value of records of the original <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> that got <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#groupBy-org.apache.kafka.streams.kstream.KeyValueMapper-"><code>mapped</code></a> to the same key into a new instance of <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> using default serializers and deserializers.</div>
</td>
</tr>
<tr id="i5" class="rowColor">
<td class="colFirst"><code>&lt;VR&gt;&nbsp;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html" title="type parameter in KGroupedTable">K</a>,VR&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html#aggregate-org.apache.kafka.streams.kstream.Initializer-org.apache.kafka.streams.kstream.Aggregator-org.apache.kafka.streams.kstream.Aggregator-org.apache.kafka.streams.processor.StateStoreSupplier-">aggregate</a></span>&#8203;(<a href="../../../../../org/apache/kafka/streams/kstream/Initializer.html" title="interface in org.apache.kafka.streams.kstream">Initializer</a>&lt;VR&gt;&nbsp;initializer,
         <a href="../../../../../org/apache/kafka/streams/kstream/Aggregator.html" title="interface in org.apache.kafka.streams.kstream">Aggregator</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html" title="type parameter in KGroupedTable">K</a>,? super <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html" title="type parameter in KGroupedTable">V</a>,VR&gt;&nbsp;adder,
         <a href="../../../../../org/apache/kafka/streams/kstream/Aggregator.html" title="interface in org.apache.kafka.streams.kstream">Aggregator</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html" title="type parameter in KGroupedTable">K</a>,? super <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html" title="type parameter in KGroupedTable">V</a>,VR&gt;&nbsp;subtractor,
         <a href="../../../../../org/apache/kafka/streams/processor/StateStoreSupplier.html" title="interface in org.apache.kafka.streams.processor">StateStoreSupplier</a>&lt;<a href="../../../../../org/apache/kafka/streams/state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state">KeyValueStore</a>&gt;&nbsp;storeSupplier)</code></th>
<td class="colLast">
<div class="block"><span class="deprecatedLabel">Deprecated.</span>&nbsp;
<div class="block"><span class="deprecationComment">use <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html#aggregate-org.apache.kafka.streams.kstream.Initializer-org.apache.kafka.streams.kstream.Aggregator-org.apache.kafka.streams.kstream.Aggregator-org.apache.kafka.streams.kstream.Materialized-"><code>aggregate(initializer, adder, subtractor, Materialized.as(KeyValueByteStoreSupplier))</code></a></span></div>
</div>
</td>
</tr>
<tr id="i6" class="altColor">
<td class="colFirst"><code><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html" title="type parameter in KGroupedTable">K</a>,java.lang.Long&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html#count--">count</a></span>&#8203;()</code></th>
<td class="colLast">
<div class="block">Count number of records of the original <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> that got <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#groupBy-org.apache.kafka.streams.kstream.KeyValueMapper-"><code>mapped</code></a> to
 the same key into a new instance of <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a>.</div>
</td>
</tr>
<tr id="i7" class="rowColor">
<td class="colFirst"><code><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html" title="type parameter in KGroupedTable">K</a>,java.lang.Long&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html#count-java.lang.String-">count</a></span>&#8203;(java.lang.String&nbsp;queryableStoreName)</code></th>
<td class="colLast">
<div class="block"><span class="deprecatedLabel">Deprecated.</span>&nbsp;
<div class="block"><span class="deprecationComment">use <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html#count-org.apache.kafka.streams.kstream.Materialized-"><code>count(Materialized.as(queryableStoreName))</code></a></span></div>
</div>
</td>
</tr>
<tr id="i8" class="altColor">
<td class="colFirst"><code><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html" title="type parameter in KGroupedTable">K</a>,java.lang.Long&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html#count-org.apache.kafka.streams.kstream.Materialized-">count</a></span>&#8203;(<a href="../../../../../org/apache/kafka/streams/kstream/Materialized.html" title="class in org.apache.kafka.streams.kstream">Materialized</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html" title="type parameter in KGroupedTable">K</a>,java.lang.Long,<a href="../../../../../org/apache/kafka/streams/state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state">KeyValueStore</a>&lt;org.apache.kafka.common.utils.Bytes,byte[]&gt;&gt;&nbsp;materialized)</code></th>
<td class="colLast">
<div class="block">Count number of records of the original <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> that got <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#groupBy-org.apache.kafka.streams.kstream.KeyValueMapper-"><code>mapped</code></a> to
 the same key into a new instance of <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a>.</div>
</td>
</tr>
<tr id="i9" class="rowColor">
<td class="colFirst"><code><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html" title="type parameter in KGroupedTable">K</a>,java.lang.Long&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html#count-org.apache.kafka.streams.processor.StateStoreSupplier-">count</a></span>&#8203;(<a href="../../../../../org/apache/kafka/streams/processor/StateStoreSupplier.html" title="interface in org.apache.kafka.streams.processor">StateStoreSupplier</a>&lt;<a href="../../../../../org/apache/kafka/streams/state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state">KeyValueStore</a>&gt;&nbsp;storeSupplier)</code></th>
<td class="colLast">
<div class="block"><span class="deprecatedLabel">Deprecated.</span>&nbsp;
<div class="block"><span class="deprecationComment">use <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html#count-org.apache.kafka.streams.kstream.Materialized-"><code>count(Materialized.as(KeyValueByteStoreSupplier)</code></a></span></div>
</div>
</td>
</tr>
<tr id="i10" class="altColor">
<td class="colFirst"><code><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html" title="type parameter in KGroupedTable">K</a>,<a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html" title="type parameter in KGroupedTable">V</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html#reduce-org.apache.kafka.streams.kstream.Reducer-org.apache.kafka.streams.kstream.Reducer-">reduce</a></span>&#8203;(<a href="../../../../../org/apache/kafka/streams/kstream/Reducer.html" title="interface in org.apache.kafka.streams.kstream">Reducer</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html" title="type parameter in KGroupedTable">V</a>&gt;&nbsp;adder,
      <a href="../../../../../org/apache/kafka/streams/kstream/Reducer.html" title="interface in org.apache.kafka.streams.kstream">Reducer</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html" title="type parameter in KGroupedTable">V</a>&gt;&nbsp;subtractor)</code></th>
<td class="colLast">
<div class="block">Combine the value of records of the original <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> that got <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#groupBy-org.apache.kafka.streams.kstream.KeyValueMapper-"><code>mapped</code></a> to the same key into a new instance of <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a>.</div>
</td>
</tr>
<tr id="i11" class="rowColor">
<td class="colFirst"><code><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html" title="type parameter in KGroupedTable">K</a>,<a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html" title="type parameter in KGroupedTable">V</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html#reduce-org.apache.kafka.streams.kstream.Reducer-org.apache.kafka.streams.kstream.Reducer-java.lang.String-">reduce</a></span>&#8203;(<a href="../../../../../org/apache/kafka/streams/kstream/Reducer.html" title="interface in org.apache.kafka.streams.kstream">Reducer</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html" title="type parameter in KGroupedTable">V</a>&gt;&nbsp;adder,
      <a href="../../../../../org/apache/kafka/streams/kstream/Reducer.html" title="interface in org.apache.kafka.streams.kstream">Reducer</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html" title="type parameter in KGroupedTable">V</a>&gt;&nbsp;subtractor,
      java.lang.String&nbsp;queryableStoreName)</code></th>
<td class="colLast">
<div class="block"><span class="deprecatedLabel">Deprecated.</span>&nbsp;
<div class="block"><span class="deprecationComment">use <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html#reduce-org.apache.kafka.streams.kstream.Reducer-org.apache.kafka.streams.kstream.Reducer-org.apache.kafka.streams.kstream.Materialized-"><code>reduce(adder, subtractor, Materialized.as(queryableStoreName))</code></a></span></div>
</div>
</td>
</tr>
<tr id="i12" class="altColor">
<td class="colFirst"><code><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html" title="type parameter in KGroupedTable">K</a>,<a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html" title="type parameter in KGroupedTable">V</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html#reduce-org.apache.kafka.streams.kstream.Reducer-org.apache.kafka.streams.kstream.Reducer-org.apache.kafka.streams.kstream.Materialized-">reduce</a></span>&#8203;(<a href="../../../../../org/apache/kafka/streams/kstream/Reducer.html" title="interface in org.apache.kafka.streams.kstream">Reducer</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html" title="type parameter in KGroupedTable">V</a>&gt;&nbsp;adder,
      <a href="../../../../../org/apache/kafka/streams/kstream/Reducer.html" title="interface in org.apache.kafka.streams.kstream">Reducer</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html" title="type parameter in KGroupedTable">V</a>&gt;&nbsp;subtractor,
      <a href="../../../../../org/apache/kafka/streams/kstream/Materialized.html" title="class in org.apache.kafka.streams.kstream">Materialized</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html" title="type parameter in KGroupedTable">K</a>,<a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html" title="type parameter in KGroupedTable">V</a>,<a href="../../../../../org/apache/kafka/streams/state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state">KeyValueStore</a>&lt;org.apache.kafka.common.utils.Bytes,byte[]&gt;&gt;&nbsp;materialized)</code></th>
<td class="colLast">
<div class="block">Combine the value of records of the original <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> that got <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#groupBy-org.apache.kafka.streams.kstream.KeyValueMapper-"><code>mapped</code></a> to the same key into a new instance of <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a>.</div>
</td>
</tr>
<tr id="i13" class="rowColor">
<td class="colFirst"><code><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html" title="type parameter in KGroupedTable">K</a>,<a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html" title="type parameter in KGroupedTable">V</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html#reduce-org.apache.kafka.streams.kstream.Reducer-org.apache.kafka.streams.kstream.Reducer-org.apache.kafka.streams.processor.StateStoreSupplier-">reduce</a></span>&#8203;(<a href="../../../../../org/apache/kafka/streams/kstream/Reducer.html" title="interface in org.apache.kafka.streams.kstream">Reducer</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html" title="type parameter in KGroupedTable">V</a>&gt;&nbsp;adder,
      <a href="../../../../../org/apache/kafka/streams/kstream/Reducer.html" title="interface in org.apache.kafka.streams.kstream">Reducer</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html" title="type parameter in KGroupedTable">V</a>&gt;&nbsp;subtractor,
      <a href="../../../../../org/apache/kafka/streams/processor/StateStoreSupplier.html" title="interface in org.apache.kafka.streams.processor">StateStoreSupplier</a>&lt;<a href="../../../../../org/apache/kafka/streams/state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state">KeyValueStore</a>&gt;&nbsp;storeSupplier)</code></th>
<td class="colLast">
<div class="block"><span class="deprecatedLabel">Deprecated.</span>&nbsp;
<div class="block"><span class="deprecationComment">use <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html#reduce-org.apache.kafka.streams.kstream.Reducer-org.apache.kafka.streams.kstream.Reducer-org.apache.kafka.streams.kstream.Materialized-"><code>reduce(adder, subtractor, Materialized.as(KeyValueByteStoreSupplier))</code></a></span></div>
</div>
</td>
</tr>
</table>
</li>
</ul>
</li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ============ METHOD DETAIL ========== -->
<ul class="blockList">
<li class="blockList"><a name="method.detail">
<!--   -->
</a>
<h3>Method Detail</h3>
<a name="count-java.lang.String-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>count</h4>
<pre>@Deprecated
<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html" title="type parameter in KGroupedTable">K</a>,java.lang.Long&gt;&nbsp;count&#8203;(java.lang.String&nbsp;queryableStoreName)</pre>
<div class="block"><span class="deprecatedLabel">Deprecated.</span>&nbsp;<span class="deprecationComment">use <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html#count-org.apache.kafka.streams.kstream.Materialized-"><code>count(Materialized.as(queryableStoreName))</code></a></span></div>
<div class="block">Count number of records of the original <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> that got <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#groupBy-org.apache.kafka.streams.kstream.KeyValueMapper-"><code>mapped</code></a> to
 the same key into a new instance of <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a>.
 Records with <code>null</code> key are ignored.
 The result is written into a local <a href="../../../../../org/apache/kafka/streams/state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state"><code>KeyValueStore</code></a> (which is basically an ever-updating materialized view)
 that can be queried using the provided <code>queryableStoreName</code>.
 Furthermore, updates to the store are sent downstream into a <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> changelog stream.
 <p>
 Not all updates might get sent downstream, as an internal cache is used to deduplicate consecutive updates to
 the same key.
 The rate of propagated updates depends on your input data rate, the number of distinct keys, the number of
 parallel running Kafka Streams instances, and the <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html" title="class in org.apache.kafka.streams"><code>configuration</code></a> parameters for
 <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html#CACHE_MAX_BYTES_BUFFERING_CONFIG"><code>cache size</code></a>, and
 <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html#COMMIT_INTERVAL_MS_CONFIG"><code>commit intervall</code></a>.
 <p>
 To query the local <a href="../../../../../org/apache/kafka/streams/state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state"><code>KeyValueStore</code></a> it must be obtained via
 <a href="../../../../../org/apache/kafka/streams/KafkaStreams.html#store-java.lang.String-org.apache.kafka.streams.state.QueryableStoreType-"><code>KafkaStreams#store(...)</code></a>:
 <pre><code>
 KafkaStreams streams = ... // counting words
 ReadOnlyKeyValueStore&lt;String,Long&gt; localStore = streams.store(queryableStoreName, QueryableStoreTypes.&lt;String, Long&gt;keyValueStore());
 String key = "some-word";
 Long countForWord = localStore.get(key); // key must be local (application state is shared over all running Kafka Streams instances)
 </code></pre>
 For non-local keys, a custom RPC mechanism must be implemented using <a href="../../../../../org/apache/kafka/streams/KafkaStreams.html#allMetadata--"><code>KafkaStreams.allMetadata()</code></a> to
 query the value of the key on a parallel running instance of your Kafka Streams application.
 <p>
 For failure and recovery the store will be backed by an internal changelog topic that will be created in Kafka.
 The changelog topic will be named "${applicationId}-${queryableStoreName}-changelog", where "applicationId" is
 user-specified in <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html" title="class in org.apache.kafka.streams"><code>StreamsConfig</code></a> via parameter
 <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html#APPLICATION_ID_CONFIG"><code>APPLICATION_ID_CONFIG</code></a>, "queryableStoreName" is the
 provide <code>queryableStoreName</code>, and "-changelog" is a fixed suffix.
 The store name must be a valid Kafka topic name and cannot contain characters other than ASCII alphanumerics,
 '.', '_' and '-'.
 You can retrieve all generated internal topic names via <a href="../../../../../org/apache/kafka/streams/KafkaStreams.html#toString--"><code>KafkaStreams.toString()</code></a>.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>queryableStoreName</code> - the name of the underlying <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> state store; valid characters are ASCII
 alphanumerics, '.', '_' and '-'. If <code>null</code> this is the equivalent of <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html#count--"><code>count()</code></a>.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> that contains "update" records with unmodified keys and <code>Long</code> values that
 represent the latest (rolling) count (i.e., number of records) for each key</dd>
</dl>
</li>
</ul>
<a name="count-org.apache.kafka.streams.kstream.Materialized-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>count</h4>
<pre><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html" title="type parameter in KGroupedTable">K</a>,java.lang.Long&gt;&nbsp;count&#8203;(<a href="../../../../../org/apache/kafka/streams/kstream/Materialized.html" title="class in org.apache.kafka.streams.kstream">Materialized</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html" title="type parameter in KGroupedTable">K</a>,java.lang.Long,<a href="../../../../../org/apache/kafka/streams/state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state">KeyValueStore</a>&lt;org.apache.kafka.common.utils.Bytes,byte[]&gt;&gt;&nbsp;materialized)</pre>
<div class="block">Count number of records of the original <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> that got <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#groupBy-org.apache.kafka.streams.kstream.KeyValueMapper-"><code>mapped</code></a> to
 the same key into a new instance of <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a>.
 Records with <code>null</code> key are ignored.
 The result is written into a local <a href="../../../../../org/apache/kafka/streams/state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state"><code>KeyValueStore</code></a> (which is basically an ever-updating materialized view)
 that can be queried using the provided <code>queryableStoreName</code>.
 Furthermore, updates to the store are sent downstream into a <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> changelog stream.
 <p>
 Not all updates might get sent downstream, as an internal cache is used to deduplicate consecutive updates to
 the same key.
 The rate of propagated updates depends on your input data rate, the number of distinct keys, the number of
 parallel running Kafka Streams instances, and the <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html" title="class in org.apache.kafka.streams"><code>configuration</code></a> parameters for
 <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html#CACHE_MAX_BYTES_BUFFERING_CONFIG"><code>cache size</code></a>, and
 <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html#COMMIT_INTERVAL_MS_CONFIG"><code>commit intervall</code></a>.
 <p>
 To query the local <a href="../../../../../org/apache/kafka/streams/state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state"><code>KeyValueStore</code></a> it must be obtained via
 <a href="../../../../../org/apache/kafka/streams/KafkaStreams.html#store-java.lang.String-org.apache.kafka.streams.state.QueryableStoreType-"><code>KafkaStreams#store(...)</code></a>:
 <pre><code>
 KafkaStreams streams = ... // counting words
 ReadOnlyKeyValueStore&lt;String,Long&gt; localStore = streams.store(queryableStoreName, QueryableStoreTypes.&lt;String, Long&gt;keyValueStore());
 String key = "some-word";
 Long countForWord = localStore.get(key); // key must be local (application state is shared over all running Kafka Streams instances)
 </code></pre>
 For non-local keys, a custom RPC mechanism must be implemented using <a href="../../../../../org/apache/kafka/streams/KafkaStreams.html#allMetadata--"><code>KafkaStreams.allMetadata()</code></a> to
 query the value of the key on a parallel running instance of your Kafka Streams application.
 <p>
 For failure and recovery the store will be backed by an internal changelog topic that will be created in Kafka.
 The changelog topic will be named "${applicationId}-${queryableStoreName}-changelog", where "applicationId" is
 user-specified in <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html" title="class in org.apache.kafka.streams"><code>StreamsConfig</code></a> via parameter
 <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html#APPLICATION_ID_CONFIG"><code>APPLICATION_ID_CONFIG</code></a>, "queryableStoreName" is the
 provide <code>queryableStoreName</code>, and "-changelog" is a fixed suffix.
 The store name must be a valid Kafka topic name and cannot contain characters other than ASCII alphanumerics,
 '.', '_' and '-'.
 You can retrieve all generated internal topic names via <a href="../../../../../org/apache/kafka/streams/KafkaStreams.html#toString--"><code>KafkaStreams.toString()</code></a>.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>materialized</code> - the instance of <a href="../../../../../org/apache/kafka/streams/kstream/Materialized.html" title="class in org.apache.kafka.streams.kstream"><code>Materialized</code></a> used to materialize the state store. Cannot be <code>null</code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> that contains "update" records with unmodified keys and <code>Long</code> values that
 represent the latest (rolling) count (i.e., number of records) for each key</dd>
</dl>
</li>
</ul>
<a name="count--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>count</h4>
<pre><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html" title="type parameter in KGroupedTable">K</a>,java.lang.Long&gt;&nbsp;count&#8203;()</pre>
<div class="block">Count number of records of the original <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> that got <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#groupBy-org.apache.kafka.streams.kstream.KeyValueMapper-"><code>mapped</code></a> to
 the same key into a new instance of <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a>.
 Records with <code>null</code> key are ignored.
 The result is written into a local <a href="../../../../../org/apache/kafka/streams/state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state"><code>KeyValueStore</code></a> (which is basically an ever-updating materialized view)
 that can be queried using the provided <code>queryableStoreName</code>.
 Furthermore, updates to the store are sent downstream into a <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> changelog stream.
 <p>
 Not all updates might get sent downstream, as an internal cache is used to deduplicate consecutive updates to
 the same key.
 The rate of propagated updates depends on your input data rate, the number of distinct keys, the number of
 parallel running Kafka Streams instances, and the <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html" title="class in org.apache.kafka.streams"><code>configuration</code></a> parameters for
 <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html#CACHE_MAX_BYTES_BUFFERING_CONFIG"><code>cache size</code></a>, and
 <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html#COMMIT_INTERVAL_MS_CONFIG"><code>commit intervall</code></a>.
 <p>
 For failure and recovery the store will be backed by an internal changelog topic that will be created in Kafka.
 The changelog topic will be named "${applicationId}-${internalStoreName}-changelog", where "applicationId" is
 user-specified in <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html" title="class in org.apache.kafka.streams"><code>StreamsConfig</code></a> via parameter
 <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html#APPLICATION_ID_CONFIG"><code>APPLICATION_ID_CONFIG</code></a>, "internalStoreName" is an internal name
 and "-changelog" is a fixed suffix.
 Note that the internal store name may not be queriable through Interactive Queries.
 You can retrieve all generated internal topic names via <a href="../../../../../org/apache/kafka/streams/KafkaStreams.html#toString--"><code>KafkaStreams.toString()</code></a>.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> that contains "update" records with unmodified keys and <code>Long</code> values that
 represent the latest (rolling) count (i.e., number of records) for each key</dd>
</dl>
</li>
</ul>
<a name="count-org.apache.kafka.streams.processor.StateStoreSupplier-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>count</h4>
<pre>@Deprecated
<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html" title="type parameter in KGroupedTable">K</a>,java.lang.Long&gt;&nbsp;count&#8203;(<a href="../../../../../org/apache/kafka/streams/processor/StateStoreSupplier.html" title="interface in org.apache.kafka.streams.processor">StateStoreSupplier</a>&lt;<a href="../../../../../org/apache/kafka/streams/state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state">KeyValueStore</a>&gt;&nbsp;storeSupplier)</pre>
<div class="block"><span class="deprecatedLabel">Deprecated.</span>&nbsp;<span class="deprecationComment">use <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html#count-org.apache.kafka.streams.kstream.Materialized-"><code>count(Materialized.as(KeyValueByteStoreSupplier)</code></a></span></div>
<div class="block">Count number of records of the original <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> that got <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#groupBy-org.apache.kafka.streams.kstream.KeyValueMapper-"><code>mapped</code></a> to
 the same key into a new instance of <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a>.
 Records with <code>null</code> key are ignored.
 The result is written into a local <a href="../../../../../org/apache/kafka/streams/state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state"><code>KeyValueStore</code></a> (which is basically an ever-updating materialized view)
 provided by the given <code>storeSupplier</code>.
 Furthermore, updates to the store are sent downstream into a <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> changelog stream.
 <p>
 Not all updates might get sent downstream, as an internal cache is used to deduplicate consecutive updates to
 the same key.
 The rate of propagated updates depends on your input data rate, the number of distinct keys, the number of
 parallel running Kafka Streams instances, and the <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html" title="class in org.apache.kafka.streams"><code>configuration</code></a> parameters for
 <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html#CACHE_MAX_BYTES_BUFFERING_CONFIG"><code>cache size</code></a>, and
 <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html#COMMIT_INTERVAL_MS_CONFIG"><code>commit intervall</code></a>.
 <p>
 To query the local <a href="../../../../../org/apache/kafka/streams/state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state"><code>KeyValueStore</code></a> it must be obtained via
 <a href="../../../../../org/apache/kafka/streams/KafkaStreams.html#store-java.lang.String-org.apache.kafka.streams.state.QueryableStoreType-"><code>KafkaStreams#store(...)</code></a>:
 <pre><code>
 KafkaStreams streams = ... // counting words
 String queryableStoreName = storeSupplier.name();
 ReadOnlyKeyValueStore&lt;String,Long&gt; localStore = streams.store(queryableStoreName, QueryableStoreTypes.&lt;String, Long&gt;keyValueStore());
 String key = "some-word";
 Long countForWord = localStore.get(key); // key must be local (application state is shared over all running Kafka Streams instances)
 </code></pre>
 For non-local keys, a custom RPC mechanism must be implemented using <a href="../../../../../org/apache/kafka/streams/KafkaStreams.html#allMetadata--"><code>KafkaStreams.allMetadata()</code></a> to
 query the value of the key on a parallel running instance of your Kafka Streams application.
 <p>
 For failure and recovery the store will be backed by an internal changelog topic that will be created in Kafka.
 The changelog topic will be named "${applicationId}-${queryableStoreName}-changelog", where "applicationId" is
 user-specified in <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html" title="class in org.apache.kafka.streams"><code>StreamsConfig</code></a> via parameter
 <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html#APPLICATION_ID_CONFIG"><code>APPLICATION_ID_CONFIG</code></a>, "queryableStoreName" is the
 provide <code>queryableStoreName</code>, and "-changelog" is a fixed suffix.
 You can retrieve all generated internal topic names via <a href="../../../../../org/apache/kafka/streams/KafkaStreams.html#toString--"><code>KafkaStreams.toString()</code></a>.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>storeSupplier</code> - user defined state store supplier. Cannot be <code>null</code>.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> that contains "update" records with unmodified keys and <code>Long</code> values that
 represent the latest (rolling) count (i.e., number of records) for each key</dd>
</dl>
</li>
</ul>
<a name="reduce-org.apache.kafka.streams.kstream.Reducer-org.apache.kafka.streams.kstream.Reducer-java.lang.String-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>reduce</h4>
<pre>@Deprecated
<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html" title="type parameter in KGroupedTable">K</a>,<a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html" title="type parameter in KGroupedTable">V</a>&gt;&nbsp;reduce&#8203;(<a href="../../../../../org/apache/kafka/streams/kstream/Reducer.html" title="interface in org.apache.kafka.streams.kstream">Reducer</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html" title="type parameter in KGroupedTable">V</a>&gt;&nbsp;adder,
                   <a href="../../../../../org/apache/kafka/streams/kstream/Reducer.html" title="interface in org.apache.kafka.streams.kstream">Reducer</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html" title="type parameter in KGroupedTable">V</a>&gt;&nbsp;subtractor,
                   java.lang.String&nbsp;queryableStoreName)</pre>
<div class="block"><span class="deprecatedLabel">Deprecated.</span>&nbsp;<span class="deprecationComment">use <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html#reduce-org.apache.kafka.streams.kstream.Reducer-org.apache.kafka.streams.kstream.Reducer-org.apache.kafka.streams.kstream.Materialized-"><code>reduce(adder, subtractor, Materialized.as(queryableStoreName))</code></a></span></div>
<div class="block">Combine the value of records of the original <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> that got <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#groupBy-org.apache.kafka.streams.kstream.KeyValueMapper-"><code>mapped</code></a> to the same key into a new instance of <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a>.
 Records with <code>null</code> key are ignored.
 Combining implies that the type of the aggregate result is the same as the type of the input value
 (c.f. <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html#aggregate-org.apache.kafka.streams.kstream.Initializer-org.apache.kafka.streams.kstream.Aggregator-org.apache.kafka.streams.kstream.Aggregator-org.apache.kafka.common.serialization.Serde-java.lang.String-"><code>aggregate(Initializer, Aggregator, Aggregator, Serde, String)</code></a>).
 The result is written into a local <a href="../../../../../org/apache/kafka/streams/state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state"><code>KeyValueStore</code></a> (which is basically an ever-updating materialized view)
 that can be queried using the provided <code>queryableStoreName</code>.
 Furthermore, updates to the store are sent downstream into a <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> changelog stream.
 <p>
 Each update to the original <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> results in a two step update of the result <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a>.
 The specified <a href="../../../../../org/apache/kafka/streams/kstream/Reducer.html" title="interface in org.apache.kafka.streams.kstream"><code>adder</code></a> is applied for each update record and computes a new aggregate using the
 current aggregate (first argument) and the record's value (second argument) by adding the new record to the
 aggregate.
 The specified <a href="../../../../../org/apache/kafka/streams/kstream/Reducer.html" title="interface in org.apache.kafka.streams.kstream"><code>substractor</code></a> is applied for each "replaced" record of the original <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a>
 and computes a new aggregate using the current aggregate (first argument) and the record's value (second
 argument) by "removing" the "replaced" record from the aggregate.
 If there is no current aggregate the <a href="../../../../../org/apache/kafka/streams/kstream/Reducer.html" title="interface in org.apache.kafka.streams.kstream"><code>Reducer</code></a> is not applied and the new aggregate will be the record's
 value as-is.
 Thus, <code>reduce(Reducer, Reducer, String)</code> can be used to compute aggregate functions like sum.
 For sum, the adder and substractor would work as follows:
 <pre><code>
 public class SumAdder implements Reducer&lt;Integer&gt; {
   public Integer apply(Integer currentAgg, Integer newValue) {
     return currentAgg + newValue;
   }
 }

 public class SumSubtractor implements Reducer&lt;Integer&gt; {
   public Integer apply(Integer currentAgg, Integer oldValue) {
     return currentAgg - oldValue;
   }
 }
 </code></pre>
 Not all updates might get sent downstream, as an internal cache is used to deduplicate consecutive updates to
 the same key.
 The rate of propagated updates depends on your input data rate, the number of distinct keys, the number of
 parallel running Kafka Streams instances, and the <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html" title="class in org.apache.kafka.streams"><code>configuration</code></a> parameters for
 <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html#CACHE_MAX_BYTES_BUFFERING_CONFIG"><code>cache size</code></a>, and
 <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html#COMMIT_INTERVAL_MS_CONFIG"><code>commit intervall</code></a>.
 <p>
 To query the local <a href="../../../../../org/apache/kafka/streams/state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state"><code>KeyValueStore</code></a> it must be obtained via
 <a href="../../../../../org/apache/kafka/streams/KafkaStreams.html#store-java.lang.String-org.apache.kafka.streams.state.QueryableStoreType-"><code>KafkaStreams#store(...)</code></a>:
 <pre><code>
 KafkaStreams streams = ... // counting words
 ReadOnlyKeyValueStore&lt;String,Long&gt; localStore = streams.store(queryableStoreName, QueryableStoreTypes.&lt;String, Long&gt;keyValueStore());
 String key = "some-word";
 Long countForWord = localStore.get(key); // key must be local (application state is shared over all running Kafka Streams instances)
 </code></pre>
 For non-local keys, a custom RPC mechanism must be implemented using <a href="../../../../../org/apache/kafka/streams/KafkaStreams.html#allMetadata--"><code>KafkaStreams.allMetadata()</code></a> to
 query the value of the key on a parallel running instance of your Kafka Streams application.
 <p>
 For failure and recovery the store will be backed by an internal changelog topic that will be created in Kafka.
 The changelog topic will be named "${applicationId}-${queryableStoreName}-changelog", where "applicationId" is
 user-specified in <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html" title="class in org.apache.kafka.streams"><code>StreamsConfig</code></a> via parameter
 <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html#APPLICATION_ID_CONFIG"><code>APPLICATION_ID_CONFIG</code></a>, "queryableStoreName" is the
 provide <code>queryableStoreName</code>, and "-changelog" is a fixed suffix.
 The store name must be a valid Kafka topic name and cannot contain characters other than ASCII alphanumerics,
 '.', '_' and '-'.
 You can retrieve all generated internal topic names via <a href="../../../../../org/apache/kafka/streams/KafkaStreams.html#toString--"><code>KafkaStreams.toString()</code></a>.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>adder</code> - a <a href="../../../../../org/apache/kafka/streams/kstream/Reducer.html" title="interface in org.apache.kafka.streams.kstream"><code>Reducer</code></a> that adds a new value to the aggregate result</dd>
<dd><code>subtractor</code> - a <a href="../../../../../org/apache/kafka/streams/kstream/Reducer.html" title="interface in org.apache.kafka.streams.kstream"><code>Reducer</code></a> that removed an old value from the aggregate result</dd>
<dd><code>queryableStoreName</code> - the name of the underlying <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> state store; valid characters are ASCII alphanumerics,
 '.', '_' and '-'. If <code>null</code> this is the equivalent of <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html#reduce-org.apache.kafka.streams.kstream.Reducer-org.apache.kafka.streams.kstream.Reducer-"><code>reduce(Reducer, Reducer)</code></a> ()}.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> that contains "update" records with unmodified keys, and values that represent the
 latest (rolling) aggregate for each key</dd>
</dl>
</li>
</ul>
<a name="reduce-org.apache.kafka.streams.kstream.Reducer-org.apache.kafka.streams.kstream.Reducer-org.apache.kafka.streams.kstream.Materialized-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>reduce</h4>
<pre><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html" title="type parameter in KGroupedTable">K</a>,<a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html" title="type parameter in KGroupedTable">V</a>&gt;&nbsp;reduce&#8203;(<a href="../../../../../org/apache/kafka/streams/kstream/Reducer.html" title="interface in org.apache.kafka.streams.kstream">Reducer</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html" title="type parameter in KGroupedTable">V</a>&gt;&nbsp;adder,
                   <a href="../../../../../org/apache/kafka/streams/kstream/Reducer.html" title="interface in org.apache.kafka.streams.kstream">Reducer</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html" title="type parameter in KGroupedTable">V</a>&gt;&nbsp;subtractor,
                   <a href="../../../../../org/apache/kafka/streams/kstream/Materialized.html" title="class in org.apache.kafka.streams.kstream">Materialized</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html" title="type parameter in KGroupedTable">K</a>,<a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html" title="type parameter in KGroupedTable">V</a>,<a href="../../../../../org/apache/kafka/streams/state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state">KeyValueStore</a>&lt;org.apache.kafka.common.utils.Bytes,byte[]&gt;&gt;&nbsp;materialized)</pre>
<div class="block">Combine the value of records of the original <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> that got <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#groupBy-org.apache.kafka.streams.kstream.KeyValueMapper-"><code>mapped</code></a> to the same key into a new instance of <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a>.
 Records with <code>null</code> key are ignored.
 Combining implies that the type of the aggregate result is the same as the type of the input value
 (c.f. <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html#aggregate-org.apache.kafka.streams.kstream.Initializer-org.apache.kafka.streams.kstream.Aggregator-org.apache.kafka.streams.kstream.Aggregator-org.apache.kafka.streams.kstream.Materialized-"><code>aggregate(Initializer, Aggregator, Aggregator, Materialized)</code></a>).
 The result is written into a local <a href="../../../../../org/apache/kafka/streams/state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state"><code>KeyValueStore</code></a> (which is basically an ever-updating materialized view)
 that can be queried using the provided <code>queryableStoreName</code>.
 Furthermore, updates to the store are sent downstream into a <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> changelog stream.
 <p>
 Each update to the original <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> results in a two step update of the result <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a>.
 The specified <a href="../../../../../org/apache/kafka/streams/kstream/Reducer.html" title="interface in org.apache.kafka.streams.kstream"><code>adder</code></a> is applied for each update record and computes a new aggregate using the
 current aggregate (first argument) and the record's value (second argument) by adding the new record to the
 aggregate.
 The specified <a href="../../../../../org/apache/kafka/streams/kstream/Reducer.html" title="interface in org.apache.kafka.streams.kstream"><code>substractor</code></a> is applied for each "replaced" record of the original <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a>
 and computes a new aggregate using the current aggregate (first argument) and the record's value (second
 argument) by "removing" the "replaced" record from the aggregate.
 If there is no current aggregate the <a href="../../../../../org/apache/kafka/streams/kstream/Reducer.html" title="interface in org.apache.kafka.streams.kstream"><code>Reducer</code></a> is not applied and the new aggregate will be the record's
 value as-is.
 Thus, <code>reduce(Reducer, Reducer, String)</code> can be used to compute aggregate functions like sum.
 For sum, the adder and substractor would work as follows:
 <pre><code>
 public class SumAdder implements Reducer&lt;Integer&gt; {
   public Integer apply(Integer currentAgg, Integer newValue) {
     return currentAgg + newValue;
   }
 }

 public class SumSubtractor implements Reducer&lt;Integer&gt; {
   public Integer apply(Integer currentAgg, Integer oldValue) {
     return currentAgg - oldValue;
   }
 }
 </code></pre>
 Not all updates might get sent downstream, as an internal cache is used to deduplicate consecutive updates to
 the same key.
 The rate of propagated updates depends on your input data rate, the number of distinct keys, the number of
 parallel running Kafka Streams instances, and the <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html" title="class in org.apache.kafka.streams"><code>configuration</code></a> parameters for
 <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html#CACHE_MAX_BYTES_BUFFERING_CONFIG"><code>cache size</code></a>, and
 <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html#COMMIT_INTERVAL_MS_CONFIG"><code>commit intervall</code></a>.
 <p>
 To query the local <a href="../../../../../org/apache/kafka/streams/state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state"><code>KeyValueStore</code></a> it must be obtained via
 <a href="../../../../../org/apache/kafka/streams/KafkaStreams.html#store-java.lang.String-org.apache.kafka.streams.state.QueryableStoreType-"><code>KafkaStreams#store(...)</code></a>:
 <pre><code>
 KafkaStreams streams = ... // counting words
 ReadOnlyKeyValueStore&lt;String,Long&gt; localStore = streams.store(queryableStoreName, QueryableStoreTypes.&lt;String, Long&gt;keyValueStore());
 String key = "some-word";
 Long countForWord = localStore.get(key); // key must be local (application state is shared over all running Kafka Streams instances)
 </code></pre>
 For non-local keys, a custom RPC mechanism must be implemented using <a href="../../../../../org/apache/kafka/streams/KafkaStreams.html#allMetadata--"><code>KafkaStreams.allMetadata()</code></a> to
 query the value of the key on a parallel running instance of your Kafka Streams application.
 <p>
 For failure and recovery the store will be backed by an internal changelog topic that will be created in Kafka.
 The changelog topic will be named "${applicationId}-${queryableStoreName}-changelog", where "applicationId" is
 user-specified in <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html" title="class in org.apache.kafka.streams"><code>StreamsConfig</code></a> via parameter
 <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html#APPLICATION_ID_CONFIG"><code>APPLICATION_ID_CONFIG</code></a>, "queryableStoreName" is the
 provide <code>queryableStoreName</code>, and "-changelog" is a fixed suffix.
 The store name must be a valid Kafka topic name and cannot contain characters other than ASCII alphanumerics,
 '.', '_' and '-'.
 You can retrieve all generated internal topic names via <a href="../../../../../org/apache/kafka/streams/KafkaStreams.html#toString--"><code>KafkaStreams.toString()</code></a>.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>adder</code> - a <a href="../../../../../org/apache/kafka/streams/kstream/Reducer.html" title="interface in org.apache.kafka.streams.kstream"><code>Reducer</code></a> that adds a new value to the aggregate result</dd>
<dd><code>subtractor</code> - a <a href="../../../../../org/apache/kafka/streams/kstream/Reducer.html" title="interface in org.apache.kafka.streams.kstream"><code>Reducer</code></a> that removed an old value from the aggregate result</dd>
<dd><code>materialized</code> - the instance of <a href="../../../../../org/apache/kafka/streams/kstream/Materialized.html" title="class in org.apache.kafka.streams.kstream"><code>Materialized</code></a> used to materialize the state store. Cannot be <code>null</code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> that contains "update" records with unmodified keys, and values that represent the
 latest (rolling) aggregate for each key</dd>
</dl>
</li>
</ul>
<a name="reduce-org.apache.kafka.streams.kstream.Reducer-org.apache.kafka.streams.kstream.Reducer-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>reduce</h4>
<pre><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html" title="type parameter in KGroupedTable">K</a>,<a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html" title="type parameter in KGroupedTable">V</a>&gt;&nbsp;reduce&#8203;(<a href="../../../../../org/apache/kafka/streams/kstream/Reducer.html" title="interface in org.apache.kafka.streams.kstream">Reducer</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html" title="type parameter in KGroupedTable">V</a>&gt;&nbsp;adder,
                   <a href="../../../../../org/apache/kafka/streams/kstream/Reducer.html" title="interface in org.apache.kafka.streams.kstream">Reducer</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html" title="type parameter in KGroupedTable">V</a>&gt;&nbsp;subtractor)</pre>
<div class="block">Combine the value of records of the original <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> that got <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#groupBy-org.apache.kafka.streams.kstream.KeyValueMapper-"><code>mapped</code></a> to the same key into a new instance of <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a>.
 Records with <code>null</code> key are ignored.
 Combining implies that the type of the aggregate result is the same as the type of the input value
 (c.f. <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html#aggregate-org.apache.kafka.streams.kstream.Initializer-org.apache.kafka.streams.kstream.Aggregator-org.apache.kafka.streams.kstream.Aggregator-"><code>aggregate(Initializer, Aggregator, Aggregator)</code></a>).
 The result is written into a local <a href="../../../../../org/apache/kafka/streams/state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state"><code>KeyValueStore</code></a> (which is basically an ever-updating materialized view)
 that can be queried using the provided <code>queryableStoreName</code>.
 Furthermore, updates to the store are sent downstream into a <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> changelog stream.
 <p>
 Each update to the original <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> results in a two step update of the result <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a>.
 The specified <a href="../../../../../org/apache/kafka/streams/kstream/Reducer.html" title="interface in org.apache.kafka.streams.kstream"><code>adder</code></a> is applied for each update record and computes a new aggregate using the
 current aggregate and the record's value by adding the new record to the aggregate.
 The specified <a href="../../../../../org/apache/kafka/streams/kstream/Reducer.html" title="interface in org.apache.kafka.streams.kstream"><code>substractor</code></a> is applied for each "replaced" record of the original <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a>
 and computes a new aggregate using the current aggregate and the record's value by "removing" the "replaced"
 record from the aggregate.
 If there is no current aggregate the <a href="../../../../../org/apache/kafka/streams/kstream/Reducer.html" title="interface in org.apache.kafka.streams.kstream"><code>Reducer</code></a> is not applied and the new aggregate will be the record's
 value as-is.
 Thus, <code>reduce(Reducer, Reducer, String)</code> can be used to compute aggregate functions like sum.
 For sum, the adder and substractor would work as follows:
 <pre><code>
 public class SumAdder implements Reducer&lt;Integer&gt; {
   public Integer apply(Integer currentAgg, Integer newValue) {
     return currentAgg + newValue;
   }
 }

 public class SumSubtractor implements Reducer&lt;Integer&gt; {
   public Integer apply(Integer currentAgg, Integer oldValue) {
     return currentAgg - oldValue;
   }
 }
 </code></pre>
 Not all updates might get sent downstream, as an internal cache is used to deduplicate consecutive updates to
 the same key.
 The rate of propagated updates depends on your input data rate, the number of distinct keys, the number of
 parallel running Kafka Streams instances, and the <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html" title="class in org.apache.kafka.streams"><code>configuration</code></a> parameters for
 <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html#CACHE_MAX_BYTES_BUFFERING_CONFIG"><code>cache size</code></a>, and
 <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html#COMMIT_INTERVAL_MS_CONFIG"><code>commit intervall</code></a>.
 <p>
 For failure and recovery the store will be backed by an internal changelog topic that will be created in Kafka.
 The changelog topic will be named "${applicationId}-${internalStoreName}-changelog", where "applicationId" is
 user-specified in <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html" title="class in org.apache.kafka.streams"><code>StreamsConfig</code></a> via parameter
 <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html#APPLICATION_ID_CONFIG"><code>APPLICATION_ID_CONFIG</code></a>, "internalStoreName" is an internal name
 and "-changelog" is a fixed suffix.
 Note that the internal store name may not be queriable through Interactive Queries.
 You can retrieve all generated internal topic names via <a href="../../../../../org/apache/kafka/streams/KafkaStreams.html#toString--"><code>KafkaStreams.toString()</code></a>.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>adder</code> - a <a href="../../../../../org/apache/kafka/streams/kstream/Reducer.html" title="interface in org.apache.kafka.streams.kstream"><code>Reducer</code></a> that adds a new value to the aggregate result</dd>
<dd><code>subtractor</code> - a <a href="../../../../../org/apache/kafka/streams/kstream/Reducer.html" title="interface in org.apache.kafka.streams.kstream"><code>Reducer</code></a> that removed an old value from the aggregate result</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> that contains "update" records with unmodified keys, and values that represent the
 latest (rolling) aggregate for each key</dd>
</dl>
</li>
</ul>
<a name="reduce-org.apache.kafka.streams.kstream.Reducer-org.apache.kafka.streams.kstream.Reducer-org.apache.kafka.streams.processor.StateStoreSupplier-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>reduce</h4>
<pre>@Deprecated
<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html" title="type parameter in KGroupedTable">K</a>,<a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html" title="type parameter in KGroupedTable">V</a>&gt;&nbsp;reduce&#8203;(<a href="../../../../../org/apache/kafka/streams/kstream/Reducer.html" title="interface in org.apache.kafka.streams.kstream">Reducer</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html" title="type parameter in KGroupedTable">V</a>&gt;&nbsp;adder,
                   <a href="../../../../../org/apache/kafka/streams/kstream/Reducer.html" title="interface in org.apache.kafka.streams.kstream">Reducer</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html" title="type parameter in KGroupedTable">V</a>&gt;&nbsp;subtractor,
                   <a href="../../../../../org/apache/kafka/streams/processor/StateStoreSupplier.html" title="interface in org.apache.kafka.streams.processor">StateStoreSupplier</a>&lt;<a href="../../../../../org/apache/kafka/streams/state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state">KeyValueStore</a>&gt;&nbsp;storeSupplier)</pre>
<div class="block"><span class="deprecatedLabel">Deprecated.</span>&nbsp;<span class="deprecationComment">use <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html#reduce-org.apache.kafka.streams.kstream.Reducer-org.apache.kafka.streams.kstream.Reducer-org.apache.kafka.streams.kstream.Materialized-"><code>reduce(adder, subtractor, Materialized.as(KeyValueByteStoreSupplier))</code></a></span></div>
<div class="block">Combine the value of records of the original <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> that got <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#groupBy-org.apache.kafka.streams.kstream.KeyValueMapper-"><code>mapped</code></a> to the same key into a new instance of <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a>.
 Records with <code>null</code> key are ignored.
 Combining implies that the type of the aggregate result is the same as the type of the input value
 (c.f. <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html#aggregate-org.apache.kafka.streams.kstream.Initializer-org.apache.kafka.streams.kstream.Aggregator-org.apache.kafka.streams.kstream.Aggregator-org.apache.kafka.common.serialization.Serde-java.lang.String-"><code>aggregate(Initializer, Aggregator, Aggregator, Serde, String)</code></a>).
 The result is written into a local <a href="../../../../../org/apache/kafka/streams/state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state"><code>KeyValueStore</code></a> (which is basically an ever-updating materialized view)
 provided by the given <code>storeSupplier</code>.
 Furthermore, updates to the store are sent downstream into a <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> changelog stream.
 <p>
 Each update to the original <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> results in a two step update of the result <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a>.
 The specified <a href="../../../../../org/apache/kafka/streams/kstream/Reducer.html" title="interface in org.apache.kafka.streams.kstream"><code>adder</code></a> is applied for each update record and computes a new aggregate using the
 current aggregate (first argument) and the record's value (second argument) by adding the new record to the
 aggregate.
 The specified <a href="../../../../../org/apache/kafka/streams/kstream/Reducer.html" title="interface in org.apache.kafka.streams.kstream"><code>substractor</code></a> is applied for each "replaced" record of the original <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a>
 and computes a new aggregate using the current aggregate (first argument) and the record's value (second
 argument) by "removing" the "replaced" record from the aggregate.
 If there is no current aggregate the <a href="../../../../../org/apache/kafka/streams/kstream/Reducer.html" title="interface in org.apache.kafka.streams.kstream"><code>Reducer</code></a> is not applied and the new aggregate will be the record's
 value as-is.
 Thus, <code>reduce(Reducer, Reducer, String)</code> can be used to compute aggregate functions like sum.
 For sum, the adder and substractor would work as follows:
 <pre><code>
 public class SumAdder implements Reducer&lt;Integer&gt; {
   public Integer apply(Integer currentAgg, Integer newValue) {
     return currentAgg + newValue;
   }
 }

 public class SumSubtractor implements Reducer&lt;Integer&gt; {
   public Integer apply(Integer currentAgg, Integer oldValue) {
     return currentAgg - oldValue;
   }
 }
 </code></pre>
 Not all updates might get sent downstream, as an internal cache is used to deduplicate consecutive updates to
 the same key.
 The rate of propagated updates depends on your input data rate, the number of distinct keys, the number of
 parallel running Kafka Streams instances, and the <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html" title="class in org.apache.kafka.streams"><code>configuration</code></a> parameters for
 <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html#CACHE_MAX_BYTES_BUFFERING_CONFIG"><code>cache size</code></a>, and
 <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html#COMMIT_INTERVAL_MS_CONFIG"><code>commit intervall</code></a>.
 <p>
 To query the local <a href="../../../../../org/apache/kafka/streams/state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state"><code>KeyValueStore</code></a> it must be obtained via
 <a href="../../../../../org/apache/kafka/streams/KafkaStreams.html#store-java.lang.String-org.apache.kafka.streams.state.QueryableStoreType-"><code>KafkaStreams#store(...)</code></a>:
 <pre><code>
 KafkaStreams streams = ... // counting words
 String queryableStoreName = storeSupplier.name();
 ReadOnlyKeyValueStore&lt;String,Long&gt; localStore = streams.store(queryableStoreName, QueryableStoreTypes.&lt;String, Long&gt;keyValueStore());
 String key = "some-word";
 Long countForWord = localStore.get(key); // key must be local (application state is shared over all running Kafka Streams instances)
 </code></pre>
 For non-local keys, a custom RPC mechanism must be implemented using <a href="../../../../../org/apache/kafka/streams/KafkaStreams.html#allMetadata--"><code>KafkaStreams.allMetadata()</code></a> to
 query the value of the key on a parallel running instance of your Kafka Streams application.
 <p>
 For failure and recovery the store will be backed by an internal changelog topic that will be created in Kafka.
 The changelog topic will be named "${applicationId}-${queryableStoreName}-changelog", where "applicationId" is
 user-specified in <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html" title="class in org.apache.kafka.streams"><code>StreamsConfig</code></a> via parameter
 <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html#APPLICATION_ID_CONFIG"><code>APPLICATION_ID_CONFIG</code></a>, "queryableStoreName" is the
 provide <code>queryableStoreName</code>, and "-changelog" is a fixed suffix.
 You can retrieve all generated internal topic names via <a href="../../../../../org/apache/kafka/streams/KafkaStreams.html#toString--"><code>KafkaStreams.toString()</code></a>.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>adder</code> - a <a href="../../../../../org/apache/kafka/streams/kstream/Reducer.html" title="interface in org.apache.kafka.streams.kstream"><code>Reducer</code></a> that adds a new value to the aggregate result</dd>
<dd><code>subtractor</code> - a <a href="../../../../../org/apache/kafka/streams/kstream/Reducer.html" title="interface in org.apache.kafka.streams.kstream"><code>Reducer</code></a> that removed an old value from the aggregate result</dd>
<dd><code>storeSupplier</code> - user defined state store supplier. Cannot be <code>null</code>.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> that contains "update" records with unmodified keys, and values that represent the
 latest (rolling) aggregate for each key</dd>
</dl>
</li>
</ul>
<a name="aggregate-org.apache.kafka.streams.kstream.Initializer-org.apache.kafka.streams.kstream.Aggregator-org.apache.kafka.streams.kstream.Aggregator-java.lang.String-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>aggregate</h4>
<pre>@Deprecated
&lt;VR&gt;&nbsp;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html" title="type parameter in KGroupedTable">K</a>,VR&gt;&nbsp;aggregate&#8203;(<a href="../../../../../org/apache/kafka/streams/kstream/Initializer.html" title="interface in org.apache.kafka.streams.kstream">Initializer</a>&lt;VR&gt;&nbsp;initializer,
                            <a href="../../../../../org/apache/kafka/streams/kstream/Aggregator.html" title="interface in org.apache.kafka.streams.kstream">Aggregator</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html" title="type parameter in KGroupedTable">K</a>,? super <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html" title="type parameter in KGroupedTable">V</a>,VR&gt;&nbsp;adder,
                            <a href="../../../../../org/apache/kafka/streams/kstream/Aggregator.html" title="interface in org.apache.kafka.streams.kstream">Aggregator</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html" title="type parameter in KGroupedTable">K</a>,? super <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html" title="type parameter in KGroupedTable">V</a>,VR&gt;&nbsp;subtractor,
                            java.lang.String&nbsp;queryableStoreName)</pre>
<div class="block"><span class="deprecatedLabel">Deprecated.</span>&nbsp;<span class="deprecationComment">use <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html#aggregate-org.apache.kafka.streams.kstream.Initializer-org.apache.kafka.streams.kstream.Aggregator-org.apache.kafka.streams.kstream.Aggregator-org.apache.kafka.streams.kstream.Materialized-"><code>aggregate(initializer, adder, subtractor, Materialized.as(queryableStoreName))</code></a></span></div>
<div class="block">Aggregate the value of records of the original <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> that got <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#groupBy-org.apache.kafka.streams.kstream.KeyValueMapper-"><code>mapped</code></a> to the same key into a new instance of <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> using default serializers and deserializers.
 Records with <code>null</code> key are ignored.
 Aggregating is a generalization of <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html#reduce-org.apache.kafka.streams.kstream.Reducer-org.apache.kafka.streams.kstream.Reducer-java.lang.String-"><code>combining via reduce(...)</code></a> as it,
 for example, allows the result to have a different type than the input values.
 If the result value type does not match the <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html#DEFAULT_VALUE_SERDE_CLASS_CONFIG"><code>default value
 serde</code></a> you should use <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html#aggregate-org.apache.kafka.streams.kstream.Initializer-org.apache.kafka.streams.kstream.Aggregator-org.apache.kafka.streams.kstream.Aggregator-org.apache.kafka.common.serialization.Serde-java.lang.String-"><code>aggregate(Initializer, Aggregator, Aggregator, Serde, String)</code></a>.
 The result is written into a local <a href="../../../../../org/apache/kafka/streams/state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state"><code>KeyValueStore</code></a> (which is basically an ever-updating materialized view)
 provided by the given <code>storeSupplier</code>.
 Furthermore, updates to the store are sent downstream into a <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> changelog stream.
 <p>
 The specified <a href="../../../../../org/apache/kafka/streams/kstream/Initializer.html" title="interface in org.apache.kafka.streams.kstream"><code>Initializer</code></a> is applied once directly before the first input record is processed to
 provide an initial intermediate aggregation result that is used to process the first record.
 Each update to the original <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> results in a two step update of the result <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a>.
 The specified <a href="../../../../../org/apache/kafka/streams/kstream/Aggregator.html" title="interface in org.apache.kafka.streams.kstream"><code>adder</code></a> is applied for each update record and computes a new aggregate using the
 current aggregate (or for the very first record using the intermediate aggregation result provided via the
 <a href="../../../../../org/apache/kafka/streams/kstream/Initializer.html" title="interface in org.apache.kafka.streams.kstream"><code>Initializer</code></a>) and the record's value by adding the new record to the aggregate.
 The specified <a href="../../../../../org/apache/kafka/streams/kstream/Aggregator.html" title="interface in org.apache.kafka.streams.kstream"><code>substractor</code></a> is applied for each "replaced" record of the original <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a>
 and computes a new aggregate using the current aggregate and the record's value by "removing" the "replaced"
 record from the aggregate.
 Thus, <code>aggregate(Initializer, Aggregator, Aggregator, String)</code> can be used to compute aggregate functions
 like sum.
 For sum, the initializer, adder, and substractor would work as follows:
 <pre><code>
 // in this example, LongSerde.class must be set as default value serde in StreamsConfig
 public class SumInitializer implements Initializer&lt;Long&gt; {
   public Long apply() {
     return 0L;
   }
 }

 public class SumAdder implements Aggregator&lt;String, Integer, Long&gt; {
   public Long apply(String key, Integer newValue, Long aggregate) {
     return aggregate + newValue;
   }
 }

 public class SumSubstractor implements Aggregator&lt;String, Integer, Long&gt; {
   public Long apply(String key, Integer oldValue, Long aggregate) {
     return aggregate - oldValue;
   }
 }
 </code></pre>
 Not all updates might get sent downstream, as an internal cache is used to deduplicate consecutive updates to
 the same key.
 The rate of propagated updates depends on your input data rate, the number of distinct keys, the number of
 parallel running Kafka Streams instances, and the <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html" title="class in org.apache.kafka.streams"><code>configuration</code></a> parameters for
 <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html#CACHE_MAX_BYTES_BUFFERING_CONFIG"><code>cache size</code></a>, and
 <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html#COMMIT_INTERVAL_MS_CONFIG"><code>commit intervall</code></a>.
 <p>
 To query the local <a href="../../../../../org/apache/kafka/streams/state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state"><code>KeyValueStore</code></a> it must be obtained via
 <a href="../../../../../org/apache/kafka/streams/KafkaStreams.html#store-java.lang.String-org.apache.kafka.streams.state.QueryableStoreType-"><code>KafkaStreams#store(...)</code></a>:
 <pre><code>
 KafkaStreams streams = ... // counting words
 ReadOnlyKeyValueStore&lt;String,Long&gt; localStore = streams.store(queryableStoreName, QueryableStoreTypes.&lt;String, Long&gt;keyValueStore());
 String key = "some-word";
 Long countForWord = localStore.get(key); // key must be local (application state is shared over all running Kafka Streams instances)
 </code></pre>
 For non-local keys, a custom RPC mechanism must be implemented using <a href="../../../../../org/apache/kafka/streams/KafkaStreams.html#allMetadata--"><code>KafkaStreams.allMetadata()</code></a> to
 query the value of the key on a parallel running instance of your Kafka Streams application.
 <p>
 For failure and recovery the store will be backed by an internal changelog topic that will be created in Kafka.
 The changelog topic will be named "${applicationId}-${queryableStoreName}-changelog", where "applicationId" is
 user-specified in <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html" title="class in org.apache.kafka.streams"><code>StreamsConfig</code></a> via parameter
 <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html#APPLICATION_ID_CONFIG"><code>APPLICATION_ID_CONFIG</code></a>, "queryableStoreName" is the
 provide <code>queryableStoreName</code>, and "-changelog" is a fixed suffix.
 You can retrieve all generated internal topic names via <a href="../../../../../org/apache/kafka/streams/KafkaStreams.html#toString--"><code>KafkaStreams.toString()</code></a>.</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>VR</code> - the value type of the aggregated <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>initializer</code> - a <a href="../../../../../org/apache/kafka/streams/kstream/Initializer.html" title="interface in org.apache.kafka.streams.kstream"><code>Initializer</code></a> that provides an initial aggregate result value</dd>
<dd><code>adder</code> - a <a href="../../../../../org/apache/kafka/streams/kstream/Aggregator.html" title="interface in org.apache.kafka.streams.kstream"><code>Aggregator</code></a> that adds a new record to the aggregate result</dd>
<dd><code>subtractor</code> - a <a href="../../../../../org/apache/kafka/streams/kstream/Aggregator.html" title="interface in org.apache.kafka.streams.kstream"><code>Aggregator</code></a> that removed an old record from the aggregate result</dd>
<dd><code>queryableStoreName</code> - the name of the underlying <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> state store.
                             If <code>null</code> this is the equivalent of <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html#aggregate-org.apache.kafka.streams.kstream.Initializer-org.apache.kafka.streams.kstream.Aggregator-org.apache.kafka.streams.kstream.Aggregator-"><code>aggregate(Initializer, Aggregator, Aggregator)</code></a> ()}.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> that contains "update" records with unmodified keys, and values that represent the
 latest (rolling) aggregate for each key</dd>
</dl>
</li>
</ul>
<a name="aggregate-org.apache.kafka.streams.kstream.Initializer-org.apache.kafka.streams.kstream.Aggregator-org.apache.kafka.streams.kstream.Aggregator-org.apache.kafka.streams.kstream.Materialized-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>aggregate</h4>
<pre>&lt;VR&gt;&nbsp;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html" title="type parameter in KGroupedTable">K</a>,VR&gt;&nbsp;aggregate&#8203;(<a href="../../../../../org/apache/kafka/streams/kstream/Initializer.html" title="interface in org.apache.kafka.streams.kstream">Initializer</a>&lt;VR&gt;&nbsp;initializer,
                            <a href="../../../../../org/apache/kafka/streams/kstream/Aggregator.html" title="interface in org.apache.kafka.streams.kstream">Aggregator</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html" title="type parameter in KGroupedTable">K</a>,? super <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html" title="type parameter in KGroupedTable">V</a>,VR&gt;&nbsp;adder,
                            <a href="../../../../../org/apache/kafka/streams/kstream/Aggregator.html" title="interface in org.apache.kafka.streams.kstream">Aggregator</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html" title="type parameter in KGroupedTable">K</a>,? super <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html" title="type parameter in KGroupedTable">V</a>,VR&gt;&nbsp;subtractor,
                            <a href="../../../../../org/apache/kafka/streams/kstream/Materialized.html" title="class in org.apache.kafka.streams.kstream">Materialized</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html" title="type parameter in KGroupedTable">K</a>,VR,<a href="../../../../../org/apache/kafka/streams/state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state">KeyValueStore</a>&lt;org.apache.kafka.common.utils.Bytes,byte[]&gt;&gt;&nbsp;materialized)</pre>
<div class="block">Aggregate the value of records of the original <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> that got <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#groupBy-org.apache.kafka.streams.kstream.KeyValueMapper-"><code>mapped</code></a> to the same key into a new instance of <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> using default serializers and deserializers.
 Records with <code>null</code> key are ignored.
 Aggregating is a generalization of <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html#reduce-org.apache.kafka.streams.kstream.Reducer-org.apache.kafka.streams.kstream.Reducer-org.apache.kafka.streams.kstream.Materialized-"><code>combining via reduce(...)</code></a> as it,
 for example, allows the result to have a different type than the input values.
 The result is written into a local <a href="../../../../../org/apache/kafka/streams/state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state"><code>KeyValueStore</code></a> (which is basically an ever-updating materialized view)
 provided by the given <code>storeSupplier</code>.
 Furthermore, updates to the store are sent downstream into a <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> changelog stream.
 <p>
 The specified <a href="../../../../../org/apache/kafka/streams/kstream/Initializer.html" title="interface in org.apache.kafka.streams.kstream"><code>Initializer</code></a> is applied once directly before the first input record is processed to
 provide an initial intermediate aggregation result that is used to process the first record.
 Each update to the original <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> results in a two step update of the result <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a>.
 The specified <a href="../../../../../org/apache/kafka/streams/kstream/Aggregator.html" title="interface in org.apache.kafka.streams.kstream"><code>adder</code></a> is applied for each update record and computes a new aggregate using the
 current aggregate (or for the very first record using the intermediate aggregation result provided via the
 <a href="../../../../../org/apache/kafka/streams/kstream/Initializer.html" title="interface in org.apache.kafka.streams.kstream"><code>Initializer</code></a>) and the record's value by adding the new record to the aggregate.
 The specified <a href="../../../../../org/apache/kafka/streams/kstream/Aggregator.html" title="interface in org.apache.kafka.streams.kstream"><code>substractor</code></a> is applied for each "replaced" record of the original <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a>
 and computes a new aggregate using the current aggregate and the record's value by "removing" the "replaced"
 record from the aggregate.
 Thus, <code>aggregate(Initializer, Aggregator, Aggregator, String)</code> can be used to compute aggregate functions
 like sum.
 For sum, the initializer, adder, and substractor would work as follows:
 <pre><code>
 // in this example, LongSerde.class must be set as default value serde in StreamsConfig
 public class SumInitializer implements Initializer&lt;Long&gt; {
   public Long apply() {
     return 0L;
   }
 }

 public class SumAdder implements Aggregator&lt;String, Integer, Long&gt; {
   public Long apply(String key, Integer newValue, Long aggregate) {
     return aggregate + newValue;
   }
 }

 public class SumSubstractor implements Aggregator&lt;String, Integer, Long&gt; {
   public Long apply(String key, Integer oldValue, Long aggregate) {
     return aggregate - oldValue;
   }
 }
 </code></pre>
 Not all updates might get sent downstream, as an internal cache is used to deduplicate consecutive updates to
 the same key.
 The rate of propagated updates depends on your input data rate, the number of distinct keys, the number of
 parallel running Kafka Streams instances, and the <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html" title="class in org.apache.kafka.streams"><code>configuration</code></a> parameters for
 <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html#CACHE_MAX_BYTES_BUFFERING_CONFIG"><code>cache size</code></a>, and
 <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html#COMMIT_INTERVAL_MS_CONFIG"><code>commit intervall</code></a>.
 <p>
 To query the local <a href="../../../../../org/apache/kafka/streams/state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state"><code>KeyValueStore</code></a> it must be obtained via
 <a href="../../../../../org/apache/kafka/streams/KafkaStreams.html#store-java.lang.String-org.apache.kafka.streams.state.QueryableStoreType-"><code>KafkaStreams#store(...)</code></a>:
 <pre><code>
 KafkaStreams streams = ... // counting words
 ReadOnlyKeyValueStore&lt;String,Long&gt; localStore = streams.store(queryableStoreName, QueryableStoreTypes.&lt;String, Long&gt;keyValueStore());
 String key = "some-word";
 Long countForWord = localStore.get(key); // key must be local (application state is shared over all running Kafka Streams instances)
 </code></pre>
 For non-local keys, a custom RPC mechanism must be implemented using <a href="../../../../../org/apache/kafka/streams/KafkaStreams.html#allMetadata--"><code>KafkaStreams.allMetadata()</code></a> to
 query the value of the key on a parallel running instance of your Kafka Streams application.
 <p>
 For failure and recovery the store will be backed by an internal changelog topic that will be created in Kafka.
 The changelog topic will be named "${applicationId}-${queryableStoreName}-changelog", where "applicationId" is
 user-specified in <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html" title="class in org.apache.kafka.streams"><code>StreamsConfig</code></a> via parameter
 <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html#APPLICATION_ID_CONFIG"><code>APPLICATION_ID_CONFIG</code></a>, "queryableStoreName" is the
 provide <code>queryableStoreName</code>, and "-changelog" is a fixed suffix.
 You can retrieve all generated internal topic names via <a href="../../../../../org/apache/kafka/streams/KafkaStreams.html#toString--"><code>KafkaStreams.toString()</code></a>.</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>VR</code> - the value type of the aggregated <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>initializer</code> - an <a href="../../../../../org/apache/kafka/streams/kstream/Initializer.html" title="interface in org.apache.kafka.streams.kstream"><code>Initializer</code></a> that provides an initial aggregate result value</dd>
<dd><code>adder</code> - an <a href="../../../../../org/apache/kafka/streams/kstream/Aggregator.html" title="interface in org.apache.kafka.streams.kstream"><code>Aggregator</code></a> that adds a new record to the aggregate result</dd>
<dd><code>subtractor</code> - an <a href="../../../../../org/apache/kafka/streams/kstream/Aggregator.html" title="interface in org.apache.kafka.streams.kstream"><code>Aggregator</code></a> that removed an old record from the aggregate result</dd>
<dd><code>materialized</code> - the instance of <a href="../../../../../org/apache/kafka/streams/kstream/Materialized.html" title="class in org.apache.kafka.streams.kstream"><code>Materialized</code></a> used to materialize the state store. Cannot be <code>null</code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> that contains "update" records with unmodified keys, and values that represent the
 latest (rolling) aggregate for each key</dd>
</dl>
</li>
</ul>
<a name="aggregate-org.apache.kafka.streams.kstream.Initializer-org.apache.kafka.streams.kstream.Aggregator-org.apache.kafka.streams.kstream.Aggregator-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>aggregate</h4>
<pre>&lt;VR&gt;&nbsp;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html" title="type parameter in KGroupedTable">K</a>,VR&gt;&nbsp;aggregate&#8203;(<a href="../../../../../org/apache/kafka/streams/kstream/Initializer.html" title="interface in org.apache.kafka.streams.kstream">Initializer</a>&lt;VR&gt;&nbsp;initializer,
                            <a href="../../../../../org/apache/kafka/streams/kstream/Aggregator.html" title="interface in org.apache.kafka.streams.kstream">Aggregator</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html" title="type parameter in KGroupedTable">K</a>,? super <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html" title="type parameter in KGroupedTable">V</a>,VR&gt;&nbsp;adder,
                            <a href="../../../../../org/apache/kafka/streams/kstream/Aggregator.html" title="interface in org.apache.kafka.streams.kstream">Aggregator</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html" title="type parameter in KGroupedTable">K</a>,? super <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html" title="type parameter in KGroupedTable">V</a>,VR&gt;&nbsp;subtractor)</pre>
<div class="block">Aggregate the value of records of the original <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> that got <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#groupBy-org.apache.kafka.streams.kstream.KeyValueMapper-"><code>mapped</code></a> to the same key into a new instance of <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> using default serializers and deserializers.
 Records with <code>null</code> key are ignored.
 Aggregating is a generalization of <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html#reduce-org.apache.kafka.streams.kstream.Reducer-org.apache.kafka.streams.kstream.Reducer-"><code>combining via reduce(...)</code></a> as it,
 for example, allows the result to have a different type than the input values.
 If the result value type does not match the <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html#VALUE_SERDE_CLASS_CONFIG"><code>default value
 serde</code></a> you should use <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html#aggregate-org.apache.kafka.streams.kstream.Initializer-org.apache.kafka.streams.kstream.Aggregator-org.apache.kafka.streams.kstream.Aggregator-org.apache.kafka.common.serialization.Serde-"><code>aggregate(Initializer, Aggregator, Aggregator, Serde)</code></a>.
 The result is written into a local <a href="../../../../../org/apache/kafka/streams/state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state"><code>KeyValueStore</code></a> (which is basically an ever-updating materialized view)
 provided by the given <code>storeSupplier</code>.
 Furthermore, updates to the store are sent downstream into a <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> changelog stream.
 <p>
 The specified <a href="../../../../../org/apache/kafka/streams/kstream/Initializer.html" title="interface in org.apache.kafka.streams.kstream"><code>Initializer</code></a> is applied once directly before the first input record is processed to
 provide an initial intermediate aggregation result that is used to process the first record.
 Each update to the original <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> results in a two step update of the result <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a>.
 The specified <a href="../../../../../org/apache/kafka/streams/kstream/Aggregator.html" title="interface in org.apache.kafka.streams.kstream"><code>adder</code></a> is applied for each update record and computes a new aggregate using the
 current aggregate (or for the very first record using the intermediate aggregation result provided via the
 <a href="../../../../../org/apache/kafka/streams/kstream/Initializer.html" title="interface in org.apache.kafka.streams.kstream"><code>Initializer</code></a>) and the record's value by adding the new record to the aggregate.
 The specified <a href="../../../../../org/apache/kafka/streams/kstream/Aggregator.html" title="interface in org.apache.kafka.streams.kstream"><code>substractor</code></a> is applied for each "replaced" record of the original <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a>
 and computes a new aggregate using the current aggregate and the record's value by "removing" the "replaced"
 record from the aggregate.
 Thus, <code>aggregate(Initializer, Aggregator, Aggregator, String)</code> can be used to compute aggregate functions
 like sum.
 For sum, the initializer, adder, and substractor would work as follows:
 <pre><code>
 // in this example, LongSerde.class must be set as default value serde in StreamsConfig
 public class SumInitializer implements Initializer&lt;Long&gt; {
   public Long apply() {
     return 0L;
   }
 }

 public class SumAdder implements Aggregator&lt;String, Integer, Long&gt; {
   public Long apply(String key, Integer newValue, Long aggregate) {
     return aggregate + newValue;
   }
 }

 public class SumSubstractor implements Aggregator&lt;String, Integer, Long&gt; {
   public Long apply(String key, Integer oldValue, Long aggregate) {
     return aggregate - oldValue;
   }
 }
 </code></pre>
 Not all updates might get sent downstream, as an internal cache is used to deduplicate consecutive updates to
 the same key.
 The rate of propagated updates depends on your input data rate, the number of distinct keys, the number of
 parallel running Kafka Streams instances, and the <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html" title="class in org.apache.kafka.streams"><code>configuration</code></a> parameters for
 <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html#CACHE_MAX_BYTES_BUFFERING_CONFIG"><code>cache size</code></a>, and
 <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html#COMMIT_INTERVAL_MS_CONFIG"><code>commit intervall</code></a>.
 For failure and recovery the store will be backed by an internal changelog topic that will be created in Kafka.
 The changelog topic will be named "${applicationId}-${internalStoreName}-changelog", where "applicationId" is
 user-specified in <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html" title="class in org.apache.kafka.streams"><code>StreamsConfig</code></a> via parameter
 <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html#APPLICATION_ID_CONFIG"><code>APPLICATION_ID_CONFIG</code></a>, "internalStoreName" is an internal name
 and "-changelog" is a fixed suffix.
 Note that the internal store name may not be queriable through Interactive Queries.
 You can retrieve all generated internal topic names via <a href="../../../../../org/apache/kafka/streams/KafkaStreams.html#toString--"><code>KafkaStreams.toString()</code></a>.</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>VR</code> - the value type of the aggregated <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>initializer</code> - a <a href="../../../../../org/apache/kafka/streams/kstream/Initializer.html" title="interface in org.apache.kafka.streams.kstream"><code>Initializer</code></a> that provides an initial aggregate result value</dd>
<dd><code>adder</code> - a <a href="../../../../../org/apache/kafka/streams/kstream/Aggregator.html" title="interface in org.apache.kafka.streams.kstream"><code>Aggregator</code></a> that adds a new record to the aggregate result</dd>
<dd><code>subtractor</code> - a <a href="../../../../../org/apache/kafka/streams/kstream/Aggregator.html" title="interface in org.apache.kafka.streams.kstream"><code>Aggregator</code></a> that removed an old record from the aggregate result</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> that contains "update" records with unmodified keys, and values that represent the
 latest (rolling) aggregate for each key</dd>
</dl>
</li>
</ul>
<a name="aggregate-org.apache.kafka.streams.kstream.Initializer-org.apache.kafka.streams.kstream.Aggregator-org.apache.kafka.streams.kstream.Aggregator-org.apache.kafka.common.serialization.Serde-java.lang.String-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>aggregate</h4>
<pre>@Deprecated
&lt;VR&gt;&nbsp;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html" title="type parameter in KGroupedTable">K</a>,VR&gt;&nbsp;aggregate&#8203;(<a href="../../../../../org/apache/kafka/streams/kstream/Initializer.html" title="interface in org.apache.kafka.streams.kstream">Initializer</a>&lt;VR&gt;&nbsp;initializer,
                            <a href="../../../../../org/apache/kafka/streams/kstream/Aggregator.html" title="interface in org.apache.kafka.streams.kstream">Aggregator</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html" title="type parameter in KGroupedTable">K</a>,? super <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html" title="type parameter in KGroupedTable">V</a>,VR&gt;&nbsp;adder,
                            <a href="../../../../../org/apache/kafka/streams/kstream/Aggregator.html" title="interface in org.apache.kafka.streams.kstream">Aggregator</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html" title="type parameter in KGroupedTable">K</a>,? super <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html" title="type parameter in KGroupedTable">V</a>,VR&gt;&nbsp;subtractor,
                            <a href="../../../../../org/apache/kafka/common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization">Serde</a>&lt;VR&gt;&nbsp;aggValueSerde,
                            java.lang.String&nbsp;queryableStoreName)</pre>
<div class="block"><span class="deprecatedLabel">Deprecated.</span>&nbsp;<span class="deprecationComment">use <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html#aggregate-org.apache.kafka.streams.kstream.Initializer-org.apache.kafka.streams.kstream.Aggregator-org.apache.kafka.streams.kstream.Aggregator-org.apache.kafka.streams.kstream.Materialized-"><code>aggregate(initializer, adder, subtractor, Materialized.as(queryableStoreName).withValueSerde(aggValueSerde))</code></a></span></div>
<div class="block">Aggregate the value of records of the original <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> that got <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#groupBy-org.apache.kafka.streams.kstream.KeyValueMapper-"><code>mapped</code></a> to the same key into a new instance of <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> using default serializers and deserializers.
 Records with <code>null</code> key are ignored.
 Aggregating is a generalization of <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html#reduce-org.apache.kafka.streams.kstream.Reducer-org.apache.kafka.streams.kstream.Reducer-java.lang.String-"><code>combining via reduce(...)</code></a> as it,
 for example, allows the result to have a different type than the input values.
 The result is written into a local <a href="../../../../../org/apache/kafka/streams/state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state"><code>KeyValueStore</code></a> (which is basically an ever-updating materialized view)
 that can be queried using the provided <code>queryableStoreName</code>.
 Furthermore, updates to the store are sent downstream into a <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> changelog stream.
 <p>
 The specified <a href="../../../../../org/apache/kafka/streams/kstream/Initializer.html" title="interface in org.apache.kafka.streams.kstream"><code>Initializer</code></a> is applied once directly before the first input record is processed to
 provide an initial intermediate aggregation result that is used to process the first record.
 Each update to the original <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> results in a two step update of the result <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a>.
 The specified <a href="../../../../../org/apache/kafka/streams/kstream/Aggregator.html" title="interface in org.apache.kafka.streams.kstream"><code>adder</code></a> is applied for each update record and computes a new aggregate using the
 current aggregate (or for the very first record using the intermediate aggregation result provided via the
 <a href="../../../../../org/apache/kafka/streams/kstream/Initializer.html" title="interface in org.apache.kafka.streams.kstream"><code>Initializer</code></a>) and the record's value by adding the new record to the aggregate.
 The specified <a href="../../../../../org/apache/kafka/streams/kstream/Aggregator.html" title="interface in org.apache.kafka.streams.kstream"><code>substractor</code></a> is applied for each "replaced" record of the original <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a>
 and computes a new aggregate using the current aggregate and the record's value by "removing" the "replaced"
 record from the aggregate.
 Thus, <code>aggregate(Initializer, Aggregator, Aggregator, String)</code> can be used to compute aggregate functions
 like sum.
 For sum, the initializer, adder, and substractor would work as follows:
 <pre><code>
 public class SumInitializer implements Initializer&lt;Long&gt; {
   public Long apply() {
     return 0L;
   }
 }

 public class SumAdder implements Aggregator&lt;String, Integer, Long&gt; {
   public Long apply(String key, Integer newValue, Long aggregate) {
     return aggregate + newValue;
   }
 }

 public class SumSubstractor implements Aggregator&lt;String, Integer, Long&gt; {
   public Long apply(String key, Integer oldValue, Long aggregate) {
     return aggregate - oldValue;
   }
 }
 </code></pre>
 Not all updates might get sent downstream, as an internal cache is used to deduplicate consecutive updates to
 the same key.
 The rate of propagated updates depends on your input data rate, the number of distinct keys, the number of
 parallel running Kafka Streams instances, and the <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html" title="class in org.apache.kafka.streams"><code>configuration</code></a> parameters for
 <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html#CACHE_MAX_BYTES_BUFFERING_CONFIG"><code>cache size</code></a>, and
 <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html#COMMIT_INTERVAL_MS_CONFIG"><code>commit intervall</code></a>.
 <p>
 To query the local <a href="../../../../../org/apache/kafka/streams/state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state"><code>KeyValueStore</code></a> it must be obtained via
 <a href="../../../../../org/apache/kafka/streams/KafkaStreams.html#store-java.lang.String-org.apache.kafka.streams.state.QueryableStoreType-"><code>KafkaStreams#store(...)</code></a>:
 <pre><code>
 KafkaStreams streams = ... // counting words
 ReadOnlyKeyValueStore&lt;String,Long&gt; localStore = streams.store(queryableStoreName, QueryableStoreTypes.&lt;String, Long&gt;keyValueStore());
 String key = "some-word";
 Long countForWord = localStore.get(key); // key must be local (application state is shared over all running Kafka Streams instances)
 </code></pre>
 For non-local keys, a custom RPC mechanism must be implemented using <a href="../../../../../org/apache/kafka/streams/KafkaStreams.html#allMetadata--"><code>KafkaStreams.allMetadata()</code></a> to
 query the value of the key on a parallel running instance of your Kafka Streams application.
 <p>
 For failure and recovery the store will be backed by an internal changelog topic that will be created in Kafka.
 The changelog topic will be named "${applicationId}-${queryableStoreName}-changelog", where "applicationId" is
 user-specified in <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html" title="class in org.apache.kafka.streams"><code>StreamsConfig</code></a> via parameter
 <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html#APPLICATION_ID_CONFIG"><code>APPLICATION_ID_CONFIG</code></a>, "queryableStoreName" is the
 provide <code>queryableStoreName</code>, and "-changelog" is a fixed suffix.
 The store name must be a valid Kafka topic name and cannot contain characters other than ASCII alphanumerics,
 '.', '_' and '-'.
 You can retrieve all generated internal topic names via <a href="../../../../../org/apache/kafka/streams/KafkaStreams.html#toString--"><code>KafkaStreams.toString()</code></a>.</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>VR</code> - the value type of the aggregated <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>initializer</code> - a <a href="../../../../../org/apache/kafka/streams/kstream/Initializer.html" title="interface in org.apache.kafka.streams.kstream"><code>Initializer</code></a> that provides an initial aggregate result value</dd>
<dd><code>adder</code> - a <a href="../../../../../org/apache/kafka/streams/kstream/Aggregator.html" title="interface in org.apache.kafka.streams.kstream"><code>Aggregator</code></a> that adds a new record to the aggregate result</dd>
<dd><code>subtractor</code> - a <a href="../../../../../org/apache/kafka/streams/kstream/Aggregator.html" title="interface in org.apache.kafka.streams.kstream"><code>Aggregator</code></a> that removed an old record from the aggregate result</dd>
<dd><code>aggValueSerde</code> - aggregate value serdes for materializing the aggregated table,
                      if not specified the default serdes defined in the configs will be used</dd>
<dd><code>queryableStoreName</code> - the name of the underlying <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> state store; valid characters are ASCII
 alphanumerics, '.', '_' and '-'. If <code>null</code> this is the equivalent of <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html#aggregate-org.apache.kafka.streams.kstream.Initializer-org.apache.kafka.streams.kstream.Aggregator-org.apache.kafka.streams.kstream.Aggregator-org.apache.kafka.common.serialization.Serde-"><code>aggregate(Initializer, Aggregator, Aggregator, Serde)</code></a> ()}.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> that contains "update" records with unmodified keys, and values that represent the
 latest (rolling) aggregate for each key</dd>
</dl>
</li>
</ul>
<a name="aggregate-org.apache.kafka.streams.kstream.Initializer-org.apache.kafka.streams.kstream.Aggregator-org.apache.kafka.streams.kstream.Aggregator-org.apache.kafka.common.serialization.Serde-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>aggregate</h4>
<pre>@Deprecated
&lt;VR&gt;&nbsp;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html" title="type parameter in KGroupedTable">K</a>,VR&gt;&nbsp;aggregate&#8203;(<a href="../../../../../org/apache/kafka/streams/kstream/Initializer.html" title="interface in org.apache.kafka.streams.kstream">Initializer</a>&lt;VR&gt;&nbsp;initializer,
                            <a href="../../../../../org/apache/kafka/streams/kstream/Aggregator.html" title="interface in org.apache.kafka.streams.kstream">Aggregator</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html" title="type parameter in KGroupedTable">K</a>,? super <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html" title="type parameter in KGroupedTable">V</a>,VR&gt;&nbsp;adder,
                            <a href="../../../../../org/apache/kafka/streams/kstream/Aggregator.html" title="interface in org.apache.kafka.streams.kstream">Aggregator</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html" title="type parameter in KGroupedTable">K</a>,? super <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html" title="type parameter in KGroupedTable">V</a>,VR&gt;&nbsp;subtractor,
                            <a href="../../../../../org/apache/kafka/common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization">Serde</a>&lt;VR&gt;&nbsp;aggValueSerde)</pre>
<div class="block"><span class="deprecatedLabel">Deprecated.</span>&nbsp;<span class="deprecationComment">use <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html#aggregate-org.apache.kafka.streams.kstream.Initializer-org.apache.kafka.streams.kstream.Aggregator-org.apache.kafka.streams.kstream.Aggregator-org.apache.kafka.streams.kstream.Materialized-"><code>aggregate(initializer, adder, subtractor, Materialized.with(null, aggValueSerde))</code></a></span></div>
<div class="block">Aggregate the value of records of the original <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> that got <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#groupBy-org.apache.kafka.streams.kstream.KeyValueMapper-"><code>mapped</code></a> to the same key into a new instance of <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> using default serializers and deserializers.
 Records with <code>null</code> key are ignored.
 Aggregating is a generalization of <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html#reduce-org.apache.kafka.streams.kstream.Reducer-org.apache.kafka.streams.kstream.Reducer-org.apache.kafka.streams.kstream.Materialized-"><code>combining via reduce(...)</code></a> as it,
 for example, allows the result to have a different type than the input values.
 The result is written into a local <a href="../../../../../org/apache/kafka/streams/state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state"><code>KeyValueStore</code></a> (which is basically an ever-updating materialized view)
 that can be queried using the provided <code>queryableStoreName</code>.
 Furthermore, updates to the store are sent downstream into a <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> changelog stream.
 <p>
 The specified <a href="../../../../../org/apache/kafka/streams/kstream/Initializer.html" title="interface in org.apache.kafka.streams.kstream"><code>Initializer</code></a> is applied once directly before the first input record is processed to
 provide an initial intermediate aggregation result that is used to process the first record.
 Each update to the original <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> results in a two step update of the result <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a>.
 The specified <a href="../../../../../org/apache/kafka/streams/kstream/Aggregator.html" title="interface in org.apache.kafka.streams.kstream"><code>adder</code></a> is applied for each update record and computes a new aggregate using the
 current aggregate (or for the very first record using the intermediate aggregation result provided via the
 <a href="../../../../../org/apache/kafka/streams/kstream/Initializer.html" title="interface in org.apache.kafka.streams.kstream"><code>Initializer</code></a>) and the record's value by adding the new record to the aggregate.
 The specified <a href="../../../../../org/apache/kafka/streams/kstream/Aggregator.html" title="interface in org.apache.kafka.streams.kstream"><code>substractor</code></a> is applied for each "replaced" record of the original <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a>
 and computes a new aggregate using the current aggregate and the record's value by "removing" the "replaced"
 record from the aggregate.
 Thus, <code>aggregate(Initializer, Aggregator, Aggregator, String)</code> can be used to compute aggregate functions
 like sum.
 For sum, the initializer, adder, and substractor would work as follows:
 <pre><code>
 public class SumInitializer implements Initializer&lt;Long&gt; {
   public Long apply() {
     return 0L;
   }
 }

 public class SumAdder implements Aggregator&lt;String, Integer, Long&gt; {
   public Long apply(String key, Integer newValue, Long aggregate) {
     return aggregate + newValue;
   }
 }

 public class SumSubstractor implements Aggregator&lt;String, Integer, Long&gt; {
   public Long apply(String key, Integer oldValue, Long aggregate) {
     return aggregate - oldValue;
   }
 }
 </code></pre>
 Not all updates might get sent downstream, as an internal cache is used to deduplicate consecutive updates to
 the same key.
 The rate of propagated updates depends on your input data rate, the number of distinct keys, the number of
 parallel running Kafka Streams instances, and the <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html" title="class in org.apache.kafka.streams"><code>configuration</code></a> parameters for
 <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html#CACHE_MAX_BYTES_BUFFERING_CONFIG"><code>cache size</code></a>, and
 <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html#COMMIT_INTERVAL_MS_CONFIG"><code>commit intervall</code></a>.
 <p>
 For failure and recovery the store will be backed by an internal changelog topic that will be created in Kafka.
 The changelog topic will be named "${applicationId}-${internalStoreName}-changelog", where "applicationId" is
 user-specified in <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html" title="class in org.apache.kafka.streams"><code>StreamsConfig</code></a> via parameter
 <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html#APPLICATION_ID_CONFIG"><code>APPLICATION_ID_CONFIG</code></a>, "internalStoreName" is an internal name
 and "-changelog" is a fixed suffix.
 Note that the internal store name may not be queriable through Interactive Queries.
 You can retrieve all generated internal topic names via <a href="../../../../../org/apache/kafka/streams/KafkaStreams.html#toString--"><code>KafkaStreams.toString()</code></a>.</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>VR</code> - the value type of the aggregated <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>initializer</code> - a <a href="../../../../../org/apache/kafka/streams/kstream/Initializer.html" title="interface in org.apache.kafka.streams.kstream"><code>Initializer</code></a> that provides an initial aggregate result value</dd>
<dd><code>adder</code> - a <a href="../../../../../org/apache/kafka/streams/kstream/Aggregator.html" title="interface in org.apache.kafka.streams.kstream"><code>Aggregator</code></a> that adds a new record to the aggregate result</dd>
<dd><code>subtractor</code> - a <a href="../../../../../org/apache/kafka/streams/kstream/Aggregator.html" title="interface in org.apache.kafka.streams.kstream"><code>Aggregator</code></a> that removed an old record from the aggregate result</dd>
<dd><code>aggValueSerde</code> - aggregate value serdes for materializing the aggregated table,
                      if not specified the default serdes defined in the configs will be used</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> that contains "update" records with unmodified keys, and values that represent the
 latest (rolling) aggregate for each key</dd>
</dl>
</li>
</ul>
<a name="aggregate-org.apache.kafka.streams.kstream.Initializer-org.apache.kafka.streams.kstream.Aggregator-org.apache.kafka.streams.kstream.Aggregator-org.apache.kafka.streams.processor.StateStoreSupplier-">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>aggregate</h4>
<pre>@Deprecated
&lt;VR&gt;&nbsp;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html" title="type parameter in KGroupedTable">K</a>,VR&gt;&nbsp;aggregate&#8203;(<a href="../../../../../org/apache/kafka/streams/kstream/Initializer.html" title="interface in org.apache.kafka.streams.kstream">Initializer</a>&lt;VR&gt;&nbsp;initializer,
                            <a href="../../../../../org/apache/kafka/streams/kstream/Aggregator.html" title="interface in org.apache.kafka.streams.kstream">Aggregator</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html" title="type parameter in KGroupedTable">K</a>,? super <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html" title="type parameter in KGroupedTable">V</a>,VR&gt;&nbsp;adder,
                            <a href="../../../../../org/apache/kafka/streams/kstream/Aggregator.html" title="interface in org.apache.kafka.streams.kstream">Aggregator</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html" title="type parameter in KGroupedTable">K</a>,? super <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html" title="type parameter in KGroupedTable">V</a>,VR&gt;&nbsp;subtractor,
                            <a href="../../../../../org/apache/kafka/streams/processor/StateStoreSupplier.html" title="interface in org.apache.kafka.streams.processor">StateStoreSupplier</a>&lt;<a href="../../../../../org/apache/kafka/streams/state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state">KeyValueStore</a>&gt;&nbsp;storeSupplier)</pre>
<div class="block"><span class="deprecatedLabel">Deprecated.</span>&nbsp;<span class="deprecationComment">use <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html#aggregate-org.apache.kafka.streams.kstream.Initializer-org.apache.kafka.streams.kstream.Aggregator-org.apache.kafka.streams.kstream.Aggregator-org.apache.kafka.streams.kstream.Materialized-"><code>aggregate(initializer, adder, subtractor, Materialized.as(KeyValueByteStoreSupplier))</code></a></span></div>
<div class="block">Aggregate the value of records of the original <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> that got <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#groupBy-org.apache.kafka.streams.kstream.KeyValueMapper-"><code>mapped</code></a> to the same key into a new instance of <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> using default serializers and deserializers.
 Records with <code>null</code> key are ignored.
 Aggregating is a generalization of <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html#reduce-org.apache.kafka.streams.kstream.Reducer-org.apache.kafka.streams.kstream.Reducer-java.lang.String-"><code>combining via reduce(...)</code></a> as it,
 for example, allows the result to have a different type than the input values.
 The result is written into a local <a href="../../../../../org/apache/kafka/streams/state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state"><code>KeyValueStore</code></a> (which is basically an ever-updating materialized view)
 provided by the given <code>storeSupplier</code>.
 Furthermore, updates to the store are sent downstream into a <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> changelog stream.
 <p>
 The specified <a href="../../../../../org/apache/kafka/streams/kstream/Initializer.html" title="interface in org.apache.kafka.streams.kstream"><code>Initializer</code></a> is applied once directly before the first input record is processed to
 provide an initial intermediate aggregation result that is used to process the first record.
 Each update to the original <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> results in a two step update of the result <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a>.
 The specified <a href="../../../../../org/apache/kafka/streams/kstream/Aggregator.html" title="interface in org.apache.kafka.streams.kstream"><code>adder</code></a> is applied for each update record and computes a new aggregate using the
 current aggregate (or for the very first record using the intermediate aggregation result provided via the
 <a href="../../../../../org/apache/kafka/streams/kstream/Initializer.html" title="interface in org.apache.kafka.streams.kstream"><code>Initializer</code></a>) and the record's value by adding the new record to the aggregate.
 The specified <a href="../../../../../org/apache/kafka/streams/kstream/Aggregator.html" title="interface in org.apache.kafka.streams.kstream"><code>substractor</code></a> is applied for each "replaced" record of the original <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a>
 and computes a new aggregate using the current aggregate and the record's value by "removing" the "replaced"
 record from the aggregate.
 Thus, <code>aggregate(Initializer, Aggregator, Aggregator, String)</code> can be used to compute aggregate functions
 like sum.
 For sum, the initializer, adder, and substractor would work as follows:
 <pre><code>
 public class SumInitializer implements Initializer&lt;Long&gt; {
   public Long apply() {
     return 0L;
   }
 }

 public class SumAdder implements Aggregator&lt;String, Integer, Long&gt; {
   public Long apply(String key, Integer newValue, Long aggregate) {
     return aggregate + newValue;
   }
 }

 public class SumSubstractor implements Aggregator&lt;String, Integer, Long&gt; {
   public Long apply(String key, Integer oldValue, Long aggregate) {
     return aggregate - oldValue;
   }
 }
 </code></pre>
 Not all updates might get sent downstream, as an internal cache is used to deduplicate consecutive updates to
 the same key.
 The rate of propagated updates depends on your input data rate, the number of distinct keys, the number of
 parallel running Kafka Streams instances, and the <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html" title="class in org.apache.kafka.streams"><code>configuration</code></a> parameters for
 <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html#CACHE_MAX_BYTES_BUFFERING_CONFIG"><code>cache size</code></a>, and
 <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html#COMMIT_INTERVAL_MS_CONFIG"><code>commit intervall</code></a>.
 <p>
 To query the local <a href="../../../../../org/apache/kafka/streams/state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state"><code>KeyValueStore</code></a> it must be obtained via
 <a href="../../../../../org/apache/kafka/streams/KafkaStreams.html#store-java.lang.String-org.apache.kafka.streams.state.QueryableStoreType-"><code>KafkaStreams#store(...)</code></a>:
 <pre><code>
 KafkaStreams streams = ... // counting words
 String queryableStoreName = storeSupplier.name();
 ReadOnlyKeyValueStore&lt;String,Long&gt; localStore = streams.store(queryableStoreName, QueryableStoreTypes.&lt;String, Long&gt;keyValueStore());
 String key = "some-word";
 Long countForWord = localStore.get(key); // key must be local (application state is shared over all running Kafka Streams instances)
 </code></pre>
 For non-local keys, a custom RPC mechanism must be implemented using <a href="../../../../../org/apache/kafka/streams/KafkaStreams.html#allMetadata--"><code>KafkaStreams.allMetadata()</code></a> to
 query the value of the key on a parallel running instance of your Kafka Streams application.
 <p>
 For failure and recovery the store will be backed by an internal changelog topic that will be created in Kafka.
 The changelog topic will be named "${applicationId}-${queryableStoreName}-changelog", where "applicationId" is
 user-specified in <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html" title="class in org.apache.kafka.streams"><code>StreamsConfig</code></a> via parameter
 <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html#APPLICATION_ID_CONFIG"><code>APPLICATION_ID_CONFIG</code></a>, "queryableStoreName" is the
 provide <code>queryableStoreName</code>, and "-changelog" is a fixed suffix.
 You can retrieve all generated internal topic names via <a href="../../../../../org/apache/kafka/streams/KafkaStreams.html#toString--"><code>KafkaStreams.toString()</code></a>.</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>VR</code> - the value type of the aggregated <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>initializer</code> - a <a href="../../../../../org/apache/kafka/streams/kstream/Initializer.html" title="interface in org.apache.kafka.streams.kstream"><code>Initializer</code></a> that provides an initial aggregate result value</dd>
<dd><code>adder</code> - a <a href="../../../../../org/apache/kafka/streams/kstream/Aggregator.html" title="interface in org.apache.kafka.streams.kstream"><code>Aggregator</code></a> that adds a new record to the aggregate result</dd>
<dd><code>subtractor</code> - a <a href="../../../../../org/apache/kafka/streams/kstream/Aggregator.html" title="interface in org.apache.kafka.streams.kstream"><code>Aggregator</code></a> that removed an old record from the aggregate result</dd>
<dd><code>storeSupplier</code> - user defined state store supplier. Cannot be <code>null</code>.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> that contains "update" records with unmodified keys, and values that represent the
 latest (rolling) aggregate for each key</dd>
</dl>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<!-- ========= END OF CLASS DATA ========= -->
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a name="navbar.bottom">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a></div>
<a name="navbar.bottom.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../../../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../../index-all.html">Index</a></li>
<li><a href="../../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html" title="interface in org.apache.kafka.streams.kstream"><span class="typeNameLink">Prev&nbsp;Class</span></a></li>
<li><a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="interface in org.apache.kafka.streams.kstream"><span class="typeNameLink">Next&nbsp;Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../../../../index.html?org/apache/kafka/streams/kstream/KGroupedTable.html" target="_top">Frames</a></li>
<li><a href="KGroupedTable.html" target="_top">No&nbsp;Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="../../../../../allclasses-noframe.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a name="skip.navbar.bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
</body>
</html>

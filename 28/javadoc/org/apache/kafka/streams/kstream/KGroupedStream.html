<!DOCTYPE HTML>
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc -->
<title>KGroupedStream (kafka 2.8.1 API)</title>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<link rel="stylesheet" type="text/css" href="../../../../../stylesheet.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../../../../jquery/jquery-ui.css" title="Style">
<script type="text/javascript" src="../../../../../script.js"></script>
<script type="text/javascript" src="../../../../../jquery/jszip/dist/jszip.min.js"></script>
<script type="text/javascript" src="../../../../../jquery/jszip-utils/dist/jszip-utils.min.js"></script>
<!--[if IE]>
<script type="text/javascript" src="../../../../../jquery/jszip-utils/dist/jszip-utils-ie.min.js"></script>
<![endif]-->
<script type="text/javascript" src="../../../../../jquery/jquery-3.3.1.js"></script>
<script type="text/javascript" src="../../../../../jquery/jquery-migrate-3.0.1.js"></script>
<script type="text/javascript" src="../../../../../jquery/jquery-ui.js"></script>
</head>
<body>
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="KGroupedStream (kafka 2.8.1 API)";
        }
    }
    catch(err) {
    }
//-->
var data = {"i0":6,"i1":6,"i2":6,"i3":6,"i4":6,"i5":6,"i6":6,"i7":6,"i8":6,"i9":6,"i10":6,"i11":6,"i12":6,"i13":6};
var tabs = {65535:["t0","All Methods"],2:["t2","Instance Methods"],4:["t3","Abstract Methods"]};
var altColor = "altColor";
var rowColor = "rowColor";
var tableTab = "tableTab";
var activeTableTab = "activeTableTab";
var pathtoroot = "../../../../../";
var useModuleDirectories = true;
loadScripts(document, 'script');</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<header role="banner">
<nav role="navigation">
<div class="fixedNav">
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a id="navbar.top">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<a id="navbar.top.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../../../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../../index-all.html">Index</a></li>
<li><a href="../../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList" id="allclasses_navbar_top">
<li><a href="../../../../../allclasses.html">All&nbsp;Classes</a></li>
</ul>
<ul class="navListSearch">
<li><label for="search">SEARCH:</label>
<input type="text" id="search" value="search" disabled="disabled">
<input type="reset" id="reset" value="reset" disabled="disabled">
</li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a id="skip.navbar.top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
</div>
<div class="navPadding">&nbsp;</div>
<script type="text/javascript"><!--
$('.navPadding').css('padding-top', $('.fixedNav').css("height"));
//-->
</script>
</nav>
</header>
<!-- ======== START OF CLASS DATA ======== -->
<main role="main">
<div class="header">
<div class="subTitle"><span class="packageLabelInType">Package</span>&nbsp;<a href="package-summary.html">org.apache.kafka.streams.kstream</a></div>
<h2 title="Interface KGroupedStream" class="title">Interface KGroupedStream&lt;K,&#8203;V&gt;</h2>
</div>
<div class="contentContainer">
<div class="description">
<ul class="blockList">
<li class="blockList">
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>K</code> - Type of keys</dd>
<dd><code>V</code> - Type of values</dd>
</dl>
<hr>
<pre>public interface <span class="typeNameLabel">KGroupedStream&lt;K,&#8203;V&gt;</span></pre>
<div class="block"><code>KGroupedStream</code> is an abstraction of a <i>grouped</i> record stream of <a href="../KeyValue.html" title="class in org.apache.kafka.streams"><code>KeyValue</code></a> pairs.
 It is an intermediate representation of a <a href="KStream.html" title="interface in org.apache.kafka.streams.kstream"><code>KStream</code></a> in order to apply an aggregation operation on the original
 <a href="KStream.html" title="interface in org.apache.kafka.streams.kstream"><code>KStream</code></a> records.
 <p>
 It is an intermediate representation after a grouping of a <a href="KStream.html" title="interface in org.apache.kafka.streams.kstream"><code>KStream</code></a> before an aggregation is applied to the
 new partitions resulting in a <a href="KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a>.
 <p>
 A <code>KGroupedStream</code> must be obtained from a <a href="KStream.html" title="interface in org.apache.kafka.streams.kstream"><code>KStream</code></a> via <a href="KStream.html#groupByKey()"><code>groupByKey()</code></a> or
 <a href="KStream.html#groupBy(org.apache.kafka.streams.kstream.KeyValueMapper)"><code>groupBy(...)</code></a>.</div>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="KStream.html" title="interface in org.apache.kafka.streams.kstream"><code>KStream</code></a></dd>
</dl>
</li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- ========== METHOD SUMMARY =========== -->
<section role="region">
<ul class="blockList">
<li class="blockList"><a id="method.summary">
<!--   -->
</a>
<h3>Method Summary</h3>
<table class="memberSummary">
<caption><span id="t0" class="activeTableTab"><span>All Methods</span><span class="tabEnd">&nbsp;</span></span><span id="t2" class="tableTab"><span><a href="javascript:show(2);">Instance Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t3" class="tableTab"><span><a href="javascript:show(4);">Abstract Methods</a></span><span class="tabEnd">&nbsp;</span></span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colSecond" scope="col">Method</th>
<th class="colLast" scope="col">Description</th>
</tr>
<tr id="i0" class="altColor">
<td class="colFirst"><code>&lt;VR&gt;&nbsp;<a href="KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="KGroupedStream.html" title="type parameter in KGroupedStream">K</a>,&#8203;VR&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#aggregate(org.apache.kafka.streams.kstream.Initializer,org.apache.kafka.streams.kstream.Aggregator)">aggregate</a></span>&#8203;(<a href="Initializer.html" title="interface in org.apache.kafka.streams.kstream">Initializer</a>&lt;VR&gt;&nbsp;initializer,
         <a href="Aggregator.html" title="interface in org.apache.kafka.streams.kstream">Aggregator</a>&lt;? super <a href="KGroupedStream.html" title="type parameter in KGroupedStream">K</a>,&#8203;? super <a href="KGroupedStream.html" title="type parameter in KGroupedStream">V</a>,&#8203;VR&gt;&nbsp;aggregator)</code></th>
<td class="colLast">
<div class="block">Aggregate the values of records in this stream by the grouped key.</div>
</td>
</tr>
<tr id="i1" class="rowColor">
<td class="colFirst"><code>&lt;VR&gt;&nbsp;<a href="KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="KGroupedStream.html" title="type parameter in KGroupedStream">K</a>,&#8203;VR&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#aggregate(org.apache.kafka.streams.kstream.Initializer,org.apache.kafka.streams.kstream.Aggregator,org.apache.kafka.streams.kstream.Materialized)">aggregate</a></span>&#8203;(<a href="Initializer.html" title="interface in org.apache.kafka.streams.kstream">Initializer</a>&lt;VR&gt;&nbsp;initializer,
         <a href="Aggregator.html" title="interface in org.apache.kafka.streams.kstream">Aggregator</a>&lt;? super <a href="KGroupedStream.html" title="type parameter in KGroupedStream">K</a>,&#8203;? super <a href="KGroupedStream.html" title="type parameter in KGroupedStream">V</a>,&#8203;VR&gt;&nbsp;aggregator,
         <a href="Materialized.html" title="class in org.apache.kafka.streams.kstream">Materialized</a>&lt;<a href="KGroupedStream.html" title="type parameter in KGroupedStream">K</a>,&#8203;VR,&#8203;<a href="../state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state">KeyValueStore</a>&lt;org.apache.kafka.common.utils.Bytes,&#8203;byte[]&gt;&gt;&nbsp;materialized)</code></th>
<td class="colLast">
<div class="block">Aggregate the values of records in this stream by the grouped key.</div>
</td>
</tr>
<tr id="i2" class="altColor">
<td class="colFirst"><code>&lt;VR&gt;&nbsp;<a href="KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="KGroupedStream.html" title="type parameter in KGroupedStream">K</a>,&#8203;VR&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#aggregate(org.apache.kafka.streams.kstream.Initializer,org.apache.kafka.streams.kstream.Aggregator,org.apache.kafka.streams.kstream.Named,org.apache.kafka.streams.kstream.Materialized)">aggregate</a></span>&#8203;(<a href="Initializer.html" title="interface in org.apache.kafka.streams.kstream">Initializer</a>&lt;VR&gt;&nbsp;initializer,
         <a href="Aggregator.html" title="interface in org.apache.kafka.streams.kstream">Aggregator</a>&lt;? super <a href="KGroupedStream.html" title="type parameter in KGroupedStream">K</a>,&#8203;? super <a href="KGroupedStream.html" title="type parameter in KGroupedStream">V</a>,&#8203;VR&gt;&nbsp;aggregator,
         <a href="Named.html" title="class in org.apache.kafka.streams.kstream">Named</a>&nbsp;named,
         <a href="Materialized.html" title="class in org.apache.kafka.streams.kstream">Materialized</a>&lt;<a href="KGroupedStream.html" title="type parameter in KGroupedStream">K</a>,&#8203;VR,&#8203;<a href="../state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state">KeyValueStore</a>&lt;org.apache.kafka.common.utils.Bytes,&#8203;byte[]&gt;&gt;&nbsp;materialized)</code></th>
<td class="colLast">
<div class="block">Aggregate the values of records in this stream by the grouped key.</div>
</td>
</tr>
<tr id="i3" class="rowColor">
<td class="colFirst"><code>&lt;VOut&gt;&nbsp;<a href="CogroupedKStream.html" title="interface in org.apache.kafka.streams.kstream">CogroupedKStream</a>&lt;<a href="KGroupedStream.html" title="type parameter in KGroupedStream">K</a>,&#8203;VOut&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#cogroup(org.apache.kafka.streams.kstream.Aggregator)">cogroup</a></span>&#8203;(<a href="Aggregator.html" title="interface in org.apache.kafka.streams.kstream">Aggregator</a>&lt;? super <a href="KGroupedStream.html" title="type parameter in KGroupedStream">K</a>,&#8203;? super <a href="KGroupedStream.html" title="type parameter in KGroupedStream">V</a>,&#8203;VOut&gt;&nbsp;aggregator)</code></th>
<td class="colLast">
<div class="block">Create a new <a href="CogroupedKStream.html" title="interface in org.apache.kafka.streams.kstream"><code>CogroupedKStream</code></a> from the this grouped KStream to allow cogrouping other
 <code>KGroupedStream</code> to it.</div>
</td>
</tr>
<tr id="i4" class="altColor">
<td class="colFirst"><code><a href="KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="KGroupedStream.html" title="type parameter in KGroupedStream">K</a>,&#8203;<a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Long.html?is-external=true" title="class or interface in java.lang" class="externalLink">Long</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#count()">count</a></span>()</code></th>
<td class="colLast">
<div class="block">Count the number of records in this stream by the grouped key.</div>
</td>
</tr>
<tr id="i5" class="rowColor">
<td class="colFirst"><code><a href="KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="KGroupedStream.html" title="type parameter in KGroupedStream">K</a>,&#8203;<a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Long.html?is-external=true" title="class or interface in java.lang" class="externalLink">Long</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#count(org.apache.kafka.streams.kstream.Materialized)">count</a></span>&#8203;(<a href="Materialized.html" title="class in org.apache.kafka.streams.kstream">Materialized</a>&lt;<a href="KGroupedStream.html" title="type parameter in KGroupedStream">K</a>,&#8203;<a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Long.html?is-external=true" title="class or interface in java.lang" class="externalLink">Long</a>,&#8203;<a href="../state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state">KeyValueStore</a>&lt;org.apache.kafka.common.utils.Bytes,&#8203;byte[]&gt;&gt;&nbsp;materialized)</code></th>
<td class="colLast">
<div class="block">Count the number of records in this stream by the grouped key.</div>
</td>
</tr>
<tr id="i6" class="altColor">
<td class="colFirst"><code><a href="KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="KGroupedStream.html" title="type parameter in KGroupedStream">K</a>,&#8203;<a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Long.html?is-external=true" title="class or interface in java.lang" class="externalLink">Long</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#count(org.apache.kafka.streams.kstream.Named)">count</a></span>&#8203;(<a href="Named.html" title="class in org.apache.kafka.streams.kstream">Named</a>&nbsp;named)</code></th>
<td class="colLast">
<div class="block">Count the number of records in this stream by the grouped key.</div>
</td>
</tr>
<tr id="i7" class="rowColor">
<td class="colFirst"><code><a href="KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="KGroupedStream.html" title="type parameter in KGroupedStream">K</a>,&#8203;<a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Long.html?is-external=true" title="class or interface in java.lang" class="externalLink">Long</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#count(org.apache.kafka.streams.kstream.Named,org.apache.kafka.streams.kstream.Materialized)">count</a></span>&#8203;(<a href="Named.html" title="class in org.apache.kafka.streams.kstream">Named</a>&nbsp;named,
     <a href="Materialized.html" title="class in org.apache.kafka.streams.kstream">Materialized</a>&lt;<a href="KGroupedStream.html" title="type parameter in KGroupedStream">K</a>,&#8203;<a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Long.html?is-external=true" title="class or interface in java.lang" class="externalLink">Long</a>,&#8203;<a href="../state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state">KeyValueStore</a>&lt;org.apache.kafka.common.utils.Bytes,&#8203;byte[]&gt;&gt;&nbsp;materialized)</code></th>
<td class="colLast">
<div class="block">Count the number of records in this stream by the grouped key.</div>
</td>
</tr>
<tr id="i8" class="altColor">
<td class="colFirst"><code><a href="KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="KGroupedStream.html" title="type parameter in KGroupedStream">K</a>,&#8203;<a href="KGroupedStream.html" title="type parameter in KGroupedStream">V</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#reduce(org.apache.kafka.streams.kstream.Reducer)">reduce</a></span>&#8203;(<a href="Reducer.html" title="interface in org.apache.kafka.streams.kstream">Reducer</a>&lt;<a href="KGroupedStream.html" title="type parameter in KGroupedStream">V</a>&gt;&nbsp;reducer)</code></th>
<td class="colLast">
<div class="block">Combine the values of records in this stream by the grouped key.</div>
</td>
</tr>
<tr id="i9" class="rowColor">
<td class="colFirst"><code><a href="KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="KGroupedStream.html" title="type parameter in KGroupedStream">K</a>,&#8203;<a href="KGroupedStream.html" title="type parameter in KGroupedStream">V</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#reduce(org.apache.kafka.streams.kstream.Reducer,org.apache.kafka.streams.kstream.Materialized)">reduce</a></span>&#8203;(<a href="Reducer.html" title="interface in org.apache.kafka.streams.kstream">Reducer</a>&lt;<a href="KGroupedStream.html" title="type parameter in KGroupedStream">V</a>&gt;&nbsp;reducer,
      <a href="Materialized.html" title="class in org.apache.kafka.streams.kstream">Materialized</a>&lt;<a href="KGroupedStream.html" title="type parameter in KGroupedStream">K</a>,&#8203;<a href="KGroupedStream.html" title="type parameter in KGroupedStream">V</a>,&#8203;<a href="../state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state">KeyValueStore</a>&lt;org.apache.kafka.common.utils.Bytes,&#8203;byte[]&gt;&gt;&nbsp;materialized)</code></th>
<td class="colLast">
<div class="block">Combine the value of records in this stream by the grouped key.</div>
</td>
</tr>
<tr id="i10" class="altColor">
<td class="colFirst"><code><a href="KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="KGroupedStream.html" title="type parameter in KGroupedStream">K</a>,&#8203;<a href="KGroupedStream.html" title="type parameter in KGroupedStream">V</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#reduce(org.apache.kafka.streams.kstream.Reducer,org.apache.kafka.streams.kstream.Named,org.apache.kafka.streams.kstream.Materialized)">reduce</a></span>&#8203;(<a href="Reducer.html" title="interface in org.apache.kafka.streams.kstream">Reducer</a>&lt;<a href="KGroupedStream.html" title="type parameter in KGroupedStream">V</a>&gt;&nbsp;reducer,
      <a href="Named.html" title="class in org.apache.kafka.streams.kstream">Named</a>&nbsp;named,
      <a href="Materialized.html" title="class in org.apache.kafka.streams.kstream">Materialized</a>&lt;<a href="KGroupedStream.html" title="type parameter in KGroupedStream">K</a>,&#8203;<a href="KGroupedStream.html" title="type parameter in KGroupedStream">V</a>,&#8203;<a href="../state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state">KeyValueStore</a>&lt;org.apache.kafka.common.utils.Bytes,&#8203;byte[]&gt;&gt;&nbsp;materialized)</code></th>
<td class="colLast">
<div class="block">Combine the value of records in this stream by the grouped key.</div>
</td>
</tr>
<tr id="i11" class="rowColor">
<td class="colFirst"><code><a href="SessionWindowedKStream.html" title="interface in org.apache.kafka.streams.kstream">SessionWindowedKStream</a>&lt;<a href="KGroupedStream.html" title="type parameter in KGroupedStream">K</a>,&#8203;<a href="KGroupedStream.html" title="type parameter in KGroupedStream">V</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#windowedBy(org.apache.kafka.streams.kstream.SessionWindows)">windowedBy</a></span>&#8203;(<a href="SessionWindows.html" title="class in org.apache.kafka.streams.kstream">SessionWindows</a>&nbsp;windows)</code></th>
<td class="colLast">
<div class="block">Create a new <a href="SessionWindowedKStream.html" title="interface in org.apache.kafka.streams.kstream"><code>SessionWindowedKStream</code></a> instance that can be used to perform session windowed aggregations.</div>
</td>
</tr>
<tr id="i12" class="altColor">
<td class="colFirst"><code><a href="TimeWindowedKStream.html" title="interface in org.apache.kafka.streams.kstream">TimeWindowedKStream</a>&lt;<a href="KGroupedStream.html" title="type parameter in KGroupedStream">K</a>,&#8203;<a href="KGroupedStream.html" title="type parameter in KGroupedStream">V</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#windowedBy(org.apache.kafka.streams.kstream.SlidingWindows)">windowedBy</a></span>&#8203;(<a href="SlidingWindows.html" title="class in org.apache.kafka.streams.kstream">SlidingWindows</a>&nbsp;windows)</code></th>
<td class="colLast">
<div class="block">Create a new <a href="TimeWindowedKStream.html" title="interface in org.apache.kafka.streams.kstream"><code>TimeWindowedKStream</code></a> instance that can be used to perform sliding windowed aggregations.</div>
</td>
</tr>
<tr id="i13" class="rowColor">
<td class="colFirst"><code>&lt;W extends <a href="Window.html" title="class in org.apache.kafka.streams.kstream">Window</a>&gt;<br><a href="TimeWindowedKStream.html" title="interface in org.apache.kafka.streams.kstream">TimeWindowedKStream</a>&lt;<a href="KGroupedStream.html" title="type parameter in KGroupedStream">K</a>,&#8203;<a href="KGroupedStream.html" title="type parameter in KGroupedStream">V</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#windowedBy(org.apache.kafka.streams.kstream.Windows)">windowedBy</a></span>&#8203;(<a href="Windows.html" title="class in org.apache.kafka.streams.kstream">Windows</a>&lt;W&gt;&nbsp;windows)</code></th>
<td class="colLast">
<div class="block">Create a new <a href="TimeWindowedKStream.html" title="interface in org.apache.kafka.streams.kstream"><code>TimeWindowedKStream</code></a> instance that can be used to perform windowed aggregations.</div>
</td>
</tr>
</table>
</li>
</ul>
</section>
</li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ============ METHOD DETAIL ========== -->
<section role="region">
<ul class="blockList">
<li class="blockList"><a id="method.detail">
<!--   -->
</a>
<h3>Method Detail</h3>
<a id="count()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>count</h4>
<pre class="methodSignature"><a href="KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="KGroupedStream.html" title="type parameter in KGroupedStream">K</a>,&#8203;<a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Long.html?is-external=true" title="class or interface in java.lang" class="externalLink">Long</a>&gt;&nbsp;count()</pre>
<div class="block">Count the number of records in this stream by the grouped key.
 Records with <code>null</code> key or value are ignored.
 The result is written into a local <a href="../state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state"><code>KeyValueStore</code></a> (which is basically an ever-updating materialized view).
 Furthermore, updates to the store are sent downstream into a <a href="KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> changelog stream.
 <p>
 Not all updates might get sent downstream, as an internal cache is used to deduplicate consecutive updates to
 the same key.
 The rate of propagated updates depends on your input data rate, the number of distinct keys, the number of
 parallel running Kafka Streams instances, and the <a href="../StreamsConfig.html" title="class in org.apache.kafka.streams"><code>configuration</code></a> parameters for
 <a href="../StreamsConfig.html#CACHE_MAX_BYTES_BUFFERING_CONFIG"><code>cache size</code></a>, and
 <a href="../StreamsConfig.html#COMMIT_INTERVAL_MS_CONFIG"><code>commit interval</code></a>.
 <p>
 For failure and recovery the store (which always will be of type <a href="../state/TimestampedKeyValueStore.html" title="interface in org.apache.kafka.streams.state"><code>TimestampedKeyValueStore</code></a>) will be backed by
 an internal changelog topic that will be created in Kafka.
 The changelog topic will be named "${applicationId}-${internalStoreName}-changelog", where "applicationId" is
 user-specified in <a href="../StreamsConfig.html" title="class in org.apache.kafka.streams"><code>StreamsConfig</code></a> via parameter
 <a href="../StreamsConfig.html#APPLICATION_ID_CONFIG"><code>APPLICATION_ID_CONFIG</code></a>, "internalStoreName" is an internal name
 and "-changelog" is a fixed suffix.
 Note that the internal store name may not be queryable through Interactive Queries.

 You can retrieve all generated internal topic names via <a href="../Topology.html#describe()"><code>Topology.describe()</code></a>.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a <a href="KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> that contains "update" records with unmodified keys and <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Long.html?is-external=true" title="class or interface in java.lang" class="externalLink"><code>Long</code></a> values that
 represent the latest (rolling) count (i.e., number of records) for each key</dd>
</dl>
</li>
</ul>
<a id="count(org.apache.kafka.streams.kstream.Named)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>count</h4>
<pre class="methodSignature"><a href="KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="KGroupedStream.html" title="type parameter in KGroupedStream">K</a>,&#8203;<a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Long.html?is-external=true" title="class or interface in java.lang" class="externalLink">Long</a>&gt;&nbsp;count&#8203;(<a href="Named.html" title="class in org.apache.kafka.streams.kstream">Named</a>&nbsp;named)</pre>
<div class="block">Count the number of records in this stream by the grouped key.
 Records with <code>null</code> key or value are ignored.
 The result is written into a local <a href="../state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state"><code>KeyValueStore</code></a> (which is basically an ever-updating materialized view).
 Furthermore, updates to the store are sent downstream into a <a href="KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> changelog stream.
 <p>
 Not all updates might get sent downstream, as an internal cache is used to deduplicate consecutive updates to
 the same key.
 The rate of propagated updates depends on your input data rate, the number of distinct keys, the number of
 parallel running Kafka Streams instances, and the <a href="../StreamsConfig.html" title="class in org.apache.kafka.streams"><code>configuration</code></a> parameters for
 <a href="../StreamsConfig.html#CACHE_MAX_BYTES_BUFFERING_CONFIG"><code>cache size</code></a>, and
 <a href="../StreamsConfig.html#COMMIT_INTERVAL_MS_CONFIG"><code>commit interval</code></a>.
 <p>
 For failure and recovery the store (which always will be of type <a href="../state/TimestampedKeyValueStore.html" title="interface in org.apache.kafka.streams.state"><code>TimestampedKeyValueStore</code></a>) will be backed by
 an internal changelog topic that will be created in Kafka.
 The changelog topic will be named "${applicationId}-${internalStoreName}-changelog", where "applicationId" is
 user-specified in <a href="../StreamsConfig.html" title="class in org.apache.kafka.streams"><code>StreamsConfig</code></a> via parameter
 <a href="../StreamsConfig.html#APPLICATION_ID_CONFIG"><code>APPLICATION_ID_CONFIG</code></a>, "internalStoreName" is an internal name
 and "-changelog" is a fixed suffix.
 Note that the internal store name may not be queryable through Interactive Queries.

 You can retrieve all generated internal topic names via <a href="../Topology.html#describe()"><code>Topology.describe()</code></a>.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>named</code> - a <a href="Named.html" title="class in org.apache.kafka.streams.kstream"><code>Named</code></a> config used to name the processor in the topology</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a <a href="KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> that contains "update" records with unmodified keys and <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Long.html?is-external=true" title="class or interface in java.lang" class="externalLink"><code>Long</code></a> values that
 represent the latest (rolling) count (i.e., number of records) for each key</dd>
</dl>
</li>
</ul>
<a id="count(org.apache.kafka.streams.kstream.Materialized)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>count</h4>
<pre class="methodSignature"><a href="KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="KGroupedStream.html" title="type parameter in KGroupedStream">K</a>,&#8203;<a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Long.html?is-external=true" title="class or interface in java.lang" class="externalLink">Long</a>&gt;&nbsp;count&#8203;(<a href="Materialized.html" title="class in org.apache.kafka.streams.kstream">Materialized</a>&lt;<a href="KGroupedStream.html" title="type parameter in KGroupedStream">K</a>,&#8203;<a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Long.html?is-external=true" title="class or interface in java.lang" class="externalLink">Long</a>,&#8203;<a href="../state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state">KeyValueStore</a>&lt;org.apache.kafka.common.utils.Bytes,&#8203;byte[]&gt;&gt;&nbsp;materialized)</pre>
<div class="block">Count the number of records in this stream by the grouped key.
 Records with <code>null</code> key or value are ignored.
 The result is written into a local <a href="../state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state"><code>KeyValueStore</code></a> (which is basically an ever-updating materialized view)
 provided by the given store name in <code>materialized</code>.
 Furthermore, updates to the store are sent downstream into a <a href="KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> changelog stream.
 <p>
 Not all updates might get sent downstream, as an internal cache is used to deduplicate consecutive updates to
 the same key.
 The rate of propagated updates depends on your input data rate, the number of distinct keys, the number of
 parallel running Kafka Streams instances, and the <a href="../StreamsConfig.html" title="class in org.apache.kafka.streams"><code>configuration</code></a> parameters for
 <a href="../StreamsConfig.html#CACHE_MAX_BYTES_BUFFERING_CONFIG"><code>cache size</code></a>, and
 <a href="../StreamsConfig.html#COMMIT_INTERVAL_MS_CONFIG"><code>commit interval</code></a>.
 <p>
 To query the local <a href="../state/ReadOnlyKeyValueStore.html" title="interface in org.apache.kafka.streams.state"><code>ReadOnlyKeyValueStore</code></a> it must be obtained via
 <a href="../KafkaStreams.html#store(org.apache.kafka.streams.StoreQueryParameters)"><code>KafkaStreams#store(...)</code></a>.
 <pre><code>
 KafkaStreams streams = ... // counting words
 String queryableStoreName = "storeName"; // the store name should be the name of the store as defined by the Materialized instance
 ReadOnlyKeyValueStore&lt;K, ValueAndTimestamp&lt;Long&gt;&gt; localStore = streams.store(queryableStoreName, QueryableStoreTypes.&lt;K, ValueAndTimestamp&lt;Long&gt;&gt;timestampedKeyValueStore());
 K key = "some-word";
 ValueAndTimestamp&lt;Long&gt; countForWord = localStore.get(key); // key must be local (application state is shared over all running Kafka Streams instances)
 </code></pre>
 For non-local keys, a custom RPC mechanism must be implemented using <a href="../KafkaStreams.html#allMetadata()"><code>KafkaStreams.allMetadata()</code></a> to
 query the value of the key on a parallel running instance of your Kafka Streams application.

 <p>
 For failure and recovery the store (which always will be of type <a href="../state/TimestampedKeyValueStore.html" title="interface in org.apache.kafka.streams.state"><code>TimestampedKeyValueStore</code></a> -- regardless of what
 is specified in the parameter <code>materialized</code>) will be backed by an internal changelog topic that will be created in Kafka.
 Therefore, the store name defined by the Materialized instance must be a valid Kafka topic name and cannot contain characters other than ASCII
 alphanumerics, '.', '_' and '-'.
 The changelog topic will be named "${applicationId}-${storeName}-changelog", where "applicationId" is
 user-specified in <a href="../StreamsConfig.html" title="class in org.apache.kafka.streams"><code>StreamsConfig</code></a> via parameter
 <a href="../StreamsConfig.html#APPLICATION_ID_CONFIG"><code>APPLICATION_ID_CONFIG</code></a>, "storeName" is the
 provide store name defined in <code>Materialized</code>, and "-changelog" is a fixed suffix.

 You can retrieve all generated internal topic names via <a href="../Topology.html#describe()"><code>Topology.describe()</code></a>.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>materialized</code> - an instance of <a href="Materialized.html" title="class in org.apache.kafka.streams.kstream"><code>Materialized</code></a> used to materialize a state store. Cannot be <code>null</code>.
                      Note: the valueSerde will be automatically set to <a href="../../common/serialization/Serdes.html#Long()"><code>Serdes#Long()</code></a>
                      if there is no valueSerde provided</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a <a href="KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> that contains "update" records with unmodified keys and <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Long.html?is-external=true" title="class or interface in java.lang" class="externalLink"><code>Long</code></a> values that
 represent the latest (rolling) count (i.e., number of records) for each key</dd>
</dl>
</li>
</ul>
<a id="count(org.apache.kafka.streams.kstream.Named,org.apache.kafka.streams.kstream.Materialized)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>count</h4>
<pre class="methodSignature"><a href="KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="KGroupedStream.html" title="type parameter in KGroupedStream">K</a>,&#8203;<a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Long.html?is-external=true" title="class or interface in java.lang" class="externalLink">Long</a>&gt;&nbsp;count&#8203;(<a href="Named.html" title="class in org.apache.kafka.streams.kstream">Named</a>&nbsp;named,
                           <a href="Materialized.html" title="class in org.apache.kafka.streams.kstream">Materialized</a>&lt;<a href="KGroupedStream.html" title="type parameter in KGroupedStream">K</a>,&#8203;<a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Long.html?is-external=true" title="class or interface in java.lang" class="externalLink">Long</a>,&#8203;<a href="../state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state">KeyValueStore</a>&lt;org.apache.kafka.common.utils.Bytes,&#8203;byte[]&gt;&gt;&nbsp;materialized)</pre>
<div class="block">Count the number of records in this stream by the grouped key.
 Records with <code>null</code> key or value are ignored.
 The result is written into a local <a href="../state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state"><code>KeyValueStore</code></a> (which is basically an ever-updating materialized view)
 provided by the given store name in <code>materialized</code>.
 Furthermore, updates to the store are sent downstream into a <a href="KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> changelog stream.
 <p>
 Not all updates might get sent downstream, as an internal cache is used to deduplicate consecutive updates to
 the same key.
 The rate of propagated updates depends on your input data rate, the number of distinct keys, the number of
 parallel running Kafka Streams instances, and the <a href="../StreamsConfig.html" title="class in org.apache.kafka.streams"><code>configuration</code></a> parameters for
 <a href="../StreamsConfig.html#CACHE_MAX_BYTES_BUFFERING_CONFIG"><code>cache size</code></a>, and
 <a href="../StreamsConfig.html#COMMIT_INTERVAL_MS_CONFIG"><code>commit interval</code></a>.
 <p>
 To query the local <a href="../state/ReadOnlyKeyValueStore.html" title="interface in org.apache.kafka.streams.state"><code>ReadOnlyKeyValueStore</code></a> it must be obtained via
 <a href="../KafkaStreams.html#store(org.apache.kafka.streams.StoreQueryParameters)"><code>KafkaStreams#store(...)</code></a>.
 <pre><code>
 KafkaStreams streams = ... // counting words
 String queryableStoreName = "storeName"; // the store name should be the name of the store as defined by the Materialized instance
 ReadOnlyKeyValueStore&lt;K, ValueAndTimestamp&lt;Long&gt;&gt; localStore = streams.store(queryableStoreName, QueryableStoreTypes.&lt;K, ValueAndTimestamp&lt;Long&gt;&gt;timestampedKeyValueStore());
 K key = "some-word";
 ValueAndTimestamp&lt;Long&gt; countForWord = localStore.get(key); // key must be local (application state is shared over all running Kafka Streams instances)
 </code></pre>
 For non-local keys, a custom RPC mechanism must be implemented using <a href="../KafkaStreams.html#allMetadata()"><code>KafkaStreams.allMetadata()</code></a> to
 query the value of the key on a parallel running instance of your Kafka Streams application.

 <p>
 For failure and recovery the store (which always will be of type <a href="../state/TimestampedKeyValueStore.html" title="interface in org.apache.kafka.streams.state"><code>TimestampedKeyValueStore</code></a> -- regardless of what
 is specified in the parameter <code>materialized</code>) will be backed by an internal changelog topic that will be created in Kafka.
 Therefore, the store name defined by the Materialized instance must be a valid Kafka topic name and cannot contain characters other than ASCII
 alphanumerics, '.', '_' and '-'.
 The changelog topic will be named "${applicationId}-${storeName}-changelog", where "applicationId" is
 user-specified in <a href="../StreamsConfig.html" title="class in org.apache.kafka.streams"><code>StreamsConfig</code></a> via parameter
 <a href="../StreamsConfig.html#APPLICATION_ID_CONFIG"><code>APPLICATION_ID_CONFIG</code></a>, "storeName" is the
 provide store name defined in <code>Materialized</code>, and "-changelog" is a fixed suffix.

 You can retrieve all generated internal topic names via <a href="../Topology.html#describe()"><code>Topology.describe()</code></a>.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>named</code> - a <a href="Named.html" title="class in org.apache.kafka.streams.kstream"><code>Named</code></a> config used to name the processor in the topology</dd>
<dd><code>materialized</code> - an instance of <a href="Materialized.html" title="class in org.apache.kafka.streams.kstream"><code>Materialized</code></a> used to materialize a state store. Cannot be <code>null</code>.
                      Note: the valueSerde will be automatically set to <a href="../../common/serialization/Serdes.html#Long()"><code>Serdes#Long()</code></a>
                      if there is no valueSerde provided</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a <a href="KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> that contains "update" records with unmodified keys and <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Long.html?is-external=true" title="class or interface in java.lang" class="externalLink"><code>Long</code></a> values that
 represent the latest (rolling) count (i.e., number of records) for each key</dd>
</dl>
</li>
</ul>
<a id="reduce(org.apache.kafka.streams.kstream.Reducer)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>reduce</h4>
<pre class="methodSignature"><a href="KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="KGroupedStream.html" title="type parameter in KGroupedStream">K</a>,&#8203;<a href="KGroupedStream.html" title="type parameter in KGroupedStream">V</a>&gt;&nbsp;reduce&#8203;(<a href="Reducer.html" title="interface in org.apache.kafka.streams.kstream">Reducer</a>&lt;<a href="KGroupedStream.html" title="type parameter in KGroupedStream">V</a>&gt;&nbsp;reducer)</pre>
<div class="block">Combine the values of records in this stream by the grouped key.
 Records with <code>null</code> key or value are ignored.
 Combining implies that the type of the aggregate result is the same as the type of the input value
 (c.f. <a href="#aggregate(org.apache.kafka.streams.kstream.Initializer,org.apache.kafka.streams.kstream.Aggregator)"><code>aggregate(Initializer, Aggregator)</code></a>).
 <p>
 The specified <a href="Reducer.html" title="interface in org.apache.kafka.streams.kstream"><code>Reducer</code></a> is applied for each input record and computes a new aggregate using the current
 aggregate and the record's value.
 If there is no current aggregate the <a href="Reducer.html" title="interface in org.apache.kafka.streams.kstream"><code>Reducer</code></a> is not applied and the new aggregate will be the record's
 value as-is.
 Thus, <code>reduce(Reducer)</code> can be used to compute aggregate functions like sum, min, or max.
 <p>
 Not all updates might get sent downstream, as an internal cache is used to deduplicate consecutive updates to
 the same key.
 The rate of propagated updates depends on your input data rate, the number of distinct keys, the number of
 parallel running Kafka Streams instances, and the <a href="../StreamsConfig.html" title="class in org.apache.kafka.streams"><code>configuration</code></a> parameters for
 <a href="../StreamsConfig.html#CACHE_MAX_BYTES_BUFFERING_CONFIG"><code>cache size</code></a>, and
 <a href="../StreamsConfig.html#COMMIT_INTERVAL_MS_CONFIG"><code>commit interval</code></a>.

 <p>
 For failure and recovery the store (which always will be of type <a href="../state/TimestampedKeyValueStore.html" title="interface in org.apache.kafka.streams.state"><code>TimestampedKeyValueStore</code></a>) will be backed by
 an internal changelog topic that will be created in Kafka.
 The changelog topic will be named "${applicationId}-${internalStoreName}-changelog", where "applicationId" is
 user-specified in <a href="../StreamsConfig.html" title="class in org.apache.kafka.streams"><code>StreamsConfig</code></a> via parameter
 <a href="../StreamsConfig.html#APPLICATION_ID_CONFIG"><code>APPLICATION_ID_CONFIG</code></a>, "internalStoreName" is an internal name
 and "-changelog" is a fixed suffix.
 Note that the internal store name may not be queryable through Interactive Queries.

 You can retrieve all generated internal topic names via <a href="../Topology.html#describe()"><code>Topology.describe()</code></a>.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>reducer</code> - a <a href="Reducer.html" title="interface in org.apache.kafka.streams.kstream"><code>Reducer</code></a> that computes a new aggregate result. Cannot be <code>null</code>.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a <a href="KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> that contains "update" records with unmodified keys, and values that represent the
 latest (rolling) aggregate for each key. If the reduce function returns <code>null</code>, it is then interpreted as
 deletion for the key, and future messages of the same key coming from upstream operators
 will be handled as newly initialized value.</dd>
</dl>
</li>
</ul>
<a id="reduce(org.apache.kafka.streams.kstream.Reducer,org.apache.kafka.streams.kstream.Materialized)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>reduce</h4>
<pre class="methodSignature"><a href="KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="KGroupedStream.html" title="type parameter in KGroupedStream">K</a>,&#8203;<a href="KGroupedStream.html" title="type parameter in KGroupedStream">V</a>&gt;&nbsp;reduce&#8203;(<a href="Reducer.html" title="interface in org.apache.kafka.streams.kstream">Reducer</a>&lt;<a href="KGroupedStream.html" title="type parameter in KGroupedStream">V</a>&gt;&nbsp;reducer,
                         <a href="Materialized.html" title="class in org.apache.kafka.streams.kstream">Materialized</a>&lt;<a href="KGroupedStream.html" title="type parameter in KGroupedStream">K</a>,&#8203;<a href="KGroupedStream.html" title="type parameter in KGroupedStream">V</a>,&#8203;<a href="../state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state">KeyValueStore</a>&lt;org.apache.kafka.common.utils.Bytes,&#8203;byte[]&gt;&gt;&nbsp;materialized)</pre>
<div class="block">Combine the value of records in this stream by the grouped key.
 Records with <code>null</code> key or value are ignored.
 Combining implies that the type of the aggregate result is the same as the type of the input value
 (c.f. <a href="#aggregate(org.apache.kafka.streams.kstream.Initializer,org.apache.kafka.streams.kstream.Aggregator,org.apache.kafka.streams.kstream.Materialized)"><code>aggregate(Initializer, Aggregator, Materialized)</code></a>).
 The result is written into a local <a href="../state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state"><code>KeyValueStore</code></a> (which is basically an ever-updating materialized view)
 provided by the given store name in <code>materialized</code>.
 Furthermore, updates to the store are sent downstream into a <a href="KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> changelog stream.
 <p>
 The specified <a href="Reducer.html" title="interface in org.apache.kafka.streams.kstream"><code>Reducer</code></a> is applied for each input record and computes a new aggregate using the current
 aggregate (first argument) and the record's value (second argument):
 <pre><code>
 // At the example of a Reducer&lt;Long&gt;
 new Reducer&lt;Long&gt;() {
   public Long apply(Long aggValue, Long currValue) {
     return aggValue + currValue;
   }
 }
 </code></pre>
 <p>
 If there is no current aggregate the <a href="Reducer.html" title="interface in org.apache.kafka.streams.kstream"><code>Reducer</code></a> is not applied and the new aggregate will be the record's
 value as-is.
 Thus, <code>reduce(Reducer, Materialized)</code> can be used to compute aggregate functions like sum, min, or
 max.
 <p>
 Not all updates might get sent downstream, as an internal cache is used to deduplicate consecutive updates to
 the same key.
 The rate of propagated updates depends on your input data rate, the number of distinct keys, the number of
 parallel running Kafka Streams instances, and the <a href="../StreamsConfig.html" title="class in org.apache.kafka.streams"><code>configuration</code></a> parameters for
 <a href="../StreamsConfig.html#CACHE_MAX_BYTES_BUFFERING_CONFIG"><code>cache size</code></a>, and
 <a href="../StreamsConfig.html#COMMIT_INTERVAL_MS_CONFIG"><code>commit interval</code></a>.
 <p>
 To query the local <a href="../state/ReadOnlyKeyValueStore.html" title="interface in org.apache.kafka.streams.state"><code>ReadOnlyKeyValueStore</code></a> it must be obtained via
 <a href="../KafkaStreams.html#store(org.apache.kafka.streams.StoreQueryParameters)"><code>KafkaStreams#store(...)</code></a>.
 <pre><code>
 KafkaStreams streams = ... // compute sum
 String queryableStoreName = "storeName" // the store name should be the name of the store as defined by the Materialized instance
 ReadOnlyKeyValueStore&lt;K, ValueAndTimestamp&lt;V&gt;&gt; localStore = streams.store(queryableStoreName, QueryableStoreTypes.&lt;K, ValueAndTimestamp&lt;V&gt;&gt;timestampedKeyValueStore());
 K key = "some-key";
 ValueAndTimestamp&lt;V&gt; reduceForKey = localStore.get(key); // key must be local (application state is shared over all running Kafka Streams instances)
 </code></pre>
 For non-local keys, a custom RPC mechanism must be implemented using <a href="../KafkaStreams.html#allMetadata()"><code>KafkaStreams.allMetadata()</code></a> to
 query the value of the key on a parallel running instance of your Kafka Streams application.

 <p>
 For failure and recovery the store (which always will be of type <a href="../state/TimestampedKeyValueStore.html" title="interface in org.apache.kafka.streams.state"><code>TimestampedKeyValueStore</code></a> -- regardless of what
 is specified in the parameter <code>materialized</code>) will be backed by an internal changelog topic that will be created in Kafka.
 The changelog topic will be named "${applicationId}-${internalStoreName}-changelog", where "applicationId" is
 user-specified in <a href="../StreamsConfig.html" title="class in org.apache.kafka.streams"><code>StreamsConfig</code></a> via parameter
 <a href="../StreamsConfig.html#APPLICATION_ID_CONFIG"><code>APPLICATION_ID_CONFIG</code></a>, "internalStoreName" is an internal name
 and "-changelog" is a fixed suffix.
 Note that the internal store name may not be queryable through Interactive Queries.

 You can retrieve all generated internal topic names via <a href="../Topology.html#describe()"><code>Topology.describe()</code></a>.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>reducer</code> - a <a href="Reducer.html" title="interface in org.apache.kafka.streams.kstream"><code>Reducer</code></a> that computes a new aggregate result. Cannot be <code>null</code>.</dd>
<dd><code>materialized</code> - an instance of <a href="Materialized.html" title="class in org.apache.kafka.streams.kstream"><code>Materialized</code></a> used to materialize a state store. Cannot be <code>null</code>.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a <a href="KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> that contains "update" records with unmodified keys, and values that represent the
 latest (rolling) aggregate for each key</dd>
</dl>
</li>
</ul>
<a id="reduce(org.apache.kafka.streams.kstream.Reducer,org.apache.kafka.streams.kstream.Named,org.apache.kafka.streams.kstream.Materialized)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>reduce</h4>
<pre class="methodSignature"><a href="KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="KGroupedStream.html" title="type parameter in KGroupedStream">K</a>,&#8203;<a href="KGroupedStream.html" title="type parameter in KGroupedStream">V</a>&gt;&nbsp;reduce&#8203;(<a href="Reducer.html" title="interface in org.apache.kafka.streams.kstream">Reducer</a>&lt;<a href="KGroupedStream.html" title="type parameter in KGroupedStream">V</a>&gt;&nbsp;reducer,
                         <a href="Named.html" title="class in org.apache.kafka.streams.kstream">Named</a>&nbsp;named,
                         <a href="Materialized.html" title="class in org.apache.kafka.streams.kstream">Materialized</a>&lt;<a href="KGroupedStream.html" title="type parameter in KGroupedStream">K</a>,&#8203;<a href="KGroupedStream.html" title="type parameter in KGroupedStream">V</a>,&#8203;<a href="../state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state">KeyValueStore</a>&lt;org.apache.kafka.common.utils.Bytes,&#8203;byte[]&gt;&gt;&nbsp;materialized)</pre>
<div class="block">Combine the value of records in this stream by the grouped key.
 Records with <code>null</code> key or value are ignored.
 Combining implies that the type of the aggregate result is the same as the type of the input value
 (c.f. <a href="#aggregate(org.apache.kafka.streams.kstream.Initializer,org.apache.kafka.streams.kstream.Aggregator,org.apache.kafka.streams.kstream.Materialized)"><code>aggregate(Initializer, Aggregator, Materialized)</code></a>).
 The result is written into a local <a href="../state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state"><code>KeyValueStore</code></a> (which is basically an ever-updating materialized view)
 provided by the given store name in <code>materialized</code>.
 Furthermore, updates to the store are sent downstream into a <a href="KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> changelog stream.
 <p>
 The specified <a href="Reducer.html" title="interface in org.apache.kafka.streams.kstream"><code>Reducer</code></a> is applied for each input record and computes a new aggregate using the current
 aggregate (first argument) and the record's value (second argument):
 <pre><code>
 // At the example of a Reducer&lt;Long&gt;
 new Reducer&lt;Long&gt;() {
   public Long apply(Long aggValue, Long currValue) {
     return aggValue + currValue;
   }
 }
 </code></pre>
 <p>
 If there is no current aggregate the <a href="Reducer.html" title="interface in org.apache.kafka.streams.kstream"><code>Reducer</code></a> is not applied and the new aggregate will be the record's
 value as-is.
 Thus, <code>reduce(Reducer, Materialized)</code> can be used to compute aggregate functions like sum, min, or
 max.
 <p>
 Not all updates might get sent downstream, as an internal cache is used to deduplicate consecutive updates to
 the same key.
 The rate of propagated updates depends on your input data rate, the number of distinct keys, the number of
 parallel running Kafka Streams instances, and the <a href="../StreamsConfig.html" title="class in org.apache.kafka.streams"><code>configuration</code></a> parameters for
 <a href="../StreamsConfig.html#CACHE_MAX_BYTES_BUFFERING_CONFIG"><code>cache size</code></a>, and
 <a href="../StreamsConfig.html#COMMIT_INTERVAL_MS_CONFIG"><code>commit interval</code></a>.
 <p>
 To query the local <a href="../state/ReadOnlyKeyValueStore.html" title="interface in org.apache.kafka.streams.state"><code>ReadOnlyKeyValueStore</code></a> it must be obtained via
 <a href="../KafkaStreams.html#store(org.apache.kafka.streams.StoreQueryParameters)"><code>KafkaStreams#store(...)</code></a>.
 <pre><code>
 KafkaStreams streams = ... // compute sum
 String queryableStoreName = "storeName" // the store name should be the name of the store as defined by the Materialized instance
 ReadOnlyKeyValueStore&lt;K, ValueAndTimestamp&lt;V&gt;&gt; localStore = streams.store(queryableStoreName, QueryableStoreTypes.&lt;K, ValueAndTimestamp&lt;V&gt;&gt;timestampedKeyValueStore());
 K key = "some-key";
 ValueAndTimestamp&lt;V&gt; reduceForKey = localStore.get(key); // key must be local (application state is shared over all running Kafka Streams instances)
 </code></pre>
 For non-local keys, a custom RPC mechanism must be implemented using <a href="../KafkaStreams.html#allMetadata()"><code>KafkaStreams.allMetadata()</code></a> to
 query the value of the key on a parallel running instance of your Kafka Streams application.

 <p>
 For failure and recovery the store (which always will be of type <a href="../state/TimestampedKeyValueStore.html" title="interface in org.apache.kafka.streams.state"><code>TimestampedKeyValueStore</code></a> -- regardless of what
 is specified in the parameter <code>materialized</code>) will be backed by an internal changelog topic that will be created in Kafka.
 The changelog topic will be named "${applicationId}-${internalStoreName}-changelog", where "applicationId" is
 user-specified in <a href="../StreamsConfig.html" title="class in org.apache.kafka.streams"><code>StreamsConfig</code></a> via parameter
 <a href="../StreamsConfig.html#APPLICATION_ID_CONFIG"><code>APPLICATION_ID_CONFIG</code></a>, "internalStoreName" is an internal name
 and "-changelog" is a fixed suffix.
 Note that the internal store name may not be queryable through Interactive Queries.

 You can retrieve all generated internal topic names via <a href="../Topology.html#describe()"><code>Topology.describe()</code></a>.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>reducer</code> - a <a href="Reducer.html" title="interface in org.apache.kafka.streams.kstream"><code>Reducer</code></a> that computes a new aggregate result. Cannot be <code>null</code>.</dd>
<dd><code>named</code> - a <a href="Named.html" title="class in org.apache.kafka.streams.kstream"><code>Named</code></a> config used to name the processor in the topology.</dd>
<dd><code>materialized</code> - an instance of <a href="Materialized.html" title="class in org.apache.kafka.streams.kstream"><code>Materialized</code></a> used to materialize a state store. Cannot be <code>null</code>.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a <a href="KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> that contains "update" records with unmodified keys, and values that represent the
 latest (rolling) aggregate for each key. If the reduce function returns <code>null</code>, it is then interpreted as
 deletion for the key, and future messages of the same key coming from upstream operators
 will be handled as newly initialized value.</dd>
</dl>
</li>
</ul>
<a id="aggregate(org.apache.kafka.streams.kstream.Initializer,org.apache.kafka.streams.kstream.Aggregator)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>aggregate</h4>
<pre class="methodSignature">&lt;VR&gt;&nbsp;<a href="KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="KGroupedStream.html" title="type parameter in KGroupedStream">K</a>,&#8203;VR&gt;&nbsp;aggregate&#8203;(<a href="Initializer.html" title="interface in org.apache.kafka.streams.kstream">Initializer</a>&lt;VR&gt;&nbsp;initializer,
                                  <a href="Aggregator.html" title="interface in org.apache.kafka.streams.kstream">Aggregator</a>&lt;? super <a href="KGroupedStream.html" title="type parameter in KGroupedStream">K</a>,&#8203;? super <a href="KGroupedStream.html" title="type parameter in KGroupedStream">V</a>,&#8203;VR&gt;&nbsp;aggregator)</pre>
<div class="block">Aggregate the values of records in this stream by the grouped key.
 Records with <code>null</code> key or value are ignored.
 Aggregating is a generalization of <a href="#reduce(org.apache.kafka.streams.kstream.Reducer)"><code>combining via reduce(...)</code></a> as it, for example,
 allows the result to have a different type than the input values.
 <p>
 The specified <a href="Initializer.html" title="interface in org.apache.kafka.streams.kstream"><code>Initializer</code></a> is applied once directly before the first input record is processed to
 provide an initial intermediate aggregation result that is used to process the first record.
 The specified <a href="Aggregator.html" title="interface in org.apache.kafka.streams.kstream"><code>Aggregator</code></a> is applied for each input record and computes a new aggregate using the current
 aggregate (or for the very first record using the intermediate aggregation result provided via the
 <a href="Initializer.html" title="interface in org.apache.kafka.streams.kstream"><code>Initializer</code></a>) and the record's value.
 Thus, <code>aggregate(Initializer, Aggregator)</code> can be used to compute aggregate functions like
 count (c.f. <a href="#count()"><code>count()</code></a>).
 <p>
 The default value serde from config will be used for serializing the result.
 If a different serde is required then you should use <a href="#aggregate(org.apache.kafka.streams.kstream.Initializer,org.apache.kafka.streams.kstream.Aggregator,org.apache.kafka.streams.kstream.Materialized)"><code>aggregate(Initializer, Aggregator, Materialized)</code></a>.
 <p>
 Not all updates might get sent downstream, as an internal cache is used to deduplicate consecutive updates to
 the same key.
 The rate of propagated updates depends on your input data rate, the number of distinct keys, the number of
 parallel running Kafka Streams instances, and the <a href="../StreamsConfig.html" title="class in org.apache.kafka.streams"><code>configuration</code></a> parameters for
 <a href="../StreamsConfig.html#CACHE_MAX_BYTES_BUFFERING_CONFIG"><code>cache size</code></a>, and
 <a href="../StreamsConfig.html#COMMIT_INTERVAL_MS_CONFIG"><code>commit interval</code></a>.

 <p>
 For failure and recovery the store (which always will be of type <a href="../state/TimestampedKeyValueStore.html" title="interface in org.apache.kafka.streams.state"><code>TimestampedKeyValueStore</code></a>) will be backed by
 an internal changelog topic that will be created in Kafka.
 The changelog topic will be named "${applicationId}-${internalStoreName}-changelog", where "applicationId" is
 user-specified in <a href="../StreamsConfig.html" title="class in org.apache.kafka.streams"><code>StreamsConfig</code></a> via parameter
 <a href="../StreamsConfig.html#APPLICATION_ID_CONFIG"><code>APPLICATION_ID_CONFIG</code></a>, "internalStoreName" is an internal name
 and "-changelog" is a fixed suffix.
 Note that the internal store name may not be queryable through Interactive Queries.

 You can retrieve all generated internal topic names via <a href="../Topology.html#describe()"><code>Topology.describe()</code></a>.</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>VR</code> - the value type of the resulting <a href="KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>initializer</code> - an <a href="Initializer.html" title="interface in org.apache.kafka.streams.kstream"><code>Initializer</code></a> that computes an initial intermediate aggregation result</dd>
<dd><code>aggregator</code> - an <a href="Aggregator.html" title="interface in org.apache.kafka.streams.kstream"><code>Aggregator</code></a> that computes a new aggregate result</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a <a href="KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> that contains "update" records with unmodified keys, and values that represent the
 latest (rolling) aggregate for each key. If the aggregate function returns <code>null</code>, it is then interpreted as
 deletion for the key, and future messages of the same key coming from upstream operators
 will be handled as newly initialized value.</dd>
</dl>
</li>
</ul>
<a id="aggregate(org.apache.kafka.streams.kstream.Initializer,org.apache.kafka.streams.kstream.Aggregator,org.apache.kafka.streams.kstream.Materialized)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>aggregate</h4>
<pre class="methodSignature">&lt;VR&gt;&nbsp;<a href="KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="KGroupedStream.html" title="type parameter in KGroupedStream">K</a>,&#8203;VR&gt;&nbsp;aggregate&#8203;(<a href="Initializer.html" title="interface in org.apache.kafka.streams.kstream">Initializer</a>&lt;VR&gt;&nbsp;initializer,
                                  <a href="Aggregator.html" title="interface in org.apache.kafka.streams.kstream">Aggregator</a>&lt;? super <a href="KGroupedStream.html" title="type parameter in KGroupedStream">K</a>,&#8203;? super <a href="KGroupedStream.html" title="type parameter in KGroupedStream">V</a>,&#8203;VR&gt;&nbsp;aggregator,
                                  <a href="Materialized.html" title="class in org.apache.kafka.streams.kstream">Materialized</a>&lt;<a href="KGroupedStream.html" title="type parameter in KGroupedStream">K</a>,&#8203;VR,&#8203;<a href="../state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state">KeyValueStore</a>&lt;org.apache.kafka.common.utils.Bytes,&#8203;byte[]&gt;&gt;&nbsp;materialized)</pre>
<div class="block">Aggregate the values of records in this stream by the grouped key.
 Records with <code>null</code> key or value are ignored.
 Aggregating is a generalization of <a href="#reduce(org.apache.kafka.streams.kstream.Reducer)"><code>combining via reduce(...)</code></a> as it, for example,
 allows the result to have a different type than the input values.
 The result is written into a local <a href="../state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state"><code>KeyValueStore</code></a> (which is basically an ever-updating materialized view)
 that can be queried by the given store name in <code>materialized</code>.
 Furthermore, updates to the store are sent downstream into a <a href="KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> changelog stream.
 <p>
 The specified <a href="Initializer.html" title="interface in org.apache.kafka.streams.kstream"><code>Initializer</code></a> is applied once directly before the first input record is processed to
 provide an initial intermediate aggregation result that is used to process the first record.
 The specified <a href="Aggregator.html" title="interface in org.apache.kafka.streams.kstream"><code>Aggregator</code></a> is applied for each input record and computes a new aggregate using the current
 aggregate (or for the very first record using the intermediate aggregation result provided via the
 <a href="Initializer.html" title="interface in org.apache.kafka.streams.kstream"><code>Initializer</code></a>) and the record's value.
 Thus, <code>aggregate(Initializer, Aggregator, Materialized)</code> can be used to compute aggregate functions like
 count (c.f. <a href="#count()"><code>count()</code></a>).
 <p>
 Not all updates might get sent downstream, as an internal cache is used to deduplicate consecutive updates to
 the same key.
 The rate of propagated updates depends on your input data rate, the number of distinct keys, the number of
 parallel running Kafka Streams instances, and the <a href="../StreamsConfig.html" title="class in org.apache.kafka.streams"><code>configuration</code></a> parameters for
 <a href="../StreamsConfig.html#CACHE_MAX_BYTES_BUFFERING_CONFIG"><code>cache size</code></a>, and
 <a href="../StreamsConfig.html#COMMIT_INTERVAL_MS_CONFIG"><code>commit interval</code></a>.
 <p>
 To query the local <a href="../state/ReadOnlyKeyValueStore.html" title="interface in org.apache.kafka.streams.state"><code>ReadOnlyKeyValueStore</code></a> it must be obtained via
 <a href="../KafkaStreams.html#store(org.apache.kafka.streams.StoreQueryParameters)"><code>KafkaStreams#store(...)</code></a>:
 <pre><code>
 KafkaStreams streams = ... // some aggregation on value type double
 String queryableStoreName = "storeName" // the store name should be the name of the store as defined by the Materialized instance
 ReadOnlyKeyValueStore&lt;K, ValueAndTimestamp&lt;VR&gt;&gt; localStore = streams.store(queryableStoreName, QueryableStoreTypes.&lt;K, ValueAndTimestamp&lt;VR&gt;&gt;timestampedKeyValueStore());
 K key = "some-key";
 ValueAndTimestamp&lt;VR&gt; aggForKey = localStore.get(key); // key must be local (application state is shared over all running Kafka Streams instances)
 </code></pre>
 For non-local keys, a custom RPC mechanism must be implemented using <a href="../KafkaStreams.html#allMetadata()"><code>KafkaStreams.allMetadata()</code></a> to
 query the value of the key on a parallel running instance of your Kafka Streams application.

 <p>
 For failure and recovery the store (which always will be of type <a href="../state/TimestampedKeyValueStore.html" title="interface in org.apache.kafka.streams.state"><code>TimestampedKeyValueStore</code></a> -- regardless of what
 is specified in the parameter <code>materialized</code>) will be backed by an internal changelog topic that will be created in Kafka.
 Therefore, the store name defined by the Materialized instance must be a valid Kafka topic name and cannot contain characters other than ASCII
 alphanumerics, '.', '_' and '-'.
 The changelog topic will be named "${applicationId}-${storeName}-changelog", where "applicationId" is
 user-specified in <a href="../StreamsConfig.html" title="class in org.apache.kafka.streams"><code>StreamsConfig</code></a> via parameter
 <a href="../StreamsConfig.html#APPLICATION_ID_CONFIG"><code>APPLICATION_ID_CONFIG</code></a>, "storeName" is the
 provide store name defined in <code>Materialized</code>, and "-changelog" is a fixed suffix.

 You can retrieve all generated internal topic names via <a href="../Topology.html#describe()"><code>Topology.describe()</code></a>.</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>VR</code> - the value type of the resulting <a href="KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>initializer</code> - an <a href="Initializer.html" title="interface in org.apache.kafka.streams.kstream"><code>Initializer</code></a> that computes an initial intermediate aggregation result</dd>
<dd><code>aggregator</code> - an <a href="Aggregator.html" title="interface in org.apache.kafka.streams.kstream"><code>Aggregator</code></a> that computes a new aggregate result</dd>
<dd><code>materialized</code> - an instance of <a href="Materialized.html" title="class in org.apache.kafka.streams.kstream"><code>Materialized</code></a> used to materialize a state store. Cannot be <code>null</code>.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a <a href="KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> that contains "update" records with unmodified keys, and values that represent the
 latest (rolling) aggregate for each key</dd>
</dl>
</li>
</ul>
<a id="aggregate(org.apache.kafka.streams.kstream.Initializer,org.apache.kafka.streams.kstream.Aggregator,org.apache.kafka.streams.kstream.Named,org.apache.kafka.streams.kstream.Materialized)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>aggregate</h4>
<pre class="methodSignature">&lt;VR&gt;&nbsp;<a href="KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="KGroupedStream.html" title="type parameter in KGroupedStream">K</a>,&#8203;VR&gt;&nbsp;aggregate&#8203;(<a href="Initializer.html" title="interface in org.apache.kafka.streams.kstream">Initializer</a>&lt;VR&gt;&nbsp;initializer,
                                  <a href="Aggregator.html" title="interface in org.apache.kafka.streams.kstream">Aggregator</a>&lt;? super <a href="KGroupedStream.html" title="type parameter in KGroupedStream">K</a>,&#8203;? super <a href="KGroupedStream.html" title="type parameter in KGroupedStream">V</a>,&#8203;VR&gt;&nbsp;aggregator,
                                  <a href="Named.html" title="class in org.apache.kafka.streams.kstream">Named</a>&nbsp;named,
                                  <a href="Materialized.html" title="class in org.apache.kafka.streams.kstream">Materialized</a>&lt;<a href="KGroupedStream.html" title="type parameter in KGroupedStream">K</a>,&#8203;VR,&#8203;<a href="../state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state">KeyValueStore</a>&lt;org.apache.kafka.common.utils.Bytes,&#8203;byte[]&gt;&gt;&nbsp;materialized)</pre>
<div class="block">Aggregate the values of records in this stream by the grouped key.
 Records with <code>null</code> key or value are ignored.
 Aggregating is a generalization of <a href="#reduce(org.apache.kafka.streams.kstream.Reducer)"><code>combining via reduce(...)</code></a> as it, for example,
 allows the result to have a different type than the input values.
 The result is written into a local <a href="../state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state"><code>KeyValueStore</code></a> (which is basically an ever-updating materialized view)
 that can be queried by the given store name in <code>materialized</code>.
 Furthermore, updates to the store are sent downstream into a <a href="KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> changelog stream.
 <p>
 The specified <a href="Initializer.html" title="interface in org.apache.kafka.streams.kstream"><code>Initializer</code></a> is applied once directly before the first input record is processed to
 provide an initial intermediate aggregation result that is used to process the first record.
 The specified <a href="Aggregator.html" title="interface in org.apache.kafka.streams.kstream"><code>Aggregator</code></a> is applied for each input record and computes a new aggregate using the current
 aggregate (or for the very first record using the intermediate aggregation result provided via the
 <a href="Initializer.html" title="interface in org.apache.kafka.streams.kstream"><code>Initializer</code></a>) and the record's value.
 Thus, <code>aggregate(Initializer, Aggregator, Materialized)</code> can be used to compute aggregate functions like
 count (c.f. <a href="#count()"><code>count()</code></a>).
 <p>
 Not all updates might get sent downstream, as an internal cache is used to deduplicate consecutive updates to
 the same key.
 The rate of propagated updates depends on your input data rate, the number of distinct keys, the number of
 parallel running Kafka Streams instances, and the <a href="../StreamsConfig.html" title="class in org.apache.kafka.streams"><code>configuration</code></a> parameters for
 <a href="../StreamsConfig.html#CACHE_MAX_BYTES_BUFFERING_CONFIG"><code>cache size</code></a>, and
 <a href="../StreamsConfig.html#COMMIT_INTERVAL_MS_CONFIG"><code>commit interval</code></a>.
 <p>
 To query the local <a href="../state/ReadOnlyKeyValueStore.html" title="interface in org.apache.kafka.streams.state"><code>ReadOnlyKeyValueStore</code></a> it must be obtained via
 <a href="../KafkaStreams.html#store(org.apache.kafka.streams.StoreQueryParameters)"><code>KafkaStreams#store(...)</code></a>:
 <pre><code>
 KafkaStreams streams = ... // some aggregation on value type double
 String queryableStoreName = "storeName" // the store name should be the name of the store as defined by the Materialized instance
 ReadOnlyKeyValueStore&lt;K, ValueAndTimestamp&lt;VR&gt;&gt; localStore = streams.store(queryableStoreName, QueryableStoreTypes.&lt;String, ValueAndTimestamp&lt;VR&gt;&gt;timestampedKeyValueStore());
 K key = "some-key";
 ValueAndTimestamp&lt;VR&gt; aggForKey = localStore.get(key); // key must be local (application state is shared over all running Kafka Streams instances)
 </code></pre>
 For non-local keys, a custom RPC mechanism must be implemented using <a href="../KafkaStreams.html#allMetadata()"><code>KafkaStreams.allMetadata()</code></a> to
 query the value of the key on a parallel running instance of your Kafka Streams application.

 <p>
 For failure and recovery the store (which always will be of type <a href="../state/TimestampedKeyValueStore.html" title="interface in org.apache.kafka.streams.state"><code>TimestampedKeyValueStore</code></a> -- regardless of what
 is specified in the parameter <code>materialized</code>) will be backed by an internal changelog topic that will be created in Kafka.
 Therefore, the store name defined by the Materialized instance must be a valid Kafka topic name and cannot contain characters other than ASCII
 alphanumerics, '.', '_' and '-'.
 The changelog topic will be named "${applicationId}-${storeName}-changelog", where "applicationId" is
 user-specified in <a href="../StreamsConfig.html" title="class in org.apache.kafka.streams"><code>StreamsConfig</code></a> via parameter
 <a href="../StreamsConfig.html#APPLICATION_ID_CONFIG"><code>APPLICATION_ID_CONFIG</code></a>, "storeName" is the
 provide store name defined in <code>Materialized</code>, and "-changelog" is a fixed suffix.

 You can retrieve all generated internal topic names via <a href="../Topology.html#describe()"><code>Topology.describe()</code></a>.</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>VR</code> - the value type of the resulting <a href="KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>initializer</code> - an <a href="Initializer.html" title="interface in org.apache.kafka.streams.kstream"><code>Initializer</code></a> that computes an initial intermediate aggregation result</dd>
<dd><code>aggregator</code> - an <a href="Aggregator.html" title="interface in org.apache.kafka.streams.kstream"><code>Aggregator</code></a> that computes a new aggregate result</dd>
<dd><code>named</code> - a <a href="Named.html" title="class in org.apache.kafka.streams.kstream"><code>Named</code></a> config used to name the processor in the topology</dd>
<dd><code>materialized</code> - an instance of <a href="Materialized.html" title="class in org.apache.kafka.streams.kstream"><code>Materialized</code></a> used to materialize a state store. Cannot be <code>null</code>.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a <a href="KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> that contains "update" records with unmodified keys, and values that represent the
 latest (rolling) aggregate for each key. If the aggregate function returns <code>null</code>, it is then interpreted as
 deletion for the key, and future messages of the same key coming from upstream operators
 will be handled as newly initialized value.</dd>
</dl>
</li>
</ul>
<a id="windowedBy(org.apache.kafka.streams.kstream.Windows)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>windowedBy</h4>
<pre class="methodSignature">&lt;W extends <a href="Window.html" title="class in org.apache.kafka.streams.kstream">Window</a>&gt;&nbsp;<a href="TimeWindowedKStream.html" title="interface in org.apache.kafka.streams.kstream">TimeWindowedKStream</a>&lt;<a href="KGroupedStream.html" title="type parameter in KGroupedStream">K</a>,&#8203;<a href="KGroupedStream.html" title="type parameter in KGroupedStream">V</a>&gt;&nbsp;windowedBy&#8203;(<a href="Windows.html" title="class in org.apache.kafka.streams.kstream">Windows</a>&lt;W&gt;&nbsp;windows)</pre>
<div class="block">Create a new <a href="TimeWindowedKStream.html" title="interface in org.apache.kafka.streams.kstream"><code>TimeWindowedKStream</code></a> instance that can be used to perform windowed aggregations.</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>W</code> - the window type</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>windows</code> - the specification of the aggregation <a href="Windows.html" title="class in org.apache.kafka.streams.kstream"><code>Windows</code></a></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>an instance of <a href="TimeWindowedKStream.html" title="interface in org.apache.kafka.streams.kstream"><code>TimeWindowedKStream</code></a></dd>
</dl>
</li>
</ul>
<a id="windowedBy(org.apache.kafka.streams.kstream.SlidingWindows)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>windowedBy</h4>
<pre class="methodSignature"><a href="TimeWindowedKStream.html" title="interface in org.apache.kafka.streams.kstream">TimeWindowedKStream</a>&lt;<a href="KGroupedStream.html" title="type parameter in KGroupedStream">K</a>,&#8203;<a href="KGroupedStream.html" title="type parameter in KGroupedStream">V</a>&gt;&nbsp;windowedBy&#8203;(<a href="SlidingWindows.html" title="class in org.apache.kafka.streams.kstream">SlidingWindows</a>&nbsp;windows)</pre>
<div class="block">Create a new <a href="TimeWindowedKStream.html" title="interface in org.apache.kafka.streams.kstream"><code>TimeWindowedKStream</code></a> instance that can be used to perform sliding windowed aggregations.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>windows</code> - the specification of the aggregation <a href="SlidingWindows.html" title="class in org.apache.kafka.streams.kstream"><code>SlidingWindows</code></a></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>an instance of <a href="TimeWindowedKStream.html" title="interface in org.apache.kafka.streams.kstream"><code>TimeWindowedKStream</code></a></dd>
</dl>
</li>
</ul>
<a id="windowedBy(org.apache.kafka.streams.kstream.SessionWindows)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>windowedBy</h4>
<pre class="methodSignature"><a href="SessionWindowedKStream.html" title="interface in org.apache.kafka.streams.kstream">SessionWindowedKStream</a>&lt;<a href="KGroupedStream.html" title="type parameter in KGroupedStream">K</a>,&#8203;<a href="KGroupedStream.html" title="type parameter in KGroupedStream">V</a>&gt;&nbsp;windowedBy&#8203;(<a href="SessionWindows.html" title="class in org.apache.kafka.streams.kstream">SessionWindows</a>&nbsp;windows)</pre>
<div class="block">Create a new <a href="SessionWindowedKStream.html" title="interface in org.apache.kafka.streams.kstream"><code>SessionWindowedKStream</code></a> instance that can be used to perform session windowed aggregations.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>windows</code> - the specification of the aggregation <a href="SessionWindows.html" title="class in org.apache.kafka.streams.kstream"><code>SessionWindows</code></a></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>an instance of <a href="TimeWindowedKStream.html" title="interface in org.apache.kafka.streams.kstream"><code>TimeWindowedKStream</code></a></dd>
</dl>
</li>
</ul>
<a id="cogroup(org.apache.kafka.streams.kstream.Aggregator)">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>cogroup</h4>
<pre class="methodSignature">&lt;VOut&gt;&nbsp;<a href="CogroupedKStream.html" title="interface in org.apache.kafka.streams.kstream">CogroupedKStream</a>&lt;<a href="KGroupedStream.html" title="type parameter in KGroupedStream">K</a>,&#8203;VOut&gt;&nbsp;cogroup&#8203;(<a href="Aggregator.html" title="interface in org.apache.kafka.streams.kstream">Aggregator</a>&lt;? super <a href="KGroupedStream.html" title="type parameter in KGroupedStream">K</a>,&#8203;? super <a href="KGroupedStream.html" title="type parameter in KGroupedStream">V</a>,&#8203;VOut&gt;&nbsp;aggregator)</pre>
<div class="block">Create a new <a href="CogroupedKStream.html" title="interface in org.apache.kafka.streams.kstream"><code>CogroupedKStream</code></a> from the this grouped KStream to allow cogrouping other
 <code>KGroupedStream</code> to it.
 <a href="CogroupedKStream.html" title="interface in org.apache.kafka.streams.kstream"><code>CogroupedKStream</code></a> is an abstraction of multiple <i>grouped</i> record streams of <a href="../KeyValue.html" title="class in org.apache.kafka.streams"><code>KeyValue</code></a> pairs.
 It is an intermediate representation after a grouping of <a href="KStream.html" title="interface in org.apache.kafka.streams.kstream"><code>KStream</code></a>s, before the
 aggregations are applied to the new partitions resulting in a <a href="KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a>.
 <p>
 The specified <a href="Aggregator.html" title="interface in org.apache.kafka.streams.kstream"><code>Aggregator</code></a> is applied in the actual <a href="CogroupedKStream.html#aggregate(org.apache.kafka.streams.kstream.Initializer)"><code>aggregation</code></a> step for each input record and computes a new aggregate using the current aggregate (or for the very
 first record per key using the initial intermediate aggregation result provided via the <a href="Initializer.html" title="interface in org.apache.kafka.streams.kstream"><code>Initializer</code></a> that
 is passed into <a href="CogroupedKStream.html#aggregate(org.apache.kafka.streams.kstream.Initializer)"><code>CogroupedKStream.aggregate(Initializer)</code></a>) and the record's value.</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>VOut</code> - the type of the output values</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>aggregator</code> - an <a href="Aggregator.html" title="interface in org.apache.kafka.streams.kstream"><code>Aggregator</code></a> that computes a new aggregate result</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a <a href="CogroupedKStream.html" title="interface in org.apache.kafka.streams.kstream"><code>CogroupedKStream</code></a></dd>
</dl>
</li>
</ul>
</li>
</ul>
</section>
</li>
</ul>
</div>
</div>
</main>
<!-- ========= END OF CLASS DATA ========= -->
<footer role="contentinfo">
<nav role="navigation">
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a id="navbar.bottom">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a></div>
<a id="navbar.bottom.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../../../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../../index-all.html">Index</a></li>
<li><a href="../../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="../../../../../allclasses.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a id="skip.navbar.bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
</nav>
</footer>
</body>
</html>

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (version 1.7.0_80) on Fri Nov 10 23:49:17 GMT 2017 -->
<title>KStream (kafka 0.11.0.2 API)</title>
<meta name="date" content="2017-11-10">
<link rel="stylesheet" type="text/css" href="../../../../../stylesheet.css" title="Style">
</head>
<body>
<script type="text/javascript"><!--
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="KStream (kafka 0.11.0.2 API)";
    }
//-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a name="navbar_top">
<!--   -->
</a><a href="#skip-navbar_top" title="Skip navigation links"></a><a name="navbar_top_firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../../../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../../index-all.html">Index</a></li>
<li><a href="../../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html" title="interface in org.apache.kafka.streams.kstream"><span class="strong">Prev Class</span></a></li>
<li><a href="../../../../../org/apache/kafka/streams/kstream/KStreamBuilder.html" title="class in org.apache.kafka.streams.kstream"><span class="strong">Next Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../../../../index.html?org/apache/kafka/streams/kstream/KStream.html" target="_top">Frames</a></li>
<li><a href="KStream.html" target="_top">No Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_top">
<li><a href="../../../../../allclasses-noframe.html">All Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method_summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method_detail">Method</a></li>
</ul>
</div>
<a name="skip-navbar_top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="subTitle">org.apache.kafka.streams.kstream</div>
<h2 title="Interface KStream" class="title">Interface KStream&lt;K,V&gt;</h2>
</div>
<div class="contentContainer">
<div class="description">
<ul class="blockList">
<li class="blockList">
<dl><dt><span class="strong">Type Parameters:</span></dt><dd><code>K</code> - Type of keys</dd><dd><code>V</code> - Type of values</dd></dl>
<hr>
<br>
<pre><a href="../../../../../org/apache/kafka/common/annotation/InterfaceStability.Evolving.html" title="annotation in org.apache.kafka.common.annotation">@InterfaceStability.Evolving</a>
public interface <span class="strong">KStream&lt;K,V&gt;</span></pre>
<div class="block"><code>KStream</code> is an abstraction of a <i>record stream</i> of <a href="../../../../../org/apache/kafka/streams/KeyValue.html" title="class in org.apache.kafka.streams"><code>KeyValue</code></a> pairs, i.e., each record is an
 independent entity/event in the real world.
 For example a user X might buy two items I1 and I2, and thus there might be two records <code>&lt;K:I1&gt;, &lt;K:I2&gt;</code>
 in the stream.
 <p>
 A <code>KStream</code> is either <a href="../../../../../org/apache/kafka/streams/kstream/KStreamBuilder.html#stream(java.lang.String...)"><code>defined from one or multiple Kafka topics</code></a> that
 are consumed message by message or the result of a <code>KStream</code> transformation.
 A <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> can also be <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#toStream()"><code>converted</code></a> into a <code>KStream</code>.
 <p>
 A <code>KStream</code> can be transformed record by record, joined with another <code>KStream</code>, <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a>,
 <a href="../../../../../org/apache/kafka/streams/kstream/GlobalKTable.html" title="interface in org.apache.kafka.streams.kstream"><code>GlobalKTable</code></a>, or can be aggregated into a <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a>.
 Kafka Streams DSL can be mixed-and-matched with Processor API (PAPI) (c.f. <a href="../../../../../org/apache/kafka/streams/processor/TopologyBuilder.html" title="class in org.apache.kafka.streams.processor"><code>TopologyBuilder</code></a>) via
 <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#process(org.apache.kafka.streams.processor.ProcessorSupplier,%20java.lang.String...)"><code>process(...)</code></a>,
 <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#transform(org.apache.kafka.streams.kstream.TransformerSupplier,%20java.lang.String...)"><code>transform(...)</code></a>, and
 <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#transformValues(org.apache.kafka.streams.kstream.ValueTransformerSupplier,%20java.lang.String...)"><code>transformValues(...)</code></a>.</div>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a>, 
<a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html" title="interface in org.apache.kafka.streams.kstream"><code>KGroupedStream</code></a>, 
<a href="../../../../../org/apache/kafka/streams/kstream/KStreamBuilder.html#stream(java.lang.String...)"><code>KStreamBuilder.stream(String...)</code></a></dd></dl>
</li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- ========== METHOD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="method_summary">
<!--   -->
</a>
<h3>Method Summary</h3>
<table class="overviewSummary" border="0" cellpadding="3" cellspacing="0" summary="Method Summary table, listing methods, and an explanation">
<caption><span>Methods</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Method and Description</th>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="interface in org.apache.kafka.streams.kstream">KStream</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">K</a>,<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">V</a>&gt;[]</code></td>
<td class="colLast"><code><strong><a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#branch(org.apache.kafka.streams.kstream.Predicate...)">branch</a></strong>(<a href="../../../../../org/apache/kafka/streams/kstream/Predicate.html" title="interface in org.apache.kafka.streams.kstream">Predicate</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">K</a>,? super <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">V</a>&gt;...&nbsp;predicates)</code>
<div class="block">Creates an array of <code>KStream</code> from this stream by branching the records in the original stream based on
 the supplied predicates.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="interface in org.apache.kafka.streams.kstream">KStream</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">K</a>,<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">V</a>&gt;</code></td>
<td class="colLast"><code><strong><a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#filter(org.apache.kafka.streams.kstream.Predicate)">filter</a></strong>(<a href="../../../../../org/apache/kafka/streams/kstream/Predicate.html" title="interface in org.apache.kafka.streams.kstream">Predicate</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">K</a>,? super <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">V</a>&gt;&nbsp;predicate)</code>
<div class="block">Create a new <code>KStream</code> that consists of all records of this stream which satisfy the given predicate.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="interface in org.apache.kafka.streams.kstream">KStream</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">K</a>,<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">V</a>&gt;</code></td>
<td class="colLast"><code><strong><a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#filterNot(org.apache.kafka.streams.kstream.Predicate)">filterNot</a></strong>(<a href="../../../../../org/apache/kafka/streams/kstream/Predicate.html" title="interface in org.apache.kafka.streams.kstream">Predicate</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">K</a>,? super <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">V</a>&gt;&nbsp;predicate)</code>
<div class="block">Create a new <code>KStream</code> that consists all records of this stream which do <em>not</em> satisfy the given
 predicate.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>&lt;KR,VR&gt;&nbsp;<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="interface in org.apache.kafka.streams.kstream">KStream</a>&lt;KR,VR&gt;</code></td>
<td class="colLast"><code><strong><a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#flatMap(org.apache.kafka.streams.kstream.KeyValueMapper)">flatMap</a></strong>(<a href="../../../../../org/apache/kafka/streams/kstream/KeyValueMapper.html" title="interface in org.apache.kafka.streams.kstream">KeyValueMapper</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">K</a>,? super <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">V</a>,? extends java.lang.Iterable&lt;? extends <a href="../../../../../org/apache/kafka/streams/KeyValue.html" title="class in org.apache.kafka.streams">KeyValue</a>&lt;? extends KR,? extends VR&gt;&gt;&gt;&nbsp;mapper)</code>
<div class="block">Transform each record of the input stream into zero or more records in the output stream (both key and value type
 can be altered arbitrarily).</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>&lt;VR&gt;&nbsp;<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="interface in org.apache.kafka.streams.kstream">KStream</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">K</a>,VR&gt;</code></td>
<td class="colLast"><code><strong><a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#flatMapValues(org.apache.kafka.streams.kstream.ValueMapper)">flatMapValues</a></strong>(<a href="../../../../../org/apache/kafka/streams/kstream/ValueMapper.html" title="interface in org.apache.kafka.streams.kstream">ValueMapper</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">V</a>,? extends java.lang.Iterable&lt;? extends VR&gt;&gt;&nbsp;processor)</code>
<div class="block">Create a new <code>KStream</code> by transforming the value of each record in this stream into zero or more values
 with the same key in the new stream.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#foreach(org.apache.kafka.streams.kstream.ForeachAction)">foreach</a></strong>(<a href="../../../../../org/apache/kafka/streams/kstream/ForeachAction.html" title="interface in org.apache.kafka.streams.kstream">ForeachAction</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">K</a>,? super <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">V</a>&gt;&nbsp;action)</code>
<div class="block">Perform an action on each record of <code>KStream</code>.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>&lt;KR&gt;&nbsp;<a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html" title="interface in org.apache.kafka.streams.kstream">KGroupedStream</a>&lt;KR,<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">V</a>&gt;</code></td>
<td class="colLast"><code><strong><a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#groupBy(org.apache.kafka.streams.kstream.KeyValueMapper)">groupBy</a></strong>(<a href="../../../../../org/apache/kafka/streams/kstream/KeyValueMapper.html" title="interface in org.apache.kafka.streams.kstream">KeyValueMapper</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">K</a>,? super <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">V</a>,KR&gt;&nbsp;selector)</code>
<div class="block">Group the records of this <code>KStream</code> on a new key that is selected using the provided <a href="../../../../../org/apache/kafka/streams/kstream/KeyValueMapper.html" title="interface in org.apache.kafka.streams.kstream"><code>KeyValueMapper</code></a>
 and default serializers and deserializers.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>&lt;KR&gt;&nbsp;<a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html" title="interface in org.apache.kafka.streams.kstream">KGroupedStream</a>&lt;KR,<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">V</a>&gt;</code></td>
<td class="colLast"><code><strong><a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#groupBy(org.apache.kafka.streams.kstream.KeyValueMapper,%20org.apache.kafka.common.serialization.Serde,%20org.apache.kafka.common.serialization.Serde)">groupBy</a></strong>(<a href="../../../../../org/apache/kafka/streams/kstream/KeyValueMapper.html" title="interface in org.apache.kafka.streams.kstream">KeyValueMapper</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">K</a>,? super <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">V</a>,KR&gt;&nbsp;selector,
       <a href="../../../../../org/apache/kafka/common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization">Serde</a>&lt;KR&gt;&nbsp;keySerde,
       <a href="../../../../../org/apache/kafka/common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization">Serde</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">V</a>&gt;&nbsp;valSerde)</code>
<div class="block">Group the records of this <code>KStream</code> on a new key that is selected using the provided <a href="../../../../../org/apache/kafka/streams/kstream/KeyValueMapper.html" title="interface in org.apache.kafka.streams.kstream"><code>KeyValueMapper</code></a>.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html" title="interface in org.apache.kafka.streams.kstream">KGroupedStream</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">K</a>,<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">V</a>&gt;</code></td>
<td class="colLast"><code><strong><a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#groupByKey()">groupByKey</a></strong>()</code>
<div class="block">Group the records by their current key into a <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html" title="interface in org.apache.kafka.streams.kstream"><code>KGroupedStream</code></a> while preserving the original values
 and default serializers and deserializers.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html" title="interface in org.apache.kafka.streams.kstream">KGroupedStream</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">K</a>,<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">V</a>&gt;</code></td>
<td class="colLast"><code><strong><a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#groupByKey(org.apache.kafka.common.serialization.Serde,%20org.apache.kafka.common.serialization.Serde)">groupByKey</a></strong>(<a href="../../../../../org/apache/kafka/common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization">Serde</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">K</a>&gt;&nbsp;keySerde,
          <a href="../../../../../org/apache/kafka/common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization">Serde</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">V</a>&gt;&nbsp;valSerde)</code>
<div class="block">Group the records by their current key into a <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html" title="interface in org.apache.kafka.streams.kstream"><code>KGroupedStream</code></a> while preserving the original values.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>&lt;GK,GV,RV&gt;&nbsp;<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="interface in org.apache.kafka.streams.kstream">KStream</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">K</a>,RV&gt;</code></td>
<td class="colLast"><code><strong><a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#join(org.apache.kafka.streams.kstream.GlobalKTable,%20org.apache.kafka.streams.kstream.KeyValueMapper,%20org.apache.kafka.streams.kstream.ValueJoiner)">join</a></strong>(<a href="../../../../../org/apache/kafka/streams/kstream/GlobalKTable.html" title="interface in org.apache.kafka.streams.kstream">GlobalKTable</a>&lt;GK,GV&gt;&nbsp;globalKTable,
    <a href="../../../../../org/apache/kafka/streams/kstream/KeyValueMapper.html" title="interface in org.apache.kafka.streams.kstream">KeyValueMapper</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">K</a>,? super <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">V</a>,? extends GK&gt;&nbsp;keyValueMapper,
    <a href="../../../../../org/apache/kafka/streams/kstream/ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream">ValueJoiner</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">V</a>,? super GV,? extends RV&gt;&nbsp;joiner)</code>
<div class="block">Join records of this stream with <a href="../../../../../org/apache/kafka/streams/kstream/GlobalKTable.html" title="interface in org.apache.kafka.streams.kstream"><code>GlobalKTable</code></a>'s records using non-windowed inner equi join.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>&lt;VO,VR&gt;&nbsp;<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="interface in org.apache.kafka.streams.kstream">KStream</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">K</a>,VR&gt;</code></td>
<td class="colLast"><code><strong><a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#join(org.apache.kafka.streams.kstream.KStream,%20org.apache.kafka.streams.kstream.ValueJoiner,%20org.apache.kafka.streams.kstream.JoinWindows)">join</a></strong>(<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="interface in org.apache.kafka.streams.kstream">KStream</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">K</a>,VO&gt;&nbsp;otherStream,
    <a href="../../../../../org/apache/kafka/streams/kstream/ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream">ValueJoiner</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">V</a>,? super VO,? extends VR&gt;&nbsp;joiner,
    <a href="../../../../../org/apache/kafka/streams/kstream/JoinWindows.html" title="class in org.apache.kafka.streams.kstream">JoinWindows</a>&nbsp;windows)</code>
<div class="block">Join records of this stream with another <code>KStream</code>'s records using windowed inner equi join with default
 serializers and deserializers.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>&lt;VO,VR&gt;&nbsp;<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="interface in org.apache.kafka.streams.kstream">KStream</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">K</a>,VR&gt;</code></td>
<td class="colLast"><code><strong><a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#join(org.apache.kafka.streams.kstream.KStream,%20org.apache.kafka.streams.kstream.ValueJoiner,%20org.apache.kafka.streams.kstream.JoinWindows,%20org.apache.kafka.common.serialization.Serde,%20org.apache.kafka.common.serialization.Serde,%20org.apache.kafka.common.serialization.Serde)">join</a></strong>(<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="interface in org.apache.kafka.streams.kstream">KStream</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">K</a>,VO&gt;&nbsp;otherStream,
    <a href="../../../../../org/apache/kafka/streams/kstream/ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream">ValueJoiner</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">V</a>,? super VO,? extends VR&gt;&nbsp;joiner,
    <a href="../../../../../org/apache/kafka/streams/kstream/JoinWindows.html" title="class in org.apache.kafka.streams.kstream">JoinWindows</a>&nbsp;windows,
    <a href="../../../../../org/apache/kafka/common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization">Serde</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">K</a>&gt;&nbsp;keySerde,
    <a href="../../../../../org/apache/kafka/common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization">Serde</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">V</a>&gt;&nbsp;thisValueSerde,
    <a href="../../../../../org/apache/kafka/common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization">Serde</a>&lt;VO&gt;&nbsp;otherValueSerde)</code>
<div class="block">Join records of this stream with another <code>KStream</code>'s records using windowed inner equi join.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>&lt;VT,VR&gt;&nbsp;<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="interface in org.apache.kafka.streams.kstream">KStream</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">K</a>,VR&gt;</code></td>
<td class="colLast"><code><strong><a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#join(org.apache.kafka.streams.kstream.KTable,%20org.apache.kafka.streams.kstream.ValueJoiner)">join</a></strong>(<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">K</a>,VT&gt;&nbsp;table,
    <a href="../../../../../org/apache/kafka/streams/kstream/ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream">ValueJoiner</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">V</a>,? super VT,? extends VR&gt;&nbsp;joiner)</code>
<div class="block">Join records of this stream with <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a>'s records using non-windowed inner equi join with default
 serializers and deserializers.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>&lt;VT,VR&gt;&nbsp;<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="interface in org.apache.kafka.streams.kstream">KStream</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">K</a>,VR&gt;</code></td>
<td class="colLast"><code><strong><a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#join(org.apache.kafka.streams.kstream.KTable,%20org.apache.kafka.streams.kstream.ValueJoiner,%20org.apache.kafka.common.serialization.Serde,%20org.apache.kafka.common.serialization.Serde)">join</a></strong>(<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">K</a>,VT&gt;&nbsp;table,
    <a href="../../../../../org/apache/kafka/streams/kstream/ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream">ValueJoiner</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">V</a>,? super VT,? extends VR&gt;&nbsp;joiner,
    <a href="../../../../../org/apache/kafka/common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization">Serde</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">K</a>&gt;&nbsp;keySerde,
    <a href="../../../../../org/apache/kafka/common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization">Serde</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">V</a>&gt;&nbsp;valSerde)</code>
<div class="block">Join records of this stream with <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a>'s records using non-windowed inner equi join.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>&lt;GK,GV,RV&gt;&nbsp;<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="interface in org.apache.kafka.streams.kstream">KStream</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">K</a>,RV&gt;</code></td>
<td class="colLast"><code><strong><a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#leftJoin(org.apache.kafka.streams.kstream.GlobalKTable,%20org.apache.kafka.streams.kstream.KeyValueMapper,%20org.apache.kafka.streams.kstream.ValueJoiner)">leftJoin</a></strong>(<a href="../../../../../org/apache/kafka/streams/kstream/GlobalKTable.html" title="interface in org.apache.kafka.streams.kstream">GlobalKTable</a>&lt;GK,GV&gt;&nbsp;globalKTable,
        <a href="../../../../../org/apache/kafka/streams/kstream/KeyValueMapper.html" title="interface in org.apache.kafka.streams.kstream">KeyValueMapper</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">K</a>,? super <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">V</a>,? extends GK&gt;&nbsp;keyValueMapper,
        <a href="../../../../../org/apache/kafka/streams/kstream/ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream">ValueJoiner</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">V</a>,? super GV,? extends RV&gt;&nbsp;valueJoiner)</code>
<div class="block">Join records of this stream with <a href="../../../../../org/apache/kafka/streams/kstream/GlobalKTable.html" title="interface in org.apache.kafka.streams.kstream"><code>GlobalKTable</code></a>'s records using non-windowed left equi join.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>&lt;VO,VR&gt;&nbsp;<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="interface in org.apache.kafka.streams.kstream">KStream</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">K</a>,VR&gt;</code></td>
<td class="colLast"><code><strong><a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#leftJoin(org.apache.kafka.streams.kstream.KStream,%20org.apache.kafka.streams.kstream.ValueJoiner,%20org.apache.kafka.streams.kstream.JoinWindows)">leftJoin</a></strong>(<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="interface in org.apache.kafka.streams.kstream">KStream</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">K</a>,VO&gt;&nbsp;otherStream,
        <a href="../../../../../org/apache/kafka/streams/kstream/ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream">ValueJoiner</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">V</a>,? super VO,? extends VR&gt;&nbsp;joiner,
        <a href="../../../../../org/apache/kafka/streams/kstream/JoinWindows.html" title="class in org.apache.kafka.streams.kstream">JoinWindows</a>&nbsp;windows)</code>
<div class="block">Join records of this stream with another <code>KStream</code>'s records using windowed left equi join with default
 serializers and deserializers.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>&lt;VO,VR&gt;&nbsp;<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="interface in org.apache.kafka.streams.kstream">KStream</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">K</a>,VR&gt;</code></td>
<td class="colLast"><code><strong><a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#leftJoin(org.apache.kafka.streams.kstream.KStream,%20org.apache.kafka.streams.kstream.ValueJoiner,%20org.apache.kafka.streams.kstream.JoinWindows,%20org.apache.kafka.common.serialization.Serde,%20org.apache.kafka.common.serialization.Serde,%20org.apache.kafka.common.serialization.Serde)">leftJoin</a></strong>(<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="interface in org.apache.kafka.streams.kstream">KStream</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">K</a>,VO&gt;&nbsp;otherStream,
        <a href="../../../../../org/apache/kafka/streams/kstream/ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream">ValueJoiner</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">V</a>,? super VO,? extends VR&gt;&nbsp;joiner,
        <a href="../../../../../org/apache/kafka/streams/kstream/JoinWindows.html" title="class in org.apache.kafka.streams.kstream">JoinWindows</a>&nbsp;windows,
        <a href="../../../../../org/apache/kafka/common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization">Serde</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">K</a>&gt;&nbsp;keySerde,
        <a href="../../../../../org/apache/kafka/common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization">Serde</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">V</a>&gt;&nbsp;thisValSerde,
        <a href="../../../../../org/apache/kafka/common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization">Serde</a>&lt;VO&gt;&nbsp;otherValueSerde)</code>
<div class="block">Join records of this stream with another <code>KStream</code>'s records using windowed left equi join.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>&lt;VT,VR&gt;&nbsp;<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="interface in org.apache.kafka.streams.kstream">KStream</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">K</a>,VR&gt;</code></td>
<td class="colLast"><code><strong><a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#leftJoin(org.apache.kafka.streams.kstream.KTable,%20org.apache.kafka.streams.kstream.ValueJoiner)">leftJoin</a></strong>(<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">K</a>,VT&gt;&nbsp;table,
        <a href="../../../../../org/apache/kafka/streams/kstream/ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream">ValueJoiner</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">V</a>,? super VT,? extends VR&gt;&nbsp;joiner)</code>
<div class="block">Join records of this stream with <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a>'s records using non-windowed left equi join with default
 serializers and deserializers.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>&lt;VT,VR&gt;&nbsp;<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="interface in org.apache.kafka.streams.kstream">KStream</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">K</a>,VR&gt;</code></td>
<td class="colLast"><code><strong><a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#leftJoin(org.apache.kafka.streams.kstream.KTable,%20org.apache.kafka.streams.kstream.ValueJoiner,%20org.apache.kafka.common.serialization.Serde,%20org.apache.kafka.common.serialization.Serde)">leftJoin</a></strong>(<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">K</a>,VT&gt;&nbsp;table,
        <a href="../../../../../org/apache/kafka/streams/kstream/ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream">ValueJoiner</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">V</a>,? super VT,? extends VR&gt;&nbsp;joiner,
        <a href="../../../../../org/apache/kafka/common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization">Serde</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">K</a>&gt;&nbsp;keySerde,
        <a href="../../../../../org/apache/kafka/common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization">Serde</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">V</a>&gt;&nbsp;valSerde)</code>
<div class="block">Join records of this stream with <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a>'s records using non-windowed left equi join.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>&lt;KR,VR&gt;&nbsp;<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="interface in org.apache.kafka.streams.kstream">KStream</a>&lt;KR,VR&gt;</code></td>
<td class="colLast"><code><strong><a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#map(org.apache.kafka.streams.kstream.KeyValueMapper)">map</a></strong>(<a href="../../../../../org/apache/kafka/streams/kstream/KeyValueMapper.html" title="interface in org.apache.kafka.streams.kstream">KeyValueMapper</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">K</a>,? super <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">V</a>,? extends <a href="../../../../../org/apache/kafka/streams/KeyValue.html" title="class in org.apache.kafka.streams">KeyValue</a>&lt;? extends KR,? extends VR&gt;&gt;&nbsp;mapper)</code>
<div class="block">Transform each record of the input stream into a new record in the output stream (both key and value type can be
 altered arbitrarily).</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>&lt;VR&gt;&nbsp;<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="interface in org.apache.kafka.streams.kstream">KStream</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">K</a>,VR&gt;</code></td>
<td class="colLast"><code><strong><a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#mapValues(org.apache.kafka.streams.kstream.ValueMapper)">mapValues</a></strong>(<a href="../../../../../org/apache/kafka/streams/kstream/ValueMapper.html" title="interface in org.apache.kafka.streams.kstream">ValueMapper</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">V</a>,? extends VR&gt;&nbsp;mapper)</code>
<div class="block">Transform the value of each input record into a new value (with possible new type) of the output record.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>&lt;VO,VR&gt;&nbsp;<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="interface in org.apache.kafka.streams.kstream">KStream</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">K</a>,VR&gt;</code></td>
<td class="colLast"><code><strong><a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#outerJoin(org.apache.kafka.streams.kstream.KStream,%20org.apache.kafka.streams.kstream.ValueJoiner,%20org.apache.kafka.streams.kstream.JoinWindows)">outerJoin</a></strong>(<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="interface in org.apache.kafka.streams.kstream">KStream</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">K</a>,VO&gt;&nbsp;otherStream,
         <a href="../../../../../org/apache/kafka/streams/kstream/ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream">ValueJoiner</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">V</a>,? super VO,? extends VR&gt;&nbsp;joiner,
         <a href="../../../../../org/apache/kafka/streams/kstream/JoinWindows.html" title="class in org.apache.kafka.streams.kstream">JoinWindows</a>&nbsp;windows)</code>
<div class="block">Join records of this stream with another <code>KStream</code>'s records using windowed left equi join with default
 serializers and deserializers.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>&lt;VO,VR&gt;&nbsp;<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="interface in org.apache.kafka.streams.kstream">KStream</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">K</a>,VR&gt;</code></td>
<td class="colLast"><code><strong><a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#outerJoin(org.apache.kafka.streams.kstream.KStream,%20org.apache.kafka.streams.kstream.ValueJoiner,%20org.apache.kafka.streams.kstream.JoinWindows,%20org.apache.kafka.common.serialization.Serde,%20org.apache.kafka.common.serialization.Serde,%20org.apache.kafka.common.serialization.Serde)">outerJoin</a></strong>(<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="interface in org.apache.kafka.streams.kstream">KStream</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">K</a>,VO&gt;&nbsp;otherStream,
         <a href="../../../../../org/apache/kafka/streams/kstream/ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream">ValueJoiner</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">V</a>,? super VO,? extends VR&gt;&nbsp;joiner,
         <a href="../../../../../org/apache/kafka/streams/kstream/JoinWindows.html" title="class in org.apache.kafka.streams.kstream">JoinWindows</a>&nbsp;windows,
         <a href="../../../../../org/apache/kafka/common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization">Serde</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">K</a>&gt;&nbsp;keySerde,
         <a href="../../../../../org/apache/kafka/common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization">Serde</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">V</a>&gt;&nbsp;thisValueSerde,
         <a href="../../../../../org/apache/kafka/common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization">Serde</a>&lt;VO&gt;&nbsp;otherValueSerde)</code>
<div class="block">Join records of this stream with another <code>KStream</code>'s records using windowed left equi join.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="interface in org.apache.kafka.streams.kstream">KStream</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">K</a>,<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">V</a>&gt;</code></td>
<td class="colLast"><code><strong><a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#peek(org.apache.kafka.streams.kstream.ForeachAction)">peek</a></strong>(<a href="../../../../../org/apache/kafka/streams/kstream/ForeachAction.html" title="interface in org.apache.kafka.streams.kstream">ForeachAction</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">K</a>,? super <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">V</a>&gt;&nbsp;action)</code>
<div class="block">Perform an action on each record of <code>KStream</code>.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#print()">print</a></strong>()</code>
<div class="block">Print the records of this stream to <code>System.out</code>.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#print(org.apache.kafka.common.serialization.Serde,%20org.apache.kafka.common.serialization.Serde)">print</a></strong>(<a href="../../../../../org/apache/kafka/common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization">Serde</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">K</a>&gt;&nbsp;keySerde,
     <a href="../../../../../org/apache/kafka/common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization">Serde</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">V</a>&gt;&nbsp;valSerde)</code>
<div class="block">Print the records of this stream to <code>System.out</code>.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#print(org.apache.kafka.common.serialization.Serde,%20org.apache.kafka.common.serialization.Serde,%20java.lang.String)">print</a></strong>(<a href="../../../../../org/apache/kafka/common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization">Serde</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">K</a>&gt;&nbsp;keySerde,
     <a href="../../../../../org/apache/kafka/common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization">Serde</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">V</a>&gt;&nbsp;valSerde,
     java.lang.String&nbsp;streamName)</code>
<div class="block">Print the records of this stream to <code>System.out</code>.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#print(java.lang.String)">print</a></strong>(java.lang.String&nbsp;streamName)</code>
<div class="block">Print the records of this stream to <code>System.out</code>.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#process(org.apache.kafka.streams.processor.ProcessorSupplier,%20java.lang.String...)">process</a></strong>(<a href="../../../../../org/apache/kafka/streams/processor/ProcessorSupplier.html" title="interface in org.apache.kafka.streams.processor">ProcessorSupplier</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">K</a>,? super <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">V</a>&gt;&nbsp;processorSupplier,
       java.lang.String...&nbsp;stateStoreNames)</code>
<div class="block">Process all records in this stream, one record at a time, by applying a <a href="../../../../../org/apache/kafka/streams/processor/Processor.html" title="interface in org.apache.kafka.streams.processor"><code>Processor</code></a> (provided by the given
 <a href="../../../../../org/apache/kafka/streams/processor/ProcessorSupplier.html" title="interface in org.apache.kafka.streams.processor"><code>ProcessorSupplier</code></a>).</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>&lt;KR&gt;&nbsp;<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="interface in org.apache.kafka.streams.kstream">KStream</a>&lt;KR,<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">V</a>&gt;</code></td>
<td class="colLast"><code><strong><a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#selectKey(org.apache.kafka.streams.kstream.KeyValueMapper)">selectKey</a></strong>(<a href="../../../../../org/apache/kafka/streams/kstream/KeyValueMapper.html" title="interface in org.apache.kafka.streams.kstream">KeyValueMapper</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">K</a>,? super <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">V</a>,? extends KR&gt;&nbsp;mapper)</code>
<div class="block">Set a new key (with possibly new type) for each input record.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="interface in org.apache.kafka.streams.kstream">KStream</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">K</a>,<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">V</a>&gt;</code></td>
<td class="colLast"><code><strong><a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#through(org.apache.kafka.common.serialization.Serde,%20org.apache.kafka.common.serialization.Serde,%20org.apache.kafka.streams.processor.StreamPartitioner,%20java.lang.String)">through</a></strong>(<a href="../../../../../org/apache/kafka/common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization">Serde</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">K</a>&gt;&nbsp;keySerde,
       <a href="../../../../../org/apache/kafka/common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization">Serde</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">V</a>&gt;&nbsp;valSerde,
       <a href="../../../../../org/apache/kafka/streams/processor/StreamPartitioner.html" title="interface in org.apache.kafka.streams.processor">StreamPartitioner</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">K</a>,? super <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">V</a>&gt;&nbsp;partitioner,
       java.lang.String&nbsp;topic)</code>
<div class="block">Materialize this stream to a topic and creates a new <code>KStream</code> from the topic using a customizable
 <a href="../../../../../org/apache/kafka/streams/processor/StreamPartitioner.html" title="interface in org.apache.kafka.streams.processor"><code>StreamPartitioner</code></a> to determine the distribution of records to partitions.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="interface in org.apache.kafka.streams.kstream">KStream</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">K</a>,<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">V</a>&gt;</code></td>
<td class="colLast"><code><strong><a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#through(org.apache.kafka.common.serialization.Serde,%20org.apache.kafka.common.serialization.Serde,%20java.lang.String)">through</a></strong>(<a href="../../../../../org/apache/kafka/common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization">Serde</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">K</a>&gt;&nbsp;keySerde,
       <a href="../../../../../org/apache/kafka/common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization">Serde</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">V</a>&gt;&nbsp;valSerde,
       java.lang.String&nbsp;topic)</code>
<div class="block">Materialize this stream to a topic, and creates a new <code>KStream</code> from the topic.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="interface in org.apache.kafka.streams.kstream">KStream</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">K</a>,<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">V</a>&gt;</code></td>
<td class="colLast"><code><strong><a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#through(org.apache.kafka.streams.processor.StreamPartitioner,%20java.lang.String)">through</a></strong>(<a href="../../../../../org/apache/kafka/streams/processor/StreamPartitioner.html" title="interface in org.apache.kafka.streams.processor">StreamPartitioner</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">K</a>,? super <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">V</a>&gt;&nbsp;partitioner,
       java.lang.String&nbsp;topic)</code>
<div class="block">Materialize this stream to a topic and creates a new <code>KStream</code> from the topic using default serializers and
 deserializers and a customizable <a href="../../../../../org/apache/kafka/streams/processor/StreamPartitioner.html" title="interface in org.apache.kafka.streams.processor"><code>StreamPartitioner</code></a> to determine the distribution of records to partitions.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="interface in org.apache.kafka.streams.kstream">KStream</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">K</a>,<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">V</a>&gt;</code></td>
<td class="colLast"><code><strong><a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#through(java.lang.String)">through</a></strong>(java.lang.String&nbsp;topic)</code>
<div class="block">Materialize this stream to a topic and creates a new <code>KStream</code> from the topic using default serializers and
 deserializers and producer's <code>DefaultPartitioner</code>.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#to(org.apache.kafka.common.serialization.Serde,%20org.apache.kafka.common.serialization.Serde,%20org.apache.kafka.streams.processor.StreamPartitioner,%20java.lang.String)">to</a></strong>(<a href="../../../../../org/apache/kafka/common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization">Serde</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">K</a>&gt;&nbsp;keySerde,
  <a href="../../../../../org/apache/kafka/common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization">Serde</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">V</a>&gt;&nbsp;valSerde,
  <a href="../../../../../org/apache/kafka/streams/processor/StreamPartitioner.html" title="interface in org.apache.kafka.streams.processor">StreamPartitioner</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">K</a>,? super <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">V</a>&gt;&nbsp;partitioner,
  java.lang.String&nbsp;topic)</code>
<div class="block">Materialize this stream to a topic using a customizable <a href="../../../../../org/apache/kafka/streams/processor/StreamPartitioner.html" title="interface in org.apache.kafka.streams.processor"><code>StreamPartitioner</code></a> to determine the distribution
 of records to partitions.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#to(org.apache.kafka.common.serialization.Serde,%20org.apache.kafka.common.serialization.Serde,%20java.lang.String)">to</a></strong>(<a href="../../../../../org/apache/kafka/common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization">Serde</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">K</a>&gt;&nbsp;keySerde,
  <a href="../../../../../org/apache/kafka/common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization">Serde</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">V</a>&gt;&nbsp;valSerde,
  java.lang.String&nbsp;topic)</code>
<div class="block">Materialize this stream to a topic.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#to(org.apache.kafka.streams.processor.StreamPartitioner,%20java.lang.String)">to</a></strong>(<a href="../../../../../org/apache/kafka/streams/processor/StreamPartitioner.html" title="interface in org.apache.kafka.streams.processor">StreamPartitioner</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">K</a>,? super <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">V</a>&gt;&nbsp;partitioner,
  java.lang.String&nbsp;topic)</code>
<div class="block">Materialize this stream to a topic using default serializers specified in the config and a customizable
 <a href="../../../../../org/apache/kafka/streams/processor/StreamPartitioner.html" title="interface in org.apache.kafka.streams.processor"><code>StreamPartitioner</code></a> to determine the distribution of records to partitions.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#to(java.lang.String)">to</a></strong>(java.lang.String&nbsp;topic)</code>
<div class="block">Materialize this stream to a topic using default serializers specified in the config and producer's
 <code>DefaultPartitioner</code>.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>&lt;K1,V1&gt;&nbsp;<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="interface in org.apache.kafka.streams.kstream">KStream</a>&lt;K1,V1&gt;</code></td>
<td class="colLast"><code><strong><a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#transform(org.apache.kafka.streams.kstream.TransformerSupplier,%20java.lang.String...)">transform</a></strong>(<a href="../../../../../org/apache/kafka/streams/kstream/TransformerSupplier.html" title="interface in org.apache.kafka.streams.kstream">TransformerSupplier</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">K</a>,? super <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">V</a>,<a href="../../../../../org/apache/kafka/streams/KeyValue.html" title="class in org.apache.kafka.streams">KeyValue</a>&lt;K1,V1&gt;&gt;&nbsp;transformerSupplier,
         java.lang.String...&nbsp;stateStoreNames)</code>
<div class="block">Transform each record of the input stream into zero or more records in the output stream (both key and value type
 can be altered arbitrarily).</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>&lt;VR&gt;&nbsp;<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="interface in org.apache.kafka.streams.kstream">KStream</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">K</a>,VR&gt;</code></td>
<td class="colLast"><code><strong><a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#transformValues(org.apache.kafka.streams.kstream.ValueTransformerSupplier,%20java.lang.String...)">transformValues</a></strong>(<a href="../../../../../org/apache/kafka/streams/kstream/ValueTransformerSupplier.html" title="interface in org.apache.kafka.streams.kstream">ValueTransformerSupplier</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">V</a>,? extends VR&gt;&nbsp;valueTransformerSupplier,
               java.lang.String...&nbsp;stateStoreNames)</code>
<div class="block">Transform the value of each input record into a new value (with possible new type) of the output record.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#writeAsText(java.lang.String)">writeAsText</a></strong>(java.lang.String&nbsp;filePath)</code>
<div class="block">Write the records of this stream to a file at the given path.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#writeAsText(java.lang.String,%20org.apache.kafka.common.serialization.Serde,%20org.apache.kafka.common.serialization.Serde)">writeAsText</a></strong>(java.lang.String&nbsp;filePath,
           <a href="../../../../../org/apache/kafka/common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization">Serde</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">K</a>&gt;&nbsp;keySerde,
           <a href="../../../../../org/apache/kafka/common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization">Serde</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">V</a>&gt;&nbsp;valSerde)</code>
<div class="block">Write the records of this stream to a file at the given path.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#writeAsText(java.lang.String,%20java.lang.String)">writeAsText</a></strong>(java.lang.String&nbsp;filePath,
           java.lang.String&nbsp;streamName)</code>
<div class="block">Write the records of this stream to a file at the given path.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#writeAsText(java.lang.String,%20java.lang.String,%20org.apache.kafka.common.serialization.Serde,%20org.apache.kafka.common.serialization.Serde)">writeAsText</a></strong>(java.lang.String&nbsp;filePath,
           java.lang.String&nbsp;streamName,
           <a href="../../../../../org/apache/kafka/common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization">Serde</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">K</a>&gt;&nbsp;keySerde,
           <a href="../../../../../org/apache/kafka/common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization">Serde</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">V</a>&gt;&nbsp;valSerde)</code>
<div class="block">Write the records of this stream to a file at the given path.</div>
</td>
</tr>
</table>
</li>
</ul>
</li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ============ METHOD DETAIL ========== -->
<ul class="blockList">
<li class="blockList"><a name="method_detail">
<!--   -->
</a>
<h3>Method Detail</h3>
<a name="filter(org.apache.kafka.streams.kstream.Predicate)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>filter</h4>
<pre><a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="interface in org.apache.kafka.streams.kstream">KStream</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">K</a>,<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">V</a>&gt;&nbsp;filter(<a href="../../../../../org/apache/kafka/streams/kstream/Predicate.html" title="interface in org.apache.kafka.streams.kstream">Predicate</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">K</a>,? super <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">V</a>&gt;&nbsp;predicate)</pre>
<div class="block">Create a new <code>KStream</code> that consists of all records of this stream which satisfy the given predicate.
 All records that do not satisfy the predicate are dropped.
 This is a stateless record-by-record operation.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>predicate</code> - a filter <a href="../../../../../org/apache/kafka/streams/kstream/Predicate.html" title="interface in org.apache.kafka.streams.kstream"><code>Predicate</code></a> that is applied to each record</dd>
<dt><span class="strong">Returns:</span></dt><dd>a <code>KStream</code> that contains only those records that satisfy the given predicate</dd><dt><span class="strong">See Also:</span></dt><dd><a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#filterNot(org.apache.kafka.streams.kstream.Predicate)"><code>filterNot(Predicate)</code></a></dd></dl>
</li>
</ul>
<a name="filterNot(org.apache.kafka.streams.kstream.Predicate)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>filterNot</h4>
<pre><a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="interface in org.apache.kafka.streams.kstream">KStream</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">K</a>,<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">V</a>&gt;&nbsp;filterNot(<a href="../../../../../org/apache/kafka/streams/kstream/Predicate.html" title="interface in org.apache.kafka.streams.kstream">Predicate</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">K</a>,? super <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">V</a>&gt;&nbsp;predicate)</pre>
<div class="block">Create a new <code>KStream</code> that consists all records of this stream which do <em>not</em> satisfy the given
 predicate.
 All records that <em>do</em> satisfy the predicate are dropped.
 This is a stateless record-by-record operation.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>predicate</code> - a filter <a href="../../../../../org/apache/kafka/streams/kstream/Predicate.html" title="interface in org.apache.kafka.streams.kstream"><code>Predicate</code></a> that is applied to each record</dd>
<dt><span class="strong">Returns:</span></dt><dd>a <code>KStream</code> that contains only those records that do <em>not</em> satisfy the given predicate</dd><dt><span class="strong">See Also:</span></dt><dd><a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#filter(org.apache.kafka.streams.kstream.Predicate)"><code>filter(Predicate)</code></a></dd></dl>
</li>
</ul>
<a name="selectKey(org.apache.kafka.streams.kstream.KeyValueMapper)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>selectKey</h4>
<pre>&lt;KR&gt;&nbsp;<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="interface in org.apache.kafka.streams.kstream">KStream</a>&lt;KR,<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">V</a>&gt;&nbsp;selectKey(<a href="../../../../../org/apache/kafka/streams/kstream/KeyValueMapper.html" title="interface in org.apache.kafka.streams.kstream">KeyValueMapper</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">K</a>,? super <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">V</a>,? extends KR&gt;&nbsp;mapper)</pre>
<div class="block">Set a new key (with possibly new type) for each input record.
 The provided <a href="../../../../../org/apache/kafka/streams/kstream/KeyValueMapper.html" title="interface in org.apache.kafka.streams.kstream"><code>KeyValueMapper</code></a> is applied to each input record and computes a new key for it.
 Thus, an input record <code>&lt;K,V&gt;</code> can be transformed into an output record <code>&lt;K':V&gt;</code>.
 This is a stateless record-by-record operation.
 <p>
 For example, you can use this transformation to set a key for a key-less input record <code>&lt;null,V&gt;</code> by
 extracting a key from the value within your <a href="../../../../../org/apache/kafka/streams/kstream/KeyValueMapper.html" title="interface in org.apache.kafka.streams.kstream"><code>KeyValueMapper</code></a>. The example below computes the new key as the
 length of the value string.
 <pre class="line-numbers"><code>KStream&lt;Byte[], String&gt; keyLessStream = builder.stream("key-less-topic");
 KStream&lt;Integer, String&gt; keyedStream = keyLessStream.selectKey(new KeyValueMapper&lt;Byte[], String, Integer&gt; {
     Integer apply(Byte[] key, String value) {
         return value.length();
     }
 });
 </code></pre>
 <p>
 Setting a new key might result in an internal data redistribution if a key based operator (like an aggregation or
 join) is applied to the result <code>KStream</code>.</div>
<dl><dt><span class="strong">Type Parameters:</span></dt><dd><code>KR</code> - the new key type of the result stream</dd><dt><span class="strong">Parameters:</span></dt><dd><code>mapper</code> - a <a href="../../../../../org/apache/kafka/streams/kstream/KeyValueMapper.html" title="interface in org.apache.kafka.streams.kstream"><code>KeyValueMapper</code></a> that computes a new key for each record</dd>
<dt><span class="strong">Returns:</span></dt><dd>a <code>KStream</code> that contains records with new key (possibly of different type) and unmodified value</dd><dt><span class="strong">See Also:</span></dt><dd><a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#map(org.apache.kafka.streams.kstream.KeyValueMapper)"><code>map(KeyValueMapper)</code></a>, 
<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#flatMap(org.apache.kafka.streams.kstream.KeyValueMapper)"><code>flatMap(KeyValueMapper)</code></a>, 
<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#mapValues(org.apache.kafka.streams.kstream.ValueMapper)"><code>mapValues(ValueMapper)</code></a>, 
<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#flatMapValues(org.apache.kafka.streams.kstream.ValueMapper)"><code>flatMapValues(ValueMapper)</code></a></dd></dl>
</li>
</ul>
<a name="map(org.apache.kafka.streams.kstream.KeyValueMapper)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>map</h4>
<pre>&lt;KR,VR&gt;&nbsp;<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="interface in org.apache.kafka.streams.kstream">KStream</a>&lt;KR,VR&gt;&nbsp;map(<a href="../../../../../org/apache/kafka/streams/kstream/KeyValueMapper.html" title="interface in org.apache.kafka.streams.kstream">KeyValueMapper</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">K</a>,? super <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">V</a>,? extends <a href="../../../../../org/apache/kafka/streams/KeyValue.html" title="class in org.apache.kafka.streams">KeyValue</a>&lt;? extends KR,? extends VR&gt;&gt;&nbsp;mapper)</pre>
<div class="block">Transform each record of the input stream into a new record in the output stream (both key and value type can be
 altered arbitrarily).
 The provided <a href="../../../../../org/apache/kafka/streams/kstream/KeyValueMapper.html" title="interface in org.apache.kafka.streams.kstream"><code>KeyValueMapper</code></a> is applied to each input record and computes a new output record.
 Thus, an input record <code>&lt;K,V&gt;</code> can be transformed into an output record <code>&lt;K':V'&gt;</code>.
 This is a stateless record-by-record operation (cf. <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#transform(org.apache.kafka.streams.kstream.TransformerSupplier,%20java.lang.String...)"><code>transform(TransformerSupplier, String...)</code></a> for
 stateful record transformation).
 <p>
 The example below normalizes the String key to upper-case letters and counts the number of token of the value string.
 <pre class="line-numbers"><code>KStream&lt;String, String&gt; inputStream = builder.stream("topic");
 KStream&lt;Integer, String&gt; outputStream = inputStream.map(new KeyValueMapper&lt;String, String, KeyValue&lt;String, Integer&gt;&gt; {
     KeyValue&lt;String, Integer&gt; apply(String key, String value) {
         return new KeyValue&lt;&gt;(key.toUpperCase(), value.split(" ").length);
     }
 });
 </code></pre>
 <p>
 The provided <a href="../../../../../org/apache/kafka/streams/kstream/KeyValueMapper.html" title="interface in org.apache.kafka.streams.kstream"><code>KeyValueMapper</code></a> must return a <a href="../../../../../org/apache/kafka/streams/KeyValue.html" title="class in org.apache.kafka.streams"><code>KeyValue</code></a> type and must not return <code>null</code>.
 <p>
 Mapping records might result in an internal data redistribution if a key based operator (like an aggregation or
 join) is applied to the result <code>KStream</code>. (cf. <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#mapValues(org.apache.kafka.streams.kstream.ValueMapper)"><code>mapValues(ValueMapper)</code></a>)</div>
<dl><dt><span class="strong">Type Parameters:</span></dt><dd><code>KR</code> - the key type of the result stream</dd><dd><code>VR</code> - the value type of the result stream</dd><dt><span class="strong">Parameters:</span></dt><dd><code>mapper</code> - a <a href="../../../../../org/apache/kafka/streams/kstream/KeyValueMapper.html" title="interface in org.apache.kafka.streams.kstream"><code>KeyValueMapper</code></a> that computes a new output record</dd>
<dt><span class="strong">Returns:</span></dt><dd>a <code>KStream</code> that contains records with new key and value (possibly both of different type)</dd><dt><span class="strong">See Also:</span></dt><dd><a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#selectKey(org.apache.kafka.streams.kstream.KeyValueMapper)"><code>selectKey(KeyValueMapper)</code></a>, 
<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#flatMap(org.apache.kafka.streams.kstream.KeyValueMapper)"><code>flatMap(KeyValueMapper)</code></a>, 
<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#mapValues(org.apache.kafka.streams.kstream.ValueMapper)"><code>mapValues(ValueMapper)</code></a>, 
<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#flatMapValues(org.apache.kafka.streams.kstream.ValueMapper)"><code>flatMapValues(ValueMapper)</code></a>, 
<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#transform(org.apache.kafka.streams.kstream.TransformerSupplier,%20java.lang.String...)"><code>transform(TransformerSupplier, String...)</code></a>, 
<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#transformValues(org.apache.kafka.streams.kstream.ValueTransformerSupplier,%20java.lang.String...)"><code>transformValues(ValueTransformerSupplier, String...)</code></a></dd></dl>
</li>
</ul>
<a name="mapValues(org.apache.kafka.streams.kstream.ValueMapper)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>mapValues</h4>
<pre>&lt;VR&gt;&nbsp;<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="interface in org.apache.kafka.streams.kstream">KStream</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">K</a>,VR&gt;&nbsp;mapValues(<a href="../../../../../org/apache/kafka/streams/kstream/ValueMapper.html" title="interface in org.apache.kafka.streams.kstream">ValueMapper</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">V</a>,? extends VR&gt;&nbsp;mapper)</pre>
<div class="block">Transform the value of each input record into a new value (with possible new type) of the output record.
 The provided <a href="../../../../../org/apache/kafka/streams/kstream/ValueMapper.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueMapper</code></a> is applied to each input record value and computes a new value for it.
 Thus, an input record <code>&lt;K,V&gt;</code> can be transformed into an output record <code>&lt;K:V'&gt;</code>.
 This is a stateless record-by-record operation (cf.
 <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#transformValues(org.apache.kafka.streams.kstream.ValueTransformerSupplier,%20java.lang.String...)"><code>transformValues(ValueTransformerSupplier, String...)</code></a> for stateful value transformation).
 <p>
 The example below counts the number of token of the value string.
 <pre class="line-numbers"><code>KStream&lt;String, String&gt; inputStream = builder.stream("topic");
 KStream&lt;String, Integer&gt; outputStream = inputStream.mapValues(new ValueMapper&lt;String, Integer&gt; {
     Integer apply(String value) {
         return value.split(" ").length;
     }
 });
 </code></pre>
 <p>
 Setting a new value preserves data co-location with respect to the key.
 Thus, <em>no</em> internal data redistribution is required if a key based operator (like an aggregation or join)
 is applied to the result <code>KStream</code>. (cf. <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#map(org.apache.kafka.streams.kstream.KeyValueMapper)"><code>map(KeyValueMapper)</code></a>)</div>
<dl><dt><span class="strong">Type Parameters:</span></dt><dd><code>VR</code> - the value type of the result stream</dd><dt><span class="strong">Parameters:</span></dt><dd><code>mapper</code> - a <a href="../../../../../org/apache/kafka/streams/kstream/ValueMapper.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueMapper</code></a> that computes a new output value</dd>
<dt><span class="strong">Returns:</span></dt><dd>a <code>KStream</code> that contains records with unmodified key and new values (possibly of different type)</dd><dt><span class="strong">See Also:</span></dt><dd><a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#selectKey(org.apache.kafka.streams.kstream.KeyValueMapper)"><code>selectKey(KeyValueMapper)</code></a>, 
<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#map(org.apache.kafka.streams.kstream.KeyValueMapper)"><code>map(KeyValueMapper)</code></a>, 
<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#flatMap(org.apache.kafka.streams.kstream.KeyValueMapper)"><code>flatMap(KeyValueMapper)</code></a>, 
<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#flatMapValues(org.apache.kafka.streams.kstream.ValueMapper)"><code>flatMapValues(ValueMapper)</code></a>, 
<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#transform(org.apache.kafka.streams.kstream.TransformerSupplier,%20java.lang.String...)"><code>transform(TransformerSupplier, String...)</code></a>, 
<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#transformValues(org.apache.kafka.streams.kstream.ValueTransformerSupplier,%20java.lang.String...)"><code>transformValues(ValueTransformerSupplier, String...)</code></a></dd></dl>
</li>
</ul>
<a name="flatMap(org.apache.kafka.streams.kstream.KeyValueMapper)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>flatMap</h4>
<pre>&lt;KR,VR&gt;&nbsp;<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="interface in org.apache.kafka.streams.kstream">KStream</a>&lt;KR,VR&gt;&nbsp;flatMap(<a href="../../../../../org/apache/kafka/streams/kstream/KeyValueMapper.html" title="interface in org.apache.kafka.streams.kstream">KeyValueMapper</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">K</a>,? super <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">V</a>,? extends java.lang.Iterable&lt;? extends <a href="../../../../../org/apache/kafka/streams/KeyValue.html" title="class in org.apache.kafka.streams">KeyValue</a>&lt;? extends KR,? extends VR&gt;&gt;&gt;&nbsp;mapper)</pre>
<div class="block">Transform each record of the input stream into zero or more records in the output stream (both key and value type
 can be altered arbitrarily).
 The provided <a href="../../../../../org/apache/kafka/streams/kstream/KeyValueMapper.html" title="interface in org.apache.kafka.streams.kstream"><code>KeyValueMapper</code></a> is applied to each input record and computes zero or more output records.
 Thus, an input record <code>&lt;K,V&gt;</code> can be transformed into output records <code>&lt;K':V'&gt;, &lt;K'':V''&gt;, ...</code>.
 This is a stateless record-by-record operation (cf. <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#transform(org.apache.kafka.streams.kstream.TransformerSupplier,%20java.lang.String...)"><code>transform(TransformerSupplier, String...)</code></a> for
 stateful record transformation).
 <p>
 The example below splits input records <code>&lt;null:String&gt;</code> containing sentences as values into their words
 and emit a record <code>&lt;word:1&gt;</code> for each word.
 <pre class="line-numbers"><code>KStream&lt;byte[], String&gt; inputStream = builder.stream("topic");
 KStream&lt;String, Integer&gt; outputStream = inputStream.flatMap(new KeyValueMapper&lt;byte[], String, Iterable&lt;KeyValue&lt;String, Integer&gt;&gt;&gt; {
     Iterable&lt;KeyValue&lt;String, Integer&gt;&gt; apply(byte[] key, String value) {
         String[] tokens = value.split(" ");
         List&lt;KeyValue&lt;String, Integer&gt;&gt; result = new ArrayList&lt;&gt;(tokens.length);

         for(String token : tokens) {
             result.add(new KeyValue&lt;&gt;(token, 1));
         }

         return result;
     }
 });
 </code></pre>
 <p>
 The provided <a href="../../../../../org/apache/kafka/streams/kstream/KeyValueMapper.html" title="interface in org.apache.kafka.streams.kstream"><code>KeyValueMapper</code></a> must return an <code>Iterable</code> (e.g., any <code>Collection</code> type)
 and the return value must not be <code>null</code>.
 <p>
 Flat-mapping records might result in an internal data redistribution if a key based operator (like an aggregation
 or join) is applied to the result <code>KStream</code>. (cf. <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#flatMapValues(org.apache.kafka.streams.kstream.ValueMapper)"><code>flatMapValues(ValueMapper)</code></a>)</div>
<dl><dt><span class="strong">Type Parameters:</span></dt><dd><code>KR</code> - the key type of the result stream</dd><dd><code>VR</code> - the value type of the result stream</dd><dt><span class="strong">Parameters:</span></dt><dd><code>mapper</code> - a <a href="../../../../../org/apache/kafka/streams/kstream/KeyValueMapper.html" title="interface in org.apache.kafka.streams.kstream"><code>KeyValueMapper</code></a> that computes the new output records</dd>
<dt><span class="strong">Returns:</span></dt><dd>a <code>KStream</code> that contains more or less records with new key and value (possibly of different type)</dd><dt><span class="strong">See Also:</span></dt><dd><a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#selectKey(org.apache.kafka.streams.kstream.KeyValueMapper)"><code>selectKey(KeyValueMapper)</code></a>, 
<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#map(org.apache.kafka.streams.kstream.KeyValueMapper)"><code>map(KeyValueMapper)</code></a>, 
<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#mapValues(org.apache.kafka.streams.kstream.ValueMapper)"><code>mapValues(ValueMapper)</code></a>, 
<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#flatMapValues(org.apache.kafka.streams.kstream.ValueMapper)"><code>flatMapValues(ValueMapper)</code></a>, 
<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#transform(org.apache.kafka.streams.kstream.TransformerSupplier,%20java.lang.String...)"><code>transform(TransformerSupplier, String...)</code></a>, 
<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#transformValues(org.apache.kafka.streams.kstream.ValueTransformerSupplier,%20java.lang.String...)"><code>transformValues(ValueTransformerSupplier, String...)</code></a></dd></dl>
</li>
</ul>
<a name="flatMapValues(org.apache.kafka.streams.kstream.ValueMapper)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>flatMapValues</h4>
<pre>&lt;VR&gt;&nbsp;<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="interface in org.apache.kafka.streams.kstream">KStream</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">K</a>,VR&gt;&nbsp;flatMapValues(<a href="../../../../../org/apache/kafka/streams/kstream/ValueMapper.html" title="interface in org.apache.kafka.streams.kstream">ValueMapper</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">V</a>,? extends java.lang.Iterable&lt;? extends VR&gt;&gt;&nbsp;processor)</pre>
<div class="block">Create a new <code>KStream</code> by transforming the value of each record in this stream into zero or more values
 with the same key in the new stream.
 Transform the value of each input record into zero or more records with the same (unmodified) key in the output
 stream (value type can be altered arbitrarily).
 The provided <a href="../../../../../org/apache/kafka/streams/kstream/ValueMapper.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueMapper</code></a> is applied to each input record and computes zero or more output values.
 Thus, an input record <code>&lt;K,V&gt;</code> can be transformed into output records <code>&lt;K:V'&gt;, &lt;K:V''&gt;, ...</code>.
 This is a stateless record-by-record operation (cf. <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#transformValues(org.apache.kafka.streams.kstream.ValueTransformerSupplier,%20java.lang.String...)"><code>transformValues(ValueTransformerSupplier, String...)</code></a>
 for stateful value transformation).
 <p>
 The example below splits input records <code>&lt;null:String&gt;</code> containing sentences as values into their words.
 <pre class="line-numbers"><code>KStream&lt;byte[], String&gt; inputStream = builder.stream("topic");
 KStream&lt;byte[], String&gt; outputStream = inputStream.flatMapValues(new ValueMapper&lt;String, Iterable&lt;String&gt;&gt; {
     Iterable&lt;String&gt; apply(String value) {
         return Arrays.asList(value.split(" "));
     }
 });
 </code></pre>
 <p>
 The provided <a href="../../../../../org/apache/kafka/streams/kstream/ValueMapper.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueMapper</code></a> must return an <code>Iterable</code> (e.g., any <code>Collection</code> type)
 and the return value must not be <code>null</code>.
 <p>
 Splitting a record into multiple records with the same key preserves data co-location with respect to the key.
 Thus, <em>no</em> internal data redistribution is required if a key based operator (like an aggregation or join)
 is applied to the result <code>KStream</code>. (cf. <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#flatMap(org.apache.kafka.streams.kstream.KeyValueMapper)"><code>flatMap(KeyValueMapper)</code></a>)</div>
<dl><dt><span class="strong">Type Parameters:</span></dt><dd><code>VR</code> - the value type of the result stream</dd><dt><span class="strong">Parameters:</span></dt><dd><code>processor</code> - a <a href="../../../../../org/apache/kafka/streams/kstream/ValueMapper.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueMapper</code></a> the computes the new output values</dd>
<dt><span class="strong">Returns:</span></dt><dd>a <code>KStream</code> that contains more or less records with unmodified keys and new values of different type</dd><dt><span class="strong">See Also:</span></dt><dd><a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#selectKey(org.apache.kafka.streams.kstream.KeyValueMapper)"><code>selectKey(KeyValueMapper)</code></a>, 
<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#map(org.apache.kafka.streams.kstream.KeyValueMapper)"><code>map(KeyValueMapper)</code></a>, 
<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#flatMap(org.apache.kafka.streams.kstream.KeyValueMapper)"><code>flatMap(KeyValueMapper)</code></a>, 
<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#mapValues(org.apache.kafka.streams.kstream.ValueMapper)"><code>mapValues(ValueMapper)</code></a>, 
<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#transform(org.apache.kafka.streams.kstream.TransformerSupplier,%20java.lang.String...)"><code>transform(TransformerSupplier, String...)</code></a>, 
<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#transformValues(org.apache.kafka.streams.kstream.ValueTransformerSupplier,%20java.lang.String...)"><code>transformValues(ValueTransformerSupplier, String...)</code></a></dd></dl>
</li>
</ul>
<a name="print()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>print</h4>
<pre>void&nbsp;print()</pre>
<div class="block">Print the records of this stream to <code>System.out</code>.
 This function will use the generated name of the parent processor node to label the key/value pairs printed to
 the console.
 <p>
 The default serde will be used to deserialize the key or value in case the type is <code>byte[]</code> before calling
 <code>toString()</code> on the deserialized object.
 <p>
 Implementors will need to override <code>toString()</code> for keys and values that are not of type <code>String</code>,
 <code>Integer</code> etc. to get meaningful information.</div>
</li>
</ul>
<a name="print(java.lang.String)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>print</h4>
<pre>void&nbsp;print(java.lang.String&nbsp;streamName)</pre>
<div class="block">Print the records of this stream to <code>System.out</code>.
 This function will use the given name to label the key/value pairs printed to the console.
 <p>
 The default serde will be used to deserialize the key or value in case the type is <code>byte[]</code> before calling
 <code>toString()</code> on the deserialized object.
 <p>
 Implementors will need to override <code>toString()</code> for keys and values that are not of type <code>String</code>,
 <code>Integer</code> etc. to get meaningful information.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>streamName</code> - the name used to label the key/value pairs printed to the console</dd></dl>
</li>
</ul>
<a name="print(org.apache.kafka.common.serialization.Serde, org.apache.kafka.common.serialization.Serde)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>print</h4>
<pre>void&nbsp;print(<a href="../../../../../org/apache/kafka/common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization">Serde</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">K</a>&gt;&nbsp;keySerde,
         <a href="../../../../../org/apache/kafka/common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization">Serde</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">V</a>&gt;&nbsp;valSerde)</pre>
<div class="block">Print the records of this stream to <code>System.out</code>.
 This function will use the generated name of the parent processor node to label the key/value pairs printed to
 the console.
 <p>
 The provided serde will be used to deserialize the key or value in case the type is <code>byte[]</code> before calling
 <code>toString()</code> on the deserialized object.
 <p>
 Implementors will need to override <code>toString()</code> for keys and values that are not of type <code>String</code>,
 <code>Integer</code> etc. to get meaningful information.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>keySerde</code> - key serde used to deserialize key if type is <code>byte[]</code>,</dd><dd><code>valSerde</code> - value serde used to deserialize value if type is <code>byte[]</code>,</dd></dl>
</li>
</ul>
<a name="print(org.apache.kafka.common.serialization.Serde, org.apache.kafka.common.serialization.Serde, java.lang.String)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>print</h4>
<pre>void&nbsp;print(<a href="../../../../../org/apache/kafka/common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization">Serde</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">K</a>&gt;&nbsp;keySerde,
         <a href="../../../../../org/apache/kafka/common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization">Serde</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">V</a>&gt;&nbsp;valSerde,
         java.lang.String&nbsp;streamName)</pre>
<div class="block">Print the records of this stream to <code>System.out</code>.
 <p>
 The provided serde will be used to deserialize the key or value in case the type is <code>byte[]</code> before calling
 <code>toString()</code> on the deserialized object.
 <p>
 Implementors will need to override <code>toString()</code> for keys and values that are not of type <code>String</code>,
 <code>Integer</code> etc. to get meaningful information.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>keySerde</code> - key serde used to deserialize key if type is <code>byte[]</code>,</dd><dd><code>valSerde</code> - value serde used to deserialize value if type is <code>byte[]</code>,</dd><dd><code>streamName</code> - the name used to label the key/value pairs printed to the console</dd></dl>
</li>
</ul>
<a name="writeAsText(java.lang.String)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>writeAsText</h4>
<pre>void&nbsp;writeAsText(java.lang.String&nbsp;filePath)</pre>
<div class="block">Write the records of this stream to a file at the given path.
 This function will use the generated name of the parent processor node to label the key/value pairs printed to
 the file.
 <p>
 The default serde will be used to deserialize the key or value in case the type is <code>byte[]</code> before calling
 <code>toString()</code> on the deserialized object.
 <p>
 Implementors will need to override <code>toString()</code> for keys and values that are not of type <code>String</code>,
 <code>Integer</code> etc. to get meaningful information.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>filePath</code> - name of the file to write to</dd></dl>
</li>
</ul>
<a name="writeAsText(java.lang.String, java.lang.String)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>writeAsText</h4>
<pre>void&nbsp;writeAsText(java.lang.String&nbsp;filePath,
               java.lang.String&nbsp;streamName)</pre>
<div class="block">Write the records of this stream to a file at the given path.
 This function will use the given name to label the key/value printed to the file.
 <p>
 The default serde will be used to deserialize the key or value in case the type is <code>byte[]</code> before calling
 <code>toString()</code> on the deserialized object.
 <p>
 Implementors will need to override <code>toString()</code> for keys and values that are not of type <code>String</code>,
 <code>Integer</code> etc. to get meaningful information.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>filePath</code> - name of the file to write to</dd><dd><code>streamName</code> - the name used to label the key/value pairs written to the file</dd></dl>
</li>
</ul>
<a name="writeAsText(java.lang.String, org.apache.kafka.common.serialization.Serde, org.apache.kafka.common.serialization.Serde)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>writeAsText</h4>
<pre>void&nbsp;writeAsText(java.lang.String&nbsp;filePath,
               <a href="../../../../../org/apache/kafka/common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization">Serde</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">K</a>&gt;&nbsp;keySerde,
               <a href="../../../../../org/apache/kafka/common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization">Serde</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">V</a>&gt;&nbsp;valSerde)</pre>
<div class="block">Write the records of this stream to a file at the given path.
 This function will use the generated name of the parent processor node to label the key/value pairs printed to
 the file.
 <p>
 The provided serde will be used to deserialize the key or value in case the type is <code>byte[]</code> before calling
 <code>toString()</code> on the deserialized object.
 <p>
 Implementors will need to override <code>toString()</code> for keys and values that are not of type <code>String</code>,
 <code>Integer</code> etc. to get meaningful information.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>filePath</code> - name of the file to write to</dd><dd><code>keySerde</code> - key serde used to deserialize key if type is <code>byte[]</code>,</dd><dd><code>valSerde</code> - value serde used to deserialize value if type is <code>byte[]</code>,</dd></dl>
</li>
</ul>
<a name="writeAsText(java.lang.String, java.lang.String, org.apache.kafka.common.serialization.Serde, org.apache.kafka.common.serialization.Serde)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>writeAsText</h4>
<pre>void&nbsp;writeAsText(java.lang.String&nbsp;filePath,
               java.lang.String&nbsp;streamName,
               <a href="../../../../../org/apache/kafka/common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization">Serde</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">K</a>&gt;&nbsp;keySerde,
               <a href="../../../../../org/apache/kafka/common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization">Serde</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">V</a>&gt;&nbsp;valSerde)</pre>
<div class="block">Write the records of this stream to a file at the given path.
 This function will use the given name to label the key/value printed to the file.
 <p>
 The provided serde will be used to deserialize the key or value in case the type is <code>byte[]</code>
 before calling <code>toString()</code> on the deserialized object.
 <p>
 Implementors will need to override <code>toString()</code> for keys and values that are not of type <code>String</code>,
 <code>Integer</code> etc. to get meaningful information.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>filePath</code> - name of the file to write to</dd><dd><code>streamName</code> - the name used to label the key/value pairs written to the file</dd><dd><code>keySerde</code> - key serde used to deserialize key if type is <code>byte[]</code>,</dd><dd><code>valSerde</code> - value serde used deserialize value if type is <code>byte[]</code>,</dd></dl>
</li>
</ul>
<a name="foreach(org.apache.kafka.streams.kstream.ForeachAction)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>foreach</h4>
<pre>void&nbsp;foreach(<a href="../../../../../org/apache/kafka/streams/kstream/ForeachAction.html" title="interface in org.apache.kafka.streams.kstream">ForeachAction</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">K</a>,? super <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">V</a>&gt;&nbsp;action)</pre>
<div class="block">Perform an action on each record of <code>KStream</code>.
 This is a stateless record-by-record operation (cf. <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#process(org.apache.kafka.streams.processor.ProcessorSupplier,%20java.lang.String...)"><code>process(ProcessorSupplier, String...)</code></a>).
 Note that this is a terminal operation that returns void.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>action</code> - an action to perform on each record</dd><dt><span class="strong">See Also:</span></dt><dd><a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#process(org.apache.kafka.streams.processor.ProcessorSupplier,%20java.lang.String...)"><code>process(ProcessorSupplier, String...)</code></a></dd></dl>
</li>
</ul>
<a name="peek(org.apache.kafka.streams.kstream.ForeachAction)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>peek</h4>
<pre><a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="interface in org.apache.kafka.streams.kstream">KStream</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">K</a>,<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">V</a>&gt;&nbsp;peek(<a href="../../../../../org/apache/kafka/streams/kstream/ForeachAction.html" title="interface in org.apache.kafka.streams.kstream">ForeachAction</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">K</a>,? super <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">V</a>&gt;&nbsp;action)</pre>
<div class="block">Perform an action on each record of <code>KStream</code>.
 This is a stateless record-by-record operation (cf. <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#process(org.apache.kafka.streams.processor.ProcessorSupplier,%20java.lang.String...)"><code>process(ProcessorSupplier, String...)</code></a>).
 <p>
 Peek is a non-terminal operation that triggers a side effect (such as logging or statistics collection)
 and returns an unchanged stream.
 <p>
 Note that since this operation is stateless, it may execute multiple times for a single record in failure cases.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>action</code> - an action to perform on each record</dd><dt><span class="strong">See Also:</span></dt><dd><a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#process(org.apache.kafka.streams.processor.ProcessorSupplier,%20java.lang.String...)"><code>process(ProcessorSupplier, String...)</code></a></dd></dl>
</li>
</ul>
<a name="branch(org.apache.kafka.streams.kstream.Predicate...)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>branch</h4>
<pre><a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="interface in org.apache.kafka.streams.kstream">KStream</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">K</a>,<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">V</a>&gt;[]&nbsp;branch(<a href="../../../../../org/apache/kafka/streams/kstream/Predicate.html" title="interface in org.apache.kafka.streams.kstream">Predicate</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">K</a>,? super <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">V</a>&gt;...&nbsp;predicates)</pre>
<div class="block">Creates an array of <code>KStream</code> from this stream by branching the records in the original stream based on
 the supplied predicates.
 Each record is evaluated against the supplied predicates, and predicates are evaluated in order.
 Each stream in the result array corresponds position-wise (index) to the predicate in the supplied predicates.
 The branching happens on first-match: A record in the original stream is assigned to the corresponding result
 stream for the first predicate that evaluates to true, and is assigned to this stream only.
 A record will be dropped if none of the predicates evaluate to true.
 This is a stateless record-by-record operation.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>predicates</code> - the ordered list of <a href="../../../../../org/apache/kafka/streams/kstream/Predicate.html" title="interface in org.apache.kafka.streams.kstream"><code>Predicate</code></a> instances</dd>
<dt><span class="strong">Returns:</span></dt><dd>multiple distinct substreams of this <code>KStream</code></dd></dl>
</li>
</ul>
<a name="through(java.lang.String)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>through</h4>
<pre><a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="interface in org.apache.kafka.streams.kstream">KStream</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">K</a>,<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">V</a>&gt;&nbsp;through(java.lang.String&nbsp;topic)</pre>
<div class="block">Materialize this stream to a topic and creates a new <code>KStream</code> from the topic using default serializers and
 deserializers and producer's <code>DefaultPartitioner</code>.
 The specified topic should be manually created before it is used (i.e., before the Kafka Streams application is
 started).
 <p>
 This is equivalent to calling <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#to(java.lang.String)"><code>#to(someTopicName)</code></a> and <a href="../../../../../org/apache/kafka/streams/kstream/KStreamBuilder.html#stream(java.lang.String...)"><code>KStreamBuilder#stream(someTopicName)</code></a>.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>topic</code> - the topic name</dd>
<dt><span class="strong">Returns:</span></dt><dd>a <code>KStream</code> that contains the exact same (and potentially repartitioned) records as this <code>KStream</code></dd></dl>
</li>
</ul>
<a name="through(org.apache.kafka.streams.processor.StreamPartitioner, java.lang.String)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>through</h4>
<pre><a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="interface in org.apache.kafka.streams.kstream">KStream</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">K</a>,<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">V</a>&gt;&nbsp;through(<a href="../../../../../org/apache/kafka/streams/processor/StreamPartitioner.html" title="interface in org.apache.kafka.streams.processor">StreamPartitioner</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">K</a>,? super <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">V</a>&gt;&nbsp;partitioner,
                   java.lang.String&nbsp;topic)</pre>
<div class="block">Materialize this stream to a topic and creates a new <code>KStream</code> from the topic using default serializers and
 deserializers and a customizable <a href="../../../../../org/apache/kafka/streams/processor/StreamPartitioner.html" title="interface in org.apache.kafka.streams.processor"><code>StreamPartitioner</code></a> to determine the distribution of records to partitions.
 The specified topic should be manually created before it is used (i.e., before the Kafka Streams application is
 started).
 <p>
 This is equivalent to calling <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#to(org.apache.kafka.streams.processor.StreamPartitioner,%20java.lang.String)"><code>#to(StreamPartitioner, someTopicName)</code></a> and
 <a href="../../../../../org/apache/kafka/streams/kstream/KStreamBuilder.html#stream(java.lang.String...)"><code>KStreamBuilder#stream(someTopicName)</code></a>.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>partitioner</code> - the function used to determine how records are distributed among partitions of the topic,
                    if not specified producer's <code>DefaultPartitioner</code> will be used</dd><dd><code>topic</code> - the topic name</dd>
<dt><span class="strong">Returns:</span></dt><dd>a <code>KStream</code> that contains the exact same (and potentially repartitioned) records as this <code>KStream</code></dd></dl>
</li>
</ul>
<a name="through(org.apache.kafka.common.serialization.Serde, org.apache.kafka.common.serialization.Serde, java.lang.String)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>through</h4>
<pre><a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="interface in org.apache.kafka.streams.kstream">KStream</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">K</a>,<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">V</a>&gt;&nbsp;through(<a href="../../../../../org/apache/kafka/common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization">Serde</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">K</a>&gt;&nbsp;keySerde,
                   <a href="../../../../../org/apache/kafka/common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization">Serde</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">V</a>&gt;&nbsp;valSerde,
                   java.lang.String&nbsp;topic)</pre>
<div class="block">Materialize this stream to a topic, and creates a new <code>KStream</code> from the topic.
 The specified topic should be manually created before it is used (i.e., before the Kafka Streams application is
 started).
 <p>
 If <code>keySerde</code> provides a <code>WindowedSerializer</code> for the key <code>WindowedStreamPartitioner</code> is
 used&mdash;otherwise producer's <code>DefaultPartitioner</code> is used.
 <p>
 This is equivalent to calling <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#to(org.apache.kafka.common.serialization.Serde,%20org.apache.kafka.common.serialization.Serde,%20java.lang.String)"><code>#to(keySerde, valSerde, someTopicName)</code></a> and
 <a href="../../../../../org/apache/kafka/streams/kstream/KStreamBuilder.html#stream(org.apache.kafka.common.serialization.Serde,%20org.apache.kafka.common.serialization.Serde,%20java.lang.String...)"><code>KStreamBuilder#stream(keySerde, valSerde, someTopicName)</code></a>.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>keySerde</code> - key serde used to send key-value pairs,
                 if not specified the default key serde defined in the configuration will be used</dd><dd><code>valSerde</code> - value serde used to send key-value pairs,
                 if not specified the default value serde defined in the configuration will be used</dd><dd><code>topic</code> - the topic name</dd>
<dt><span class="strong">Returns:</span></dt><dd>a <code>KStream</code> that contains the exact same (and potentially repartitioned) records as this <code>KStream</code></dd></dl>
</li>
</ul>
<a name="through(org.apache.kafka.common.serialization.Serde, org.apache.kafka.common.serialization.Serde, org.apache.kafka.streams.processor.StreamPartitioner, java.lang.String)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>through</h4>
<pre><a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="interface in org.apache.kafka.streams.kstream">KStream</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">K</a>,<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">V</a>&gt;&nbsp;through(<a href="../../../../../org/apache/kafka/common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization">Serde</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">K</a>&gt;&nbsp;keySerde,
                   <a href="../../../../../org/apache/kafka/common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization">Serde</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">V</a>&gt;&nbsp;valSerde,
                   <a href="../../../../../org/apache/kafka/streams/processor/StreamPartitioner.html" title="interface in org.apache.kafka.streams.processor">StreamPartitioner</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">K</a>,? super <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">V</a>&gt;&nbsp;partitioner,
                   java.lang.String&nbsp;topic)</pre>
<div class="block">Materialize this stream to a topic and creates a new <code>KStream</code> from the topic using a customizable
 <a href="../../../../../org/apache/kafka/streams/processor/StreamPartitioner.html" title="interface in org.apache.kafka.streams.processor"><code>StreamPartitioner</code></a> to determine the distribution of records to partitions.
 The specified topic should be manually created before it is used (i.e., before the Kafka Streams application is
 started).
 <p>
 This is equivalent to calling <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#to(org.apache.kafka.common.serialization.Serde,%20org.apache.kafka.common.serialization.Serde,%20org.apache.kafka.streams.processor.StreamPartitioner,%20java.lang.String)"><code>#to(keySerde, valSerde,
 StreamPartitioner, someTopicName)</code></a> and <a href="../../../../../org/apache/kafka/streams/kstream/KStreamBuilder.html#stream(org.apache.kafka.common.serialization.Serde,%20org.apache.kafka.common.serialization.Serde,%20java.lang.String...)"><code>KStreamBuilder#stream(keySerde, valSerde, someTopicName)</code></a>.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>keySerde</code> - key serde used to send key-value pairs,
                    if not specified the default key serde defined in the configuration will be used</dd><dd><code>valSerde</code> - value serde used to send key-value pairs,
                    if not specified the default value serde defined in the configuration will be used</dd><dd><code>partitioner</code> - the function used to determine how records are distributed among partitions of the topic,
                    if not specified and <code>keySerde</code> provides a <code>WindowedSerializer</code> for the key
                    <code>WindowedStreamPartitioner</code> will be used&mdash;otherwise <code>DefaultPartitioner</code> will
                    be used</dd><dd><code>topic</code> - the topic name</dd>
<dt><span class="strong">Returns:</span></dt><dd>a <code>KStream</code> that contains the exact same (and potentially repartitioned) records as this <code>KStream</code></dd></dl>
</li>
</ul>
<a name="to(java.lang.String)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>to</h4>
<pre>void&nbsp;to(java.lang.String&nbsp;topic)</pre>
<div class="block">Materialize this stream to a topic using default serializers specified in the config and producer's
 <code>DefaultPartitioner</code>.
 The specified topic should be manually created before it is used (i.e., before the Kafka Streams application is
 started).</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>topic</code> - the topic name</dd></dl>
</li>
</ul>
<a name="to(org.apache.kafka.streams.processor.StreamPartitioner, java.lang.String)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>to</h4>
<pre>void&nbsp;to(<a href="../../../../../org/apache/kafka/streams/processor/StreamPartitioner.html" title="interface in org.apache.kafka.streams.processor">StreamPartitioner</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">K</a>,? super <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">V</a>&gt;&nbsp;partitioner,
      java.lang.String&nbsp;topic)</pre>
<div class="block">Materialize this stream to a topic using default serializers specified in the config and a customizable
 <a href="../../../../../org/apache/kafka/streams/processor/StreamPartitioner.html" title="interface in org.apache.kafka.streams.processor"><code>StreamPartitioner</code></a> to determine the distribution of records to partitions.
 The specified topic should be manually created before it is used (i.e., before the Kafka Streams application is
 started).</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>partitioner</code> - the function used to determine how records are distributed among partitions of the topic,
                    if not specified producer's <code>DefaultPartitioner</code> will be used</dd><dd><code>topic</code> - the topic name</dd></dl>
</li>
</ul>
<a name="to(org.apache.kafka.common.serialization.Serde, org.apache.kafka.common.serialization.Serde, java.lang.String)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>to</h4>
<pre>void&nbsp;to(<a href="../../../../../org/apache/kafka/common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization">Serde</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">K</a>&gt;&nbsp;keySerde,
      <a href="../../../../../org/apache/kafka/common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization">Serde</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">V</a>&gt;&nbsp;valSerde,
      java.lang.String&nbsp;topic)</pre>
<div class="block">Materialize this stream to a topic. If <code>keySerde</code> provides a <code>WindowedSerializer</code>
 for the key <code>WindowedStreamPartitioner</code> is used&mdash;otherwise producer's <code>DefaultPartitioner</code> is
 used.
 The specified topic should be manually created before it is used (i.e., before the Kafka Streams application is
 started).</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>keySerde</code> - key serde used to send key-value pairs,
                 if not specified the default serde defined in the configs will be used</dd><dd><code>valSerde</code> - value serde used to send key-value pairs,
                 if not specified the default serde defined in the configs will be used</dd><dd><code>topic</code> - the topic name</dd></dl>
</li>
</ul>
<a name="to(org.apache.kafka.common.serialization.Serde, org.apache.kafka.common.serialization.Serde, org.apache.kafka.streams.processor.StreamPartitioner, java.lang.String)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>to</h4>
<pre>void&nbsp;to(<a href="../../../../../org/apache/kafka/common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization">Serde</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">K</a>&gt;&nbsp;keySerde,
      <a href="../../../../../org/apache/kafka/common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization">Serde</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">V</a>&gt;&nbsp;valSerde,
      <a href="../../../../../org/apache/kafka/streams/processor/StreamPartitioner.html" title="interface in org.apache.kafka.streams.processor">StreamPartitioner</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">K</a>,? super <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">V</a>&gt;&nbsp;partitioner,
      java.lang.String&nbsp;topic)</pre>
<div class="block">Materialize this stream to a topic using a customizable <a href="../../../../../org/apache/kafka/streams/processor/StreamPartitioner.html" title="interface in org.apache.kafka.streams.processor"><code>StreamPartitioner</code></a> to determine the distribution
 of records to partitions.
 The specified topic should be manually created before it is used (i.e., before the Kafka Streams application is
 started).</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>keySerde</code> - key serde used to send key-value pairs,
                    if not specified the default serde defined in the configs will be used</dd><dd><code>valSerde</code> - value serde used to send key-value pairs,
                    if not specified the default serde defined in the configs will be used</dd><dd><code>partitioner</code> - the function used to determine how records are distributed among partitions of the topic,
                    if not specified and <code>keySerde</code> provides a <code>WindowedSerializer</code> for the key
                    <code>WindowedStreamPartitioner</code> will be used&mdash;otherwise <code>DefaultPartitioner</code> will
                    be used</dd><dd><code>topic</code> - the topic name</dd></dl>
</li>
</ul>
<a name="transform(org.apache.kafka.streams.kstream.TransformerSupplier, java.lang.String...)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>transform</h4>
<pre>&lt;K1,V1&gt;&nbsp;<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="interface in org.apache.kafka.streams.kstream">KStream</a>&lt;K1,V1&gt;&nbsp;transform(<a href="../../../../../org/apache/kafka/streams/kstream/TransformerSupplier.html" title="interface in org.apache.kafka.streams.kstream">TransformerSupplier</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">K</a>,? super <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">V</a>,<a href="../../../../../org/apache/kafka/streams/KeyValue.html" title="class in org.apache.kafka.streams">KeyValue</a>&lt;K1,V1&gt;&gt;&nbsp;transformerSupplier,
                               java.lang.String...&nbsp;stateStoreNames)</pre>
<div class="block">Transform each record of the input stream into zero or more records in the output stream (both key and value type
 can be altered arbitrarily).
 A <a href="../../../../../org/apache/kafka/streams/kstream/Transformer.html" title="interface in org.apache.kafka.streams.kstream"><code>Transformer</code></a> (provided by the given <a href="../../../../../org/apache/kafka/streams/kstream/TransformerSupplier.html" title="interface in org.apache.kafka.streams.kstream"><code>TransformerSupplier</code></a>) is applied to each input record and
 computes zero or more output records.
 Thus, an input record <code>&lt;K,V&gt;</code> can be transformed into output records <code>&lt;K':V'&gt;, &lt;K'':V''&gt;, ...</code>.
 This is a stateful record-by-record operation (cf. <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#flatMap(org.apache.kafka.streams.kstream.KeyValueMapper)"><code>flatMap(KeyValueMapper)</code></a>).
 Furthermore, via <a href="../../../../../org/apache/kafka/streams/kstream/Transformer.html#punctuate(long)"><code>Transformer.punctuate(long)</code></a> the processing progress can be observed and additional
 periodic actions can be performed.
 <p>
 In order to assign a state, the state must be created and registered beforehand:
 <pre class="line-numbers"><code>// create store
 StateStoreSupplier myStore = Stores.create("myTransformState")
     .withKeys(...)
     .withValues(...)
     .persistent() // optional
     .build();

 // register store
 builder.addStore(myStore);

 KStream outputStream = inputStream.transform(new TransformerSupplier() { ... }, "myTransformState");
 </code></pre>
 <p>
 Within the <a href="../../../../../org/apache/kafka/streams/kstream/Transformer.html" title="interface in org.apache.kafka.streams.kstream"><code>Transformer</code></a>, the state is obtained via the
 <a href="../../../../../org/apache/kafka/streams/processor/ProcessorContext.html" title="interface in org.apache.kafka.streams.processor"><code>ProcessorContext</code></a>.
 To trigger periodic actions via <a href="../../../../../org/apache/kafka/streams/kstream/Transformer.html#punctuate(long)"><code>punctuate()</code></a>, a schedule must be registered.
 The <a href="../../../../../org/apache/kafka/streams/kstream/Transformer.html" title="interface in org.apache.kafka.streams.kstream"><code>Transformer</code></a> must return a <a href="../../../../../org/apache/kafka/streams/KeyValue.html" title="class in org.apache.kafka.streams"><code>KeyValue</code></a> type in <a href="../../../../../org/apache/kafka/streams/kstream/Transformer.html#transform(K,%20V)"><code>transform()</code></a> and <a href="../../../../../org/apache/kafka/streams/kstream/Transformer.html#punctuate(long)"><code>punctuate()</code></a>.
 <pre class="line-numbers"><code>new TransformerSupplier() {
     Transformer get() {
         return new Transformer() {
             private ProcessorContext context;
             private StateStore state;

             void init(ProcessorContext context) {
                 this.context = context;
                 this.state = context.getStateStore("myTransformState");
                 context.schedule(1000); // call #punctuate() each 1000ms
             }

             KeyValue transform(K key, V value) {
                 // can access this.state
                 // can emit as many new KeyValue pairs as required via this.context#forward()
                 return new KeyValue(key, value); // can emit a single value via return -- can also be null
             }

             KeyValue punctuate(long timestamp) {
                 // can access this.state
                 // can emit as many new KeyValue pairs as required via this.context#forward()
                 return null; // don't return result -- can also be "new KeyValue()"
             }

             void close() {
                 // can access this.state
                 // can emit as many new KeyValue pairs as required via this.context#forward()
             }
         }
     }
 }
 </code></pre>
 <p>
 Transforming records might result in an internal data redistribution if a key based operator (like an aggregation
 or join) is applied to the result <code>KStream</code>.
 (cf. <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#transformValues(org.apache.kafka.streams.kstream.ValueTransformerSupplier,%20java.lang.String...)"><code>transformValues(ValueTransformerSupplier, String...)</code></a>)</div>
<dl><dt><span class="strong">Type Parameters:</span></dt><dd><code>K1</code> - the key type of the new stream</dd><dd><code>V1</code> - the value type of the new stream</dd><dt><span class="strong">Parameters:</span></dt><dd><code>transformerSupplier</code> - a instance of <a href="../../../../../org/apache/kafka/streams/kstream/TransformerSupplier.html" title="interface in org.apache.kafka.streams.kstream"><code>TransformerSupplier</code></a> that generates a <a href="../../../../../org/apache/kafka/streams/kstream/Transformer.html" title="interface in org.apache.kafka.streams.kstream"><code>Transformer</code></a></dd><dd><code>stateStoreNames</code> - the names of the state stores used by the processor</dd>
<dt><span class="strong">Returns:</span></dt><dd>a <code>KStream</code> that contains more or less records with new key and value (possibly of different type)</dd><dt><span class="strong">See Also:</span></dt><dd><a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#flatMap(org.apache.kafka.streams.kstream.KeyValueMapper)"><code>flatMap(KeyValueMapper)</code></a>, 
<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#transformValues(org.apache.kafka.streams.kstream.ValueTransformerSupplier,%20java.lang.String...)"><code>transformValues(ValueTransformerSupplier, String...)</code></a>, 
<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#process(org.apache.kafka.streams.processor.ProcessorSupplier,%20java.lang.String...)"><code>process(ProcessorSupplier, String...)</code></a></dd></dl>
</li>
</ul>
<a name="transformValues(org.apache.kafka.streams.kstream.ValueTransformerSupplier, java.lang.String...)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>transformValues</h4>
<pre>&lt;VR&gt;&nbsp;<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="interface in org.apache.kafka.streams.kstream">KStream</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">K</a>,VR&gt;&nbsp;transformValues(<a href="../../../../../org/apache/kafka/streams/kstream/ValueTransformerSupplier.html" title="interface in org.apache.kafka.streams.kstream">ValueTransformerSupplier</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">V</a>,? extends VR&gt;&nbsp;valueTransformerSupplier,
                                 java.lang.String...&nbsp;stateStoreNames)</pre>
<div class="block">Transform the value of each input record into a new value (with possible new type) of the output record.
 A <a href="../../../../../org/apache/kafka/streams/kstream/ValueTransformer.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueTransformer</code></a> (provided by the given <a href="../../../../../org/apache/kafka/streams/kstream/ValueTransformerSupplier.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueTransformerSupplier</code></a>) is applies to each input
 record value and computes a new value for it.
 Thus, an input record <code>&lt;K,V&gt;</code> can be transformed into an output record <code>&lt;K:V'&gt;</code>.
 This is a stateful record-by-record operation (cf. <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#mapValues(org.apache.kafka.streams.kstream.ValueMapper)"><code>mapValues(ValueMapper)</code></a>).
 Furthermore, via <a href="../../../../../org/apache/kafka/streams/kstream/ValueTransformer.html#punctuate(long)"><code>ValueTransformer.punctuate(long)</code></a> the processing progress can be observed and additional
 periodic actions get be performed.
 <p>
 In order to assign a state, the state must be created and registered beforehand:
 <pre class="line-numbers"><code>// create store
 StateStoreSupplier myStore = Stores.create("myValueTransformState")
     .withKeys(...)
     .withValues(...)
     .persistent() // optional
     .build();

 // register store
 builder.addStore(myStore);

 KStream outputStream = inputStream.transformValues(new ValueTransformerSupplier() { ... }, "myValueTransformState");
 </code></pre>
 <p>
 Within the <a href="../../../../../org/apache/kafka/streams/kstream/ValueTransformer.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueTransformer</code></a>, the state is obtained via the
 <a href="../../../../../org/apache/kafka/streams/processor/ProcessorContext.html" title="interface in org.apache.kafka.streams.processor"><code>ProcessorContext</code></a>.
 To trigger periodic actions via <a href="../../../../../org/apache/kafka/streams/kstream/ValueTransformer.html#punctuate(long)"><code>punctuate()</code></a>, a schedule must be
 registered.
 In contrast to <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#transform(org.apache.kafka.streams.kstream.TransformerSupplier,%20java.lang.String...)"><code>transform()</code></a>, no additional <a href="../../../../../org/apache/kafka/streams/KeyValue.html" title="class in org.apache.kafka.streams"><code>KeyValue</code></a>
 pairs should be emitted via <a href="../../../../../org/apache/kafka/streams/processor/ProcessorContext.html#forward(K,%20V)"><code>ProcessorContext.forward()</code></a>.
 <pre class="line-numbers"><code>new ValueTransformerSupplier() {
     ValueTransformer get() {
         return new ValueTransformer() {
             private StateStore state;

             void init(ProcessorContext context) {
                 this.state = context.getStateStore("myValueTransformState");
                 context.schedule(1000); // call #punctuate() each 1000ms
             }

             NewValueType transform(V value) {
                 // can access this.state
                 return new NewValueType(); // or null
             }

             NewValueType punctuate(long timestamp) {
                 // can access this.state
                 return null; // don't return result -- can also be "new NewValueType()" (current key will be used to build KeyValue pair)
             }

             void close() {
                 // can access this.state
             }
         }
     }
 }
 </code></pre>
 <p>
 Setting a new value preserves data co-location with respect to the key.
 Thus, <em>no</em> internal data redistribution is required if a key based operator (like an aggregation or join)
 is applied to the result <code>KStream</code>. (cf. <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#transform(org.apache.kafka.streams.kstream.TransformerSupplier,%20java.lang.String...)"><code>transform(TransformerSupplier, String...)</code></a>)</div>
<dl><dt><span class="strong">Type Parameters:</span></dt><dd><code>VR</code> - the value type of the result stream</dd><dt><span class="strong">Parameters:</span></dt><dd><code>valueTransformerSupplier</code> - a instance of <a href="../../../../../org/apache/kafka/streams/kstream/ValueTransformerSupplier.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueTransformerSupplier</code></a> that generates a
                                 <a href="../../../../../org/apache/kafka/streams/kstream/ValueTransformer.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueTransformer</code></a></dd><dd><code>stateStoreNames</code> - the names of the state stores used by the processor</dd>
<dt><span class="strong">Returns:</span></dt><dd>a <code>KStream</code> that contains records with unmodified key and new values (possibly of different type)</dd><dt><span class="strong">See Also:</span></dt><dd><a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#mapValues(org.apache.kafka.streams.kstream.ValueMapper)"><code>mapValues(ValueMapper)</code></a>, 
<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#transform(org.apache.kafka.streams.kstream.TransformerSupplier,%20java.lang.String...)"><code>transform(TransformerSupplier, String...)</code></a></dd></dl>
</li>
</ul>
<a name="process(org.apache.kafka.streams.processor.ProcessorSupplier, java.lang.String...)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>process</h4>
<pre>void&nbsp;process(<a href="../../../../../org/apache/kafka/streams/processor/ProcessorSupplier.html" title="interface in org.apache.kafka.streams.processor">ProcessorSupplier</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">K</a>,? super <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">V</a>&gt;&nbsp;processorSupplier,
           java.lang.String...&nbsp;stateStoreNames)</pre>
<div class="block">Process all records in this stream, one record at a time, by applying a <a href="../../../../../org/apache/kafka/streams/processor/Processor.html" title="interface in org.apache.kafka.streams.processor"><code>Processor</code></a> (provided by the given
 <a href="../../../../../org/apache/kafka/streams/processor/ProcessorSupplier.html" title="interface in org.apache.kafka.streams.processor"><code>ProcessorSupplier</code></a>).
 This is a stateful record-by-record operation (cf. <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#foreach(org.apache.kafka.streams.kstream.ForeachAction)"><code>foreach(ForeachAction)</code></a>).
 Furthermore, via <a href="../../../../../org/apache/kafka/streams/processor/Processor.html#punctuate(long)"><code>Processor.punctuate(long)</code></a> the processing progress can be observed and additional
 periodic actions can be performed.
 Note that this is a terminal operation that returns void.
 <p>
 In order to assign a state, the state must be created and registered beforehand:
 <pre class="line-numbers"><code>// create store
 StateStoreSupplier myStore = Stores.create("myProcessorState")
     .withKeys(...)
     .withValues(...)
     .persistent() // optional
     .build();

 // register store
 builder.addStore(myStore);

 inputStream.process(new ProcessorSupplier() { ... }, "myProcessorState");
 </code></pre>
 <p>
 Within the <a href="../../../../../org/apache/kafka/streams/processor/Processor.html" title="interface in org.apache.kafka.streams.processor"><code>Processor</code></a>, the state is obtained via the
 <a href="../../../../../org/apache/kafka/streams/processor/ProcessorContext.html" title="interface in org.apache.kafka.streams.processor"><code>ProcessorContext</code></a>.
 To trigger periodic actions via <a href="../../../../../org/apache/kafka/streams/processor/Processor.html#punctuate(long)"><code>punctuate()</code></a>,
 a schedule must be registered.
 <pre class="line-numbers"><code>new ProcessorSupplier() {
     Processor get() {
         return new Processor() {
             private StateStore state;

             void init(ProcessorContext context) {
                 this.state = context.getStateStore("myProcessorState");
                 context.schedule(1000); // call #punctuate() each 1000ms
             }

             void process(K key, V value) {
                 // can access this.state
             }

             void punctuate(long timestamp) {
                 // can access this.state
             }

             void close() {
                 // can access this.state
             }
         }
     }
 }
 </code></pre></div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>processorSupplier</code> - a instance of <a href="../../../../../org/apache/kafka/streams/processor/ProcessorSupplier.html" title="interface in org.apache.kafka.streams.processor"><code>ProcessorSupplier</code></a> that generates a <a href="../../../../../org/apache/kafka/streams/processor/Processor.html" title="interface in org.apache.kafka.streams.processor"><code>Processor</code></a></dd><dd><code>stateStoreNames</code> - the names of the state store used by the processor</dd><dt><span class="strong">See Also:</span></dt><dd><a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#foreach(org.apache.kafka.streams.kstream.ForeachAction)"><code>foreach(ForeachAction)</code></a>, 
<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#transform(org.apache.kafka.streams.kstream.TransformerSupplier,%20java.lang.String...)"><code>transform(TransformerSupplier, String...)</code></a></dd></dl>
</li>
</ul>
<a name="groupByKey()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>groupByKey</h4>
<pre><a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html" title="interface in org.apache.kafka.streams.kstream">KGroupedStream</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">K</a>,<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">V</a>&gt;&nbsp;groupByKey()</pre>
<div class="block">Group the records by their current key into a <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html" title="interface in org.apache.kafka.streams.kstream"><code>KGroupedStream</code></a> while preserving the original values
 and default serializers and deserializers.
 Grouping a stream on the record key is required before an aggregation operator can be applied to the data
 (cf. <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html" title="interface in org.apache.kafka.streams.kstream"><code>KGroupedStream</code></a>).
 If a record key is <code>null</code> the record will not be included in the resulting <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html" title="interface in org.apache.kafka.streams.kstream"><code>KGroupedStream</code></a>.
 <p>
 If a key changing operator was used before this operation (e.g., <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#selectKey(org.apache.kafka.streams.kstream.KeyValueMapper)"><code>selectKey(KeyValueMapper)</code></a>,
 <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#map(org.apache.kafka.streams.kstream.KeyValueMapper)"><code>map(KeyValueMapper)</code></a>, <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#flatMap(org.apache.kafka.streams.kstream.KeyValueMapper)"><code>flatMap(KeyValueMapper)</code></a>, or
 <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#transform(org.apache.kafka.streams.kstream.TransformerSupplier,%20java.lang.String...)"><code>transform(TransformerSupplier, String...)</code></a>), and no data redistribution happened afterwards (e.g., via
 <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#through(java.lang.String)"><code>through(String)</code></a>) an internal repartitioning topic will be created in Kafka.
 This topic will be named "${applicationId}-XXX-repartition", where "applicationId" is user-specified in
 <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html" title="class in org.apache.kafka.streams"><code>StreamsConfig</code></a> via parameter <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html#APPLICATION_ID_CONFIG"><code>APPLICATION_ID_CONFIG</code></a>, "XXX" is
 an internally generated name, and "-repartition" is a fixed suffix.
 You can retrieve all generated internal topic names via <a href="../../../../../org/apache/kafka/streams/KafkaStreams.html#toString()"><code>KafkaStreams.toString()</code></a>.
 <p>
 For this case, all data of this stream will be redistributed through the repartitioning topic by writing all
 records to it, and rereading all records from it, such that the resulting <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html" title="interface in org.apache.kafka.streams.kstream"><code>KGroupedStream</code></a> is partitioned
 correctly on its key.
 If the last key changing operator changed the key type, it is recommended to use
 <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#groupByKey(org.apache.kafka.common.serialization.Serde,%20org.apache.kafka.common.serialization.Serde)"><code>groupByKey(Serde, Serde)</code></a> instead.</div>
<dl><dt><span class="strong">Returns:</span></dt><dd>a <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html" title="interface in org.apache.kafka.streams.kstream"><code>KGroupedStream</code></a> that contains the grouped records of the original <code>KStream</code></dd><dt><span class="strong">See Also:</span></dt><dd><a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#groupBy(org.apache.kafka.streams.kstream.KeyValueMapper)"><code>groupBy(KeyValueMapper)</code></a></dd></dl>
</li>
</ul>
<a name="groupByKey(org.apache.kafka.common.serialization.Serde, org.apache.kafka.common.serialization.Serde)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>groupByKey</h4>
<pre><a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html" title="interface in org.apache.kafka.streams.kstream">KGroupedStream</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">K</a>,<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">V</a>&gt;&nbsp;groupByKey(<a href="../../../../../org/apache/kafka/common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization">Serde</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">K</a>&gt;&nbsp;keySerde,
                             <a href="../../../../../org/apache/kafka/common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization">Serde</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">V</a>&gt;&nbsp;valSerde)</pre>
<div class="block">Group the records by their current key into a <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html" title="interface in org.apache.kafka.streams.kstream"><code>KGroupedStream</code></a> while preserving the original values.
 Grouping a stream on the record key is required before an aggregation operator can be applied to the data
 (cf. <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html" title="interface in org.apache.kafka.streams.kstream"><code>KGroupedStream</code></a>).
 If a record key is <code>null</code> the record will not be included in the resulting <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html" title="interface in org.apache.kafka.streams.kstream"><code>KGroupedStream</code></a>.
 <p>
 If a key changing operator was used before this operation (e.g., <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#selectKey(org.apache.kafka.streams.kstream.KeyValueMapper)"><code>selectKey(KeyValueMapper)</code></a>,
 <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#map(org.apache.kafka.streams.kstream.KeyValueMapper)"><code>map(KeyValueMapper)</code></a>, <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#flatMap(org.apache.kafka.streams.kstream.KeyValueMapper)"><code>flatMap(KeyValueMapper)</code></a>, or
 <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#transform(org.apache.kafka.streams.kstream.TransformerSupplier,%20java.lang.String...)"><code>transform(TransformerSupplier, String...)</code></a>), and no data redistribution happened afterwards (e.g., via
 <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#through(java.lang.String)"><code>through(String)</code></a>) an internal repartitioning topic will be created in Kafka.
 This topic will be named "${applicationId}-XXX-repartition", where "applicationId" is user-specified in
 <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html" title="class in org.apache.kafka.streams"><code>StreamsConfig</code></a> via parameter <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html#APPLICATION_ID_CONFIG"><code>APPLICATION_ID_CONFIG</code></a>, "XXX" is
 an internally generated name, and "-repartition" is a fixed suffix.
 You can retrieve all generated internal topic names via <a href="../../../../../org/apache/kafka/streams/KafkaStreams.html#toString()"><code>KafkaStreams.toString()</code></a>.
 <p>
 For this case, all data of this stream will be redistributed through the repartitioning topic by writing all
 records to it, and rereading all records from it, such that the resulting <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html" title="interface in org.apache.kafka.streams.kstream"><code>KGroupedStream</code></a> is partitioned
 correctly on its key.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>keySerde</code> - key serdes for materializing this stream,
                 if not specified the default serdes defined in the configs will be used</dd><dd><code>valSerde</code> - value serdes for materializing this stream,
                 if not specified the default serdes defined in the configs will be used</dd>
<dt><span class="strong">Returns:</span></dt><dd>a <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html" title="interface in org.apache.kafka.streams.kstream"><code>KGroupedStream</code></a> that contains the grouped records of the original <code>KStream</code></dd></dl>
</li>
</ul>
<a name="groupBy(org.apache.kafka.streams.kstream.KeyValueMapper)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>groupBy</h4>
<pre>&lt;KR&gt;&nbsp;<a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html" title="interface in org.apache.kafka.streams.kstream">KGroupedStream</a>&lt;KR,<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">V</a>&gt;&nbsp;groupBy(<a href="../../../../../org/apache/kafka/streams/kstream/KeyValueMapper.html" title="interface in org.apache.kafka.streams.kstream">KeyValueMapper</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">K</a>,? super <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">V</a>,KR&gt;&nbsp;selector)</pre>
<div class="block">Group the records of this <code>KStream</code> on a new key that is selected using the provided <a href="../../../../../org/apache/kafka/streams/kstream/KeyValueMapper.html" title="interface in org.apache.kafka.streams.kstream"><code>KeyValueMapper</code></a>
 and default serializers and deserializers.
 Grouping a stream on the record key is required before an aggregation operator can be applied to the data
 (cf. <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html" title="interface in org.apache.kafka.streams.kstream"><code>KGroupedStream</code></a>).
 The <a href="../../../../../org/apache/kafka/streams/kstream/KeyValueMapper.html" title="interface in org.apache.kafka.streams.kstream"><code>KeyValueMapper</code></a> selects a new key (with should be of the same type) while preserving the original values.
 If the new record key is <code>null</code> the record will not be included in the resulting <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html" title="interface in org.apache.kafka.streams.kstream"><code>KGroupedStream</code></a>
 <p>
 Because a new key is selected, an internal repartitioning topic will be created in Kafka.
 This topic will be named "${applicationId}-XXX-repartition", where "applicationId" is user-specified in
 <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html" title="class in org.apache.kafka.streams"><code>StreamsConfig</code></a> via parameter <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html#APPLICATION_ID_CONFIG"><code>APPLICATION_ID_CONFIG</code></a>, "XXX" is
 an internally generated name, and "-repartition" is a fixed suffix.
 You can retrieve all generated internal topic names via <a href="../../../../../org/apache/kafka/streams/KafkaStreams.html#toString()"><code>KafkaStreams.toString()</code></a>.
 <p>
 All data of this stream will be redistributed through the repartitioning topic by writing all records to it,
 and rereading all records from it, such that the resulting <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html" title="interface in org.apache.kafka.streams.kstream"><code>KGroupedStream</code></a> is partitioned on the new key.
 <p>
 This operation is equivalent to calling <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#selectKey(org.apache.kafka.streams.kstream.KeyValueMapper)"><code>selectKey(KeyValueMapper)</code></a> followed by <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#groupByKey()"><code>groupByKey()</code></a>.
 If the key type is changed, it is recommended to use <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#groupBy(org.apache.kafka.streams.kstream.KeyValueMapper,%20org.apache.kafka.common.serialization.Serde,%20org.apache.kafka.common.serialization.Serde)"><code>groupBy(KeyValueMapper, Serde, Serde)</code></a> instead.</div>
<dl><dt><span class="strong">Type Parameters:</span></dt><dd><code>KR</code> - the key type of the result <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html" title="interface in org.apache.kafka.streams.kstream"><code>KGroupedStream</code></a></dd><dt><span class="strong">Parameters:</span></dt><dd><code>selector</code> - a <a href="../../../../../org/apache/kafka/streams/kstream/KeyValueMapper.html" title="interface in org.apache.kafka.streams.kstream"><code>KeyValueMapper</code></a> that computes a new key for grouping</dd>
<dt><span class="strong">Returns:</span></dt><dd>a <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html" title="interface in org.apache.kafka.streams.kstream"><code>KGroupedStream</code></a> that contains the grouped records of the original <code>KStream</code></dd></dl>
</li>
</ul>
<a name="groupBy(org.apache.kafka.streams.kstream.KeyValueMapper, org.apache.kafka.common.serialization.Serde, org.apache.kafka.common.serialization.Serde)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>groupBy</h4>
<pre>&lt;KR&gt;&nbsp;<a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html" title="interface in org.apache.kafka.streams.kstream">KGroupedStream</a>&lt;KR,<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">V</a>&gt;&nbsp;groupBy(<a href="../../../../../org/apache/kafka/streams/kstream/KeyValueMapper.html" title="interface in org.apache.kafka.streams.kstream">KeyValueMapper</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">K</a>,? super <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">V</a>,KR&gt;&nbsp;selector,
                                <a href="../../../../../org/apache/kafka/common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization">Serde</a>&lt;KR&gt;&nbsp;keySerde,
                                <a href="../../../../../org/apache/kafka/common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization">Serde</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">V</a>&gt;&nbsp;valSerde)</pre>
<div class="block">Group the records of this <code>KStream</code> on a new key that is selected using the provided <a href="../../../../../org/apache/kafka/streams/kstream/KeyValueMapper.html" title="interface in org.apache.kafka.streams.kstream"><code>KeyValueMapper</code></a>.
 Grouping a stream on the record key is required before an aggregation operator can be applied to the data
 (cf. <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html" title="interface in org.apache.kafka.streams.kstream"><code>KGroupedStream</code></a>).
 The <a href="../../../../../org/apache/kafka/streams/kstream/KeyValueMapper.html" title="interface in org.apache.kafka.streams.kstream"><code>KeyValueMapper</code></a> selects a new key (with potentially different type) while preserving the original values.
 If the new record key is <code>null</code> the record will not be included in the resulting <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html" title="interface in org.apache.kafka.streams.kstream"><code>KGroupedStream</code></a>.
 <p>
 Because a new key is selected, an internal repartitioning topic will be created in Kafka.
 This topic will be named "${applicationId}-XXX-repartition", where "applicationId" is user-specified in
 <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html" title="class in org.apache.kafka.streams"><code>StreamsConfig</code></a> via parameter
 <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html#APPLICATION_ID_CONFIG"><code>APPLICATION_ID_CONFIG</code></a>, "XXX" is an internally generated name, and
 "-repartition" is a fixed suffix.
 You can retrieve all generated internal topic names via <a href="../../../../../org/apache/kafka/streams/KafkaStreams.html#toString()"><code>KafkaStreams.toString()</code></a>.
 <p>
 All data of this stream will be redistributed through the repartitioning topic by writing all records to it,
 and rereading all records from it, such that the resulting <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html" title="interface in org.apache.kafka.streams.kstream"><code>KGroupedStream</code></a> is partitioned on the new key.
 <p>
 This is equivalent to calling <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#selectKey(org.apache.kafka.streams.kstream.KeyValueMapper)"><code>selectKey(KeyValueMapper)</code></a> followed by <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#groupByKey(org.apache.kafka.common.serialization.Serde,%20org.apache.kafka.common.serialization.Serde)"><code>groupByKey(Serde, Serde)</code></a>.</div>
<dl><dt><span class="strong">Type Parameters:</span></dt><dd><code>KR</code> - the key type of the result <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html" title="interface in org.apache.kafka.streams.kstream"><code>KGroupedStream</code></a></dd><dt><span class="strong">Parameters:</span></dt><dd><code>selector</code> - a <a href="../../../../../org/apache/kafka/streams/kstream/KeyValueMapper.html" title="interface in org.apache.kafka.streams.kstream"><code>KeyValueMapper</code></a> that computes a new key for grouping</dd><dd><code>keySerde</code> - key serdes for materializing this stream,
                 if not specified the default serdes defined in the configs will be used</dd><dd><code>valSerde</code> - value serdes for materializing this stream,
                 if not specified the default serdes defined in the configs will be used</dd>
<dt><span class="strong">Returns:</span></dt><dd>a <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html" title="interface in org.apache.kafka.streams.kstream"><code>KGroupedStream</code></a> that contains the grouped records of the original <code>KStream</code></dd><dt><span class="strong">See Also:</span></dt><dd><a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#groupByKey()"><code>groupByKey()</code></a></dd></dl>
</li>
</ul>
<a name="join(org.apache.kafka.streams.kstream.KStream, org.apache.kafka.streams.kstream.ValueJoiner, org.apache.kafka.streams.kstream.JoinWindows)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>join</h4>
<pre>&lt;VO,VR&gt;&nbsp;<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="interface in org.apache.kafka.streams.kstream">KStream</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">K</a>,VR&gt;&nbsp;join(<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="interface in org.apache.kafka.streams.kstream">KStream</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">K</a>,VO&gt;&nbsp;otherStream,
                         <a href="../../../../../org/apache/kafka/streams/kstream/ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream">ValueJoiner</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">V</a>,? super VO,? extends VR&gt;&nbsp;joiner,
                         <a href="../../../../../org/apache/kafka/streams/kstream/JoinWindows.html" title="class in org.apache.kafka.streams.kstream">JoinWindows</a>&nbsp;windows)</pre>
<div class="block">Join records of this stream with another <code>KStream</code>'s records using windowed inner equi join with default
 serializers and deserializers.
 The join is computed on the records' key with join attribute <code>thisKStream.key == otherKStream.key</code>.
 Furthermore, two records are only joined if their timestamps are close to each other as defined by the given
 <a href="../../../../../org/apache/kafka/streams/kstream/JoinWindows.html" title="class in org.apache.kafka.streams.kstream"><code>JoinWindows</code></a>, i.e., the window defines an additional join predicate on the record timestamps.
 <p>
 For each pair of records meeting both join predicates the provided <a href="../../../../../org/apache/kafka/streams/kstream/ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueJoiner</code></a> will be called to compute
 a value (with arbitrary type) for the result record.
 The key of the result record is the same as for both joining input records.
 If an input record key or value is <code>null</code> the record will not be included in the join operation and thus no
 output record will be added to the resulting <code>KStream</code>.
 <p>
 Example (assuming all input records belong to the correct windows):
 <table border='1'>
 <tr>
 <th>this</th>
 <th>other</th>
 <th>result</th>
 </tr>
 <tr>
 <td>&lt;K1:A&gt;</td>
 <td></td>
 <td></td>
 </tr>
 <tr>
 <td>&lt;K2:B&gt;</td>
 <td>&lt;K2:b&gt;</td>
 <td>&lt;K2:ValueJoiner(B,b)&gt;</td>
 </tr>
 <tr>
 <td></td>
 <td>&lt;K3:c&gt;</td>
 <td></td>
 </tr>
 </table>
 Both input streams (or to be more precise, their underlying source topics) need to have the same number of
 partitions.
 If this is not the case, you would need to call <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#through(java.lang.String)"><code>through(String)</code></a> (for one input stream) before doing the
 join, using a pre-created topic with the "correct" number of partitions.
 Furthermore, both input streams need to be co-partitioned on the join key (i.e., use the same partitioner).
 If this requirement is not met, Kafka Streams will automatically repartition the data, i.e., it will create an
 internal repartitioning topic in Kafka and write and re-read the data via this topic before the actual join.
 The repartitioning topic will be named "${applicationId}-XXX-repartition", where "applicationId" is
 user-specified in <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html" title="class in org.apache.kafka.streams"><code>StreamsConfig</code></a> via parameter
 <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html#APPLICATION_ID_CONFIG"><code>APPLICATION_ID_CONFIG</code></a>, "XXX" is an internally generated name, and
 "-repartition" is a fixed suffix.
 You can retrieve all generated internal topic names via <a href="../../../../../org/apache/kafka/streams/KafkaStreams.html#toString()"><code>KafkaStreams.toString()</code></a>.
 <p>
 Repartitioning can happen for one or both of the joining <code>KStream</code>s.
 For this case, all data of the stream will be redistributed through the repartitioning topic by writing all
 records to it, and rereading all records from it, such that the join input <code>KStream</code> is partitioned
 correctly on its key.
 <p>
 Both of the joining <code>KStream</code>s will be materialized in local state stores with auto-generated store names.
 For failure and recovery each store will be backed by an internal changelog topic that will be created in Kafka.
 The changelog topic will be named "${applicationId}-storeName-changelog", where "applicationId" is user-specified
 in <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html" title="class in org.apache.kafka.streams"><code>StreamsConfig</code></a> via parameter
 <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html#APPLICATION_ID_CONFIG"><code>APPLICATION_ID_CONFIG</code></a>, "storeName" is an
 internally generated name, and "-changelog" is a fixed suffix.
 You can retrieve all generated internal topic names via <a href="../../../../../org/apache/kafka/streams/KafkaStreams.html#toString()"><code>KafkaStreams.toString()</code></a>.</div>
<dl><dt><span class="strong">Type Parameters:</span></dt><dd><code>VO</code> - the value type of the other stream</dd><dd><code>VR</code> - the value type of the result stream</dd><dt><span class="strong">Parameters:</span></dt><dd><code>otherStream</code> - the <code>KStream</code> to be joined with this stream</dd><dd><code>joiner</code> - a <a href="../../../../../org/apache/kafka/streams/kstream/ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueJoiner</code></a> that computes the join result for a pair of matching records</dd><dd><code>windows</code> - the specification of the <a href="../../../../../org/apache/kafka/streams/kstream/JoinWindows.html" title="class in org.apache.kafka.streams.kstream"><code>JoinWindows</code></a></dd>
<dt><span class="strong">Returns:</span></dt><dd>a <code>KStream</code> that contains join-records for each key and values computed by the given
 <a href="../../../../../org/apache/kafka/streams/kstream/ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueJoiner</code></a>, one for each matched record-pair with the same key and within the joining window intervals</dd><dt><span class="strong">See Also:</span></dt><dd><a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#leftJoin(org.apache.kafka.streams.kstream.KStream,%20org.apache.kafka.streams.kstream.ValueJoiner,%20org.apache.kafka.streams.kstream.JoinWindows)"><code>leftJoin(KStream, ValueJoiner, JoinWindows)</code></a>, 
<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#outerJoin(org.apache.kafka.streams.kstream.KStream,%20org.apache.kafka.streams.kstream.ValueJoiner,%20org.apache.kafka.streams.kstream.JoinWindows)"><code>outerJoin(KStream, ValueJoiner, JoinWindows)</code></a></dd></dl>
</li>
</ul>
<a name="join(org.apache.kafka.streams.kstream.KStream, org.apache.kafka.streams.kstream.ValueJoiner, org.apache.kafka.streams.kstream.JoinWindows, org.apache.kafka.common.serialization.Serde, org.apache.kafka.common.serialization.Serde, org.apache.kafka.common.serialization.Serde)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>join</h4>
<pre>&lt;VO,VR&gt;&nbsp;<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="interface in org.apache.kafka.streams.kstream">KStream</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">K</a>,VR&gt;&nbsp;join(<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="interface in org.apache.kafka.streams.kstream">KStream</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">K</a>,VO&gt;&nbsp;otherStream,
                         <a href="../../../../../org/apache/kafka/streams/kstream/ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream">ValueJoiner</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">V</a>,? super VO,? extends VR&gt;&nbsp;joiner,
                         <a href="../../../../../org/apache/kafka/streams/kstream/JoinWindows.html" title="class in org.apache.kafka.streams.kstream">JoinWindows</a>&nbsp;windows,
                         <a href="../../../../../org/apache/kafka/common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization">Serde</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">K</a>&gt;&nbsp;keySerde,
                         <a href="../../../../../org/apache/kafka/common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization">Serde</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">V</a>&gt;&nbsp;thisValueSerde,
                         <a href="../../../../../org/apache/kafka/common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization">Serde</a>&lt;VO&gt;&nbsp;otherValueSerde)</pre>
<div class="block">Join records of this stream with another <code>KStream</code>'s records using windowed inner equi join.
 The join is computed on the records' key with join attribute <code>thisKStream.key == otherKStream.key</code>.
 Furthermore, two records are only joined if their timestamps are close to each other as defined by the given
 <a href="../../../../../org/apache/kafka/streams/kstream/JoinWindows.html" title="class in org.apache.kafka.streams.kstream"><code>JoinWindows</code></a>, i.e., the window defines an additional join predicate on the record timestamps.
 <p>
 For each pair of records meeting both join predicates the provided <a href="../../../../../org/apache/kafka/streams/kstream/ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueJoiner</code></a> will be called to compute
 a value (with arbitrary type) for the result record.
 The key of the result record is the same as for both joining input records.
 If an input record key or value is <code>null</code> the record will not be included in the join operation and thus no
 output record will be added to the resulting <code>KStream</code>.
 <p>
 Example (assuming all input records belong to the correct windows):
 <table border='1'>
 <tr>
 <th>this</th>
 <th>other</th>
 <th>result</th>
 </tr>
 <tr>
 <td>&lt;K1:A&gt;</td>
 <td></td>
 <td></td>
 </tr>
 <tr>
 <td>&lt;K2:B&gt;</td>
 <td>&lt;K2:b&gt;</td>
 <td>&lt;K2:ValueJoiner(B,b)&gt;</td>
 </tr>
 <tr>
 <td></td>
 <td>&lt;K3:c&gt;</td>
 <td></td>
 </tr>
 </table>
 Both input streams (or to be more precise, their underlying source topics) need to have the same number of
 partitions.
 If this is not the case, you would need to call <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#through(java.lang.String)"><code>through(String)</code></a> (for one input stream) before doing the
 join, using a pre-created topic with the "correct" number of partitions.
 Furthermore, both input streams need to be co-partitioned on the join key (i.e., use the same partitioner).
 If this requirement is not met, Kafka Streams will automatically repartition the data, i.e., it will create an
 internal repartitioning topic in Kafka and write and re-read the data via this topic before the actual join.
 The repartitioning topic will be named "${applicationId}-XXX-repartition", where "applicationId" is
 user-specified in <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html" title="class in org.apache.kafka.streams"><code>StreamsConfig</code></a> via parameter
 <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html#APPLICATION_ID_CONFIG"><code>APPLICATION_ID_CONFIG</code></a>, "XXX" is an internally generated name, and
 "-repartition" is a fixed suffix.
 You can retrieve all generated internal topic names via <a href="../../../../../org/apache/kafka/streams/KafkaStreams.html#toString()"><code>KafkaStreams.toString()</code></a>.
 <p>
 Repartitioning can happen for one or both of the joining <code>KStream</code>s.
 For this case, all data of the stream will be redistributed through the repartitioning topic by writing all
 records to it, and rereading all records from it, such that the join input <code>KStream</code> is partitioned
 correctly on its key.
 <p>
 Both of the joining <code>KStream</code>s will be materialized in local state stores with auto-generated store names.
 For failure and recovery each store will be backed by an internal changelog topic that will be created in Kafka.
 The changelog topic will be named "${applicationId}-storeName-changelog", where "applicationId" is user-specified
 in <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html" title="class in org.apache.kafka.streams"><code>StreamsConfig</code></a> via parameter <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html#APPLICATION_ID_CONFIG"><code>APPLICATION_ID_CONFIG</code></a>,
 "storeName" is an internally generated name, and "-changelog" is a fixed suffix.
 You can retrieve all generated internal topic names via <a href="../../../../../org/apache/kafka/streams/KafkaStreams.html#toString()"><code>KafkaStreams.toString()</code></a>.</div>
<dl><dt><span class="strong">Type Parameters:</span></dt><dd><code>VO</code> - the value type of the other stream</dd><dd><code>VR</code> - the value type of the result stream</dd><dt><span class="strong">Parameters:</span></dt><dd><code>otherStream</code> - the <code>KStream</code> to be joined with this stream</dd><dd><code>joiner</code> - a <a href="../../../../../org/apache/kafka/streams/kstream/ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueJoiner</code></a> that computes the join result for a pair of matching records</dd><dd><code>windows</code> - the specification of the <a href="../../../../../org/apache/kafka/streams/kstream/JoinWindows.html" title="class in org.apache.kafka.streams.kstream"><code>JoinWindows</code></a></dd><dd><code>keySerde</code> - key serdes for materializing both streams,
                        if not specified the default serdes defined in the configs will be used</dd><dd><code>thisValueSerde</code> - value serdes for materializing this stream,
                        if not specified the default serdes defined in the configs will be used</dd><dd><code>otherValueSerde</code> - value serdes for materializing the other stream,
                        if not specified the default serdes defined in the configs will be used</dd>
<dt><span class="strong">Returns:</span></dt><dd>a <code>KStream</code> that contains join-records for each key and values computed by the given
 <a href="../../../../../org/apache/kafka/streams/kstream/ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueJoiner</code></a>, one for each matched record-pair with the same key and within the joining window intervals</dd><dt><span class="strong">See Also:</span></dt><dd><a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#leftJoin(org.apache.kafka.streams.kstream.KStream,%20org.apache.kafka.streams.kstream.ValueJoiner,%20org.apache.kafka.streams.kstream.JoinWindows,%20org.apache.kafka.common.serialization.Serde,%20org.apache.kafka.common.serialization.Serde,%20org.apache.kafka.common.serialization.Serde)"><code>leftJoin(KStream, ValueJoiner, JoinWindows, Serde, Serde, Serde)</code></a>, 
<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#outerJoin(org.apache.kafka.streams.kstream.KStream,%20org.apache.kafka.streams.kstream.ValueJoiner,%20org.apache.kafka.streams.kstream.JoinWindows,%20org.apache.kafka.common.serialization.Serde,%20org.apache.kafka.common.serialization.Serde,%20org.apache.kafka.common.serialization.Serde)"><code>outerJoin(KStream, ValueJoiner, JoinWindows, Serde, Serde, Serde)</code></a></dd></dl>
</li>
</ul>
<a name="leftJoin(org.apache.kafka.streams.kstream.KStream, org.apache.kafka.streams.kstream.ValueJoiner, org.apache.kafka.streams.kstream.JoinWindows)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>leftJoin</h4>
<pre>&lt;VO,VR&gt;&nbsp;<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="interface in org.apache.kafka.streams.kstream">KStream</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">K</a>,VR&gt;&nbsp;leftJoin(<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="interface in org.apache.kafka.streams.kstream">KStream</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">K</a>,VO&gt;&nbsp;otherStream,
                             <a href="../../../../../org/apache/kafka/streams/kstream/ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream">ValueJoiner</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">V</a>,? super VO,? extends VR&gt;&nbsp;joiner,
                             <a href="../../../../../org/apache/kafka/streams/kstream/JoinWindows.html" title="class in org.apache.kafka.streams.kstream">JoinWindows</a>&nbsp;windows)</pre>
<div class="block">Join records of this stream with another <code>KStream</code>'s records using windowed left equi join with default
 serializers and deserializers.
 In contrast to <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#join(org.apache.kafka.streams.kstream.KStream,%20org.apache.kafka.streams.kstream.ValueJoiner,%20org.apache.kafka.streams.kstream.JoinWindows)"><code>inner-join</code></a>, all records from this stream will
 produce at least one output record (cf. below).
 The join is computed on the records' key with join attribute <code>thisKStream.key == otherKStream.key</code>.
 Furthermore, two records are only joined if their timestamps are close to each other as defined by the given
 <a href="../../../../../org/apache/kafka/streams/kstream/JoinWindows.html" title="class in org.apache.kafka.streams.kstream"><code>JoinWindows</code></a>, i.e., the window defines an additional join predicate on the record timestamps.
 <p>
 For each pair of records meeting both join predicates the provided <a href="../../../../../org/apache/kafka/streams/kstream/ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueJoiner</code></a> will be called to compute
 a value (with arbitrary type) for the result record.
 The key of the result record is the same as for both joining input records.
 Furthermore, for each input record of this <code>KStream</code> that does not satisfy the join predicate the provided
 <a href="../../../../../org/apache/kafka/streams/kstream/ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueJoiner</code></a> will be called with a <code>null</code> value for the other stream.
 If an input record key or value is <code>null</code> the record will not be included in the join operation and thus no
 output record will be added to the resulting <code>KStream</code>.
 <p>
 Example (assuming all input records belong to the correct windows):
 <table border='1'>
 <tr>
 <th>this</th>
 <th>other</th>
 <th>result</th>
 </tr>
 <tr>
 <td>&lt;K1:A&gt;</td>
 <td></td>
 <td>&lt;K1:ValueJoiner(A,null)&gt;</td>
 </tr>
 <tr>
 <td>&lt;K2:B&gt;</td>
 <td>&lt;K2:b&gt;</td>
 <td>&lt;K2:ValueJoiner(B,b)&gt;</td>
 </tr>
 <tr>
 <td></td>
 <td>&lt;K3:c&gt;</td>
 <td></td>
 </tr>
 </table>
 Both input streams (or to be more precise, their underlying source topics) need to have the same number of
 partitions.
 If this is not the case, you would need to call <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#through(java.lang.String)"><code>through(String)</code></a> (for one input stream) before doing the
 join, using a pre-created topic with the "correct" number of partitions.
 Furthermore, both input streams need to be co-partitioned on the join key (i.e., use the same partitioner).
 If this requirement is not met, Kafka Streams will automatically repartition the data, i.e., it will create an
 internal repartitioning topic in Kafka and write and re-read the data via this topic before the actual join.
 The repartitioning topic will be named "${applicationId}-XXX-repartition", where "applicationId" is
 user-specified in <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html" title="class in org.apache.kafka.streams"><code>StreamsConfig</code></a> via parameter
 <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html#APPLICATION_ID_CONFIG"><code>APPLICATION_ID_CONFIG</code></a>, "XXX" is an internally generated name, and
 "-repartition" is a fixed suffix.
 You can retrieve all generated internal topic names via <a href="../../../../../org/apache/kafka/streams/KafkaStreams.html#toString()"><code>KafkaStreams.toString()</code></a>.
 <p>
 Repartitioning can happen for one or both of the joining <code>KStream</code>s.
 For this case, all data of the stream will be redistributed through the repartitioning topic by writing all
 records to it, and rereading all records from it, such that the join input <code>KStream</code> is partitioned
 correctly on its key.
 <p>
 Both of the joining <code>KStream</code>s will be materialized in local state stores with auto-generated store names.
 For failure and recovery each store will be backed by an internal changelog topic that will be created in Kafka.
 The changelog topic will be named "${applicationId}-storeName-changelog", where "applicationId" is user-specified
 in <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html" title="class in org.apache.kafka.streams"><code>StreamsConfig</code></a> via parameter <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html#APPLICATION_ID_CONFIG"><code>APPLICATION_ID_CONFIG</code></a>,
 "storeName" is an internally generated name, and "-changelog" is a fixed suffix.
 You can retrieve all generated internal topic names via <a href="../../../../../org/apache/kafka/streams/KafkaStreams.html#toString()"><code>KafkaStreams.toString()</code></a>.</div>
<dl><dt><span class="strong">Type Parameters:</span></dt><dd><code>VO</code> - the value type of the other stream</dd><dd><code>VR</code> - the value type of the result stream</dd><dt><span class="strong">Parameters:</span></dt><dd><code>otherStream</code> - the <code>KStream</code> to be joined with this stream</dd><dd><code>joiner</code> - a <a href="../../../../../org/apache/kafka/streams/kstream/ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueJoiner</code></a> that computes the join result for a pair of matching records</dd><dd><code>windows</code> - the specification of the <a href="../../../../../org/apache/kafka/streams/kstream/JoinWindows.html" title="class in org.apache.kafka.streams.kstream"><code>JoinWindows</code></a></dd>
<dt><span class="strong">Returns:</span></dt><dd>a <code>KStream</code> that contains join-records for each key and values computed by the given
 <a href="../../../../../org/apache/kafka/streams/kstream/ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueJoiner</code></a>, one for each matched record-pair with the same key plus one for each non-matching record of
 this <code>KStream</code> and within the joining window intervals</dd><dt><span class="strong">See Also:</span></dt><dd><a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#join(org.apache.kafka.streams.kstream.KStream,%20org.apache.kafka.streams.kstream.ValueJoiner,%20org.apache.kafka.streams.kstream.JoinWindows)"><code>join(KStream, ValueJoiner, JoinWindows)</code></a>, 
<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#outerJoin(org.apache.kafka.streams.kstream.KStream,%20org.apache.kafka.streams.kstream.ValueJoiner,%20org.apache.kafka.streams.kstream.JoinWindows)"><code>outerJoin(KStream, ValueJoiner, JoinWindows)</code></a></dd></dl>
</li>
</ul>
<a name="leftJoin(org.apache.kafka.streams.kstream.KStream, org.apache.kafka.streams.kstream.ValueJoiner, org.apache.kafka.streams.kstream.JoinWindows, org.apache.kafka.common.serialization.Serde, org.apache.kafka.common.serialization.Serde, org.apache.kafka.common.serialization.Serde)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>leftJoin</h4>
<pre>&lt;VO,VR&gt;&nbsp;<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="interface in org.apache.kafka.streams.kstream">KStream</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">K</a>,VR&gt;&nbsp;leftJoin(<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="interface in org.apache.kafka.streams.kstream">KStream</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">K</a>,VO&gt;&nbsp;otherStream,
                             <a href="../../../../../org/apache/kafka/streams/kstream/ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream">ValueJoiner</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">V</a>,? super VO,? extends VR&gt;&nbsp;joiner,
                             <a href="../../../../../org/apache/kafka/streams/kstream/JoinWindows.html" title="class in org.apache.kafka.streams.kstream">JoinWindows</a>&nbsp;windows,
                             <a href="../../../../../org/apache/kafka/common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization">Serde</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">K</a>&gt;&nbsp;keySerde,
                             <a href="../../../../../org/apache/kafka/common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization">Serde</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">V</a>&gt;&nbsp;thisValSerde,
                             <a href="../../../../../org/apache/kafka/common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization">Serde</a>&lt;VO&gt;&nbsp;otherValueSerde)</pre>
<div class="block">Join records of this stream with another <code>KStream</code>'s records using windowed left equi join.
 In contrast to <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#join(org.apache.kafka.streams.kstream.KStream,%20org.apache.kafka.streams.kstream.ValueJoiner,%20org.apache.kafka.streams.kstream.JoinWindows,%20org.apache.kafka.common.serialization.Serde,%20org.apache.kafka.common.serialization.Serde,%20org.apache.kafka.common.serialization.Serde)"><code>inner-join</code></a>, all records from
 this stream will produce at least one output record (cf. below).
 The join is computed on the records' key with join attribute <code>thisKStream.key == otherKStream.key</code>.
 Furthermore, two records are only joined if their timestamps are close to each other as defined by the given
 <a href="../../../../../org/apache/kafka/streams/kstream/JoinWindows.html" title="class in org.apache.kafka.streams.kstream"><code>JoinWindows</code></a>, i.e., the window defines an additional join predicate on the record timestamps.
 <p>
 For each pair of records meeting both join predicates the provided <a href="../../../../../org/apache/kafka/streams/kstream/ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueJoiner</code></a> will be called to compute
 a value (with arbitrary type) for the result record.
 The key of the result record is the same as for both joining input records.
 Furthermore, for each input record of this <code>KStream</code> that does not satisfy the join predicate the provided
 <a href="../../../../../org/apache/kafka/streams/kstream/ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueJoiner</code></a> will be called with a <code>null</code> value for the other stream.
 If an input record key or value is <code>null</code> the record will not be included in the join operation and thus no
 output record will be added to the resulting <code>KStream</code>.
 <p>
 Example (assuming all input records belong to the correct windows):
 <table border='1'>
 <tr>
 <th>this</th>
 <th>other</th>
 <th>result</th>
 </tr>
 <tr>
 <td>&lt;K1:A&gt;</td>
 <td></td>
 <td>&lt;K1:ValueJoiner(A,null)&gt;</td>
 </tr>
 <tr>
 <td>&lt;K2:B&gt;</td>
 <td>&lt;K2:b&gt;</td>
 <td>&lt;K2:ValueJoiner(B,b)&gt;</td>
 </tr>
 <tr>
 <td></td>
 <td>&lt;K3:c&gt;</td>
 <td></td>
 </tr>
 </table>
 Both input streams (or to be more precise, their underlying source topics) need to have the same number of
 partitions.
 If this is not the case, you would need to call <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#through(java.lang.String)"><code>through(String)</code></a> (for one input stream) before doing the
 join, using a pre-created topic with the "correct" number of partitions.
 Furthermore, both input streams need to be co-partitioned on the join key (i.e., use the same partitioner).
 If this requirement is not met, Kafka Streams will automatically repartition the data, i.e., it will create an
 internal repartitioning topic in Kafka and write and re-read the data via this topic before the actual join.
 The repartitioning topic will be named "${applicationId}-XXX-repartition", where "applicationId" is
 user-specified in <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html" title="class in org.apache.kafka.streams"><code>StreamsConfig</code></a> via parameter
 <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html#APPLICATION_ID_CONFIG"><code>APPLICATION_ID_CONFIG</code></a>, "XXX" is an internally generated name, and
 "-repartition" is a fixed suffix.
 You can retrieve all generated internal topic names via <a href="../../../../../org/apache/kafka/streams/KafkaStreams.html#toString()"><code>KafkaStreams.toString()</code></a>.
 <p>
 Repartitioning can happen for one or both of the joining <code>KStream</code>s.
 For this case, all data of the stream will be redistributed through the repartitioning topic by writing all
 records to it, and rereading all records from it, such that the join input <code>KStream</code> is partitioned
 correctly on its key.
 <p>
 Both of the joining <code>KStream</code>s will be materialized in local state stores with auto-generated store names.
 For failure and recovery each store will be backed by an internal changelog topic that will be created in Kafka.
 The changelog topic will be named "${applicationId}-storeName-changelog", where "applicationId" is user-specified
 in <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html" title="class in org.apache.kafka.streams"><code>StreamsConfig</code></a> via parameter
 <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html#APPLICATION_ID_CONFIG"><code>APPLICATION_ID_CONFIG</code></a>, "storeName" is an
 internally generated name, and "-changelog" is a fixed suffix.
 You can retrieve all generated internal topic names via <a href="../../../../../org/apache/kafka/streams/KafkaStreams.html#toString()"><code>KafkaStreams.toString()</code></a>.</div>
<dl><dt><span class="strong">Type Parameters:</span></dt><dd><code>VO</code> - the value type of the other stream</dd><dd><code>VR</code> - the value type of the result stream</dd><dt><span class="strong">Parameters:</span></dt><dd><code>otherStream</code> - the <code>KStream</code> to be joined with this stream</dd><dd><code>joiner</code> - a <a href="../../../../../org/apache/kafka/streams/kstream/ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueJoiner</code></a> that computes the join result for a pair of matching records</dd><dd><code>windows</code> - the specification of the <a href="../../../../../org/apache/kafka/streams/kstream/JoinWindows.html" title="class in org.apache.kafka.streams.kstream"><code>JoinWindows</code></a></dd><dd><code>keySerde</code> - key serdes for materializing the other stream,
                        if not specified the default serdes defined in the configs will be used</dd><dd><code>thisValSerde</code> - value serdes for materializing this stream,
                        if not specified the default serdes defined in the configs will be used</dd><dd><code>otherValueSerde</code> - value serdes for materializing the other stream,
                        if not specified the default serdes defined in the configs will be used</dd>
<dt><span class="strong">Returns:</span></dt><dd>a <code>KStream</code> that contains join-records for each key and values computed by the given
 <a href="../../../../../org/apache/kafka/streams/kstream/ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueJoiner</code></a>, one for each matched record-pair with the same key plus one for each non-matching record of
 this <code>KStream</code> and within the joining window intervals</dd><dt><span class="strong">See Also:</span></dt><dd><a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#join(org.apache.kafka.streams.kstream.KStream,%20org.apache.kafka.streams.kstream.ValueJoiner,%20org.apache.kafka.streams.kstream.JoinWindows,%20org.apache.kafka.common.serialization.Serde,%20org.apache.kafka.common.serialization.Serde,%20org.apache.kafka.common.serialization.Serde)"><code>join(KStream, ValueJoiner, JoinWindows, Serde, Serde, Serde)</code></a>, 
<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#outerJoin(org.apache.kafka.streams.kstream.KStream,%20org.apache.kafka.streams.kstream.ValueJoiner,%20org.apache.kafka.streams.kstream.JoinWindows,%20org.apache.kafka.common.serialization.Serde,%20org.apache.kafka.common.serialization.Serde,%20org.apache.kafka.common.serialization.Serde)"><code>outerJoin(KStream, ValueJoiner, JoinWindows, Serde, Serde, Serde)</code></a></dd></dl>
</li>
</ul>
<a name="outerJoin(org.apache.kafka.streams.kstream.KStream, org.apache.kafka.streams.kstream.ValueJoiner, org.apache.kafka.streams.kstream.JoinWindows)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>outerJoin</h4>
<pre>&lt;VO,VR&gt;&nbsp;<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="interface in org.apache.kafka.streams.kstream">KStream</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">K</a>,VR&gt;&nbsp;outerJoin(<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="interface in org.apache.kafka.streams.kstream">KStream</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">K</a>,VO&gt;&nbsp;otherStream,
                              <a href="../../../../../org/apache/kafka/streams/kstream/ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream">ValueJoiner</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">V</a>,? super VO,? extends VR&gt;&nbsp;joiner,
                              <a href="../../../../../org/apache/kafka/streams/kstream/JoinWindows.html" title="class in org.apache.kafka.streams.kstream">JoinWindows</a>&nbsp;windows)</pre>
<div class="block">Join records of this stream with another <code>KStream</code>'s records using windowed left equi join with default
 serializers and deserializers.
 In contrast to <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#join(org.apache.kafka.streams.kstream.KStream,%20org.apache.kafka.streams.kstream.ValueJoiner,%20org.apache.kafka.streams.kstream.JoinWindows)"><code>inner-join</code></a> or
 <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#leftJoin(org.apache.kafka.streams.kstream.KStream,%20org.apache.kafka.streams.kstream.ValueJoiner,%20org.apache.kafka.streams.kstream.JoinWindows)"><code>left-join</code></a>, all records from both streams will produce at
 least one output record (cf. below).
 The join is computed on the records' key with join attribute <code>thisKStream.key == otherKStream.key</code>.
 Furthermore, two records are only joined if their timestamps are close to each other as defined by the given
 <a href="../../../../../org/apache/kafka/streams/kstream/JoinWindows.html" title="class in org.apache.kafka.streams.kstream"><code>JoinWindows</code></a>, i.e., the window defines an additional join predicate on the record timestamps.
 <p>
 For each pair of records meeting both join predicates the provided <a href="../../../../../org/apache/kafka/streams/kstream/ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueJoiner</code></a> will be called to compute
 a value (with arbitrary type) for the result record.
 The key of the result record is the same as for both joining input records.
 Furthermore, for each input record of both <code>KStream</code>s that does not satisfy the join predicate the provided
 <a href="../../../../../org/apache/kafka/streams/kstream/ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueJoiner</code></a> will be called with a <code>null</code> value for the this/other stream, respectively.
 If an input record key or value is <code>null</code> the record will not be included in the join operation and thus no
 output record will be added to the resulting <code>KStream</code>.
 <p>
 Example (assuming all input records belong to the correct windows):
 <table border='1'>
 <tr>
 <th>this</th>
 <th>other</th>
 <th>result</th>
 </tr>
 <tr>
 <td>&lt;K1:A&gt;</td>
 <td></td>
 <td>&lt;K1:ValueJoiner(A,null)&gt;</td>
 </tr>
 <tr>
 <td>&lt;K2:B&gt;</td>
 <td>&lt;K2:b&gt;</td>
 <td>&lt;K2:ValueJoiner(null,b)&gt;<br />&lt;K2:ValueJoiner(B,b)&gt;</td>
 </tr>
 <tr>
 <td></td>
 <td>&lt;K3:c&gt;</td>
 <td>&lt;K3:ValueJoiner(null,c)&gt;</td>
 </tr>
 </table>
 Both input streams (or to be more precise, their underlying source topics) need to have the same number of
 partitions.
 If this is not the case, you would need to call <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#through(java.lang.String)"><code>through(String)</code></a> (for one input stream) before doing the
 join, using a pre-created topic with the "correct" number of partitions.
 Furthermore, both input streams need to be co-partitioned on the join key (i.e., use the same partitioner).
 If this requirement is not met, Kafka Streams will automatically repartition the data, i.e., it will create an
 internal repartitioning topic in Kafka and write and re-read the data via this topic before the actual join.
 The repartitioning topic will be named "${applicationId}-XXX-repartition", where "applicationId" is
 user-specified in <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html" title="class in org.apache.kafka.streams"><code>StreamsConfig</code></a> via parameter
 <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html#APPLICATION_ID_CONFIG"><code>APPLICATION_ID_CONFIG</code></a>, "XXX" is an internally generated name, and
 "-repartition" is a fixed suffix.
 You can retrieve all generated internal topic names via <a href="../../../../../org/apache/kafka/streams/KafkaStreams.html#toString()"><code>KafkaStreams.toString()</code></a>.
 <p>
 Repartitioning can happen for one or both of the joining <code>KStream</code>s.
 For this case, all data of the stream will be redistributed through the repartitioning topic by writing all
 records to it, and rereading all records from it, such that the join input <code>KStream</code> is partitioned
 correctly on its key.
 <p>
 Both of the joining <code>KStream</code>s will be materialized in local state stores with auto-generated store names.
 For failure and recovery each store will be backed by an internal changelog topic that will be created in Kafka.
 The changelog topic will be named "${applicationId}-storeName-changelog", where "applicationId" is user-specified
 in <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html" title="class in org.apache.kafka.streams"><code>StreamsConfig</code></a> via parameter <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html#APPLICATION_ID_CONFIG"><code>APPLICATION_ID_CONFIG</code></a>,
 "storeName" is an internally generated name, and "-changelog" is a fixed suffix.
 You can retrieve all generated internal topic names via <a href="../../../../../org/apache/kafka/streams/KafkaStreams.html#toString()"><code>KafkaStreams.toString()</code></a>.</div>
<dl><dt><span class="strong">Type Parameters:</span></dt><dd><code>VO</code> - the value type of the other stream</dd><dd><code>VR</code> - the value type of the result stream</dd><dt><span class="strong">Parameters:</span></dt><dd><code>otherStream</code> - the <code>KStream</code> to be joined with this stream</dd><dd><code>joiner</code> - a <a href="../../../../../org/apache/kafka/streams/kstream/ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueJoiner</code></a> that computes the join result for a pair of matching records</dd><dd><code>windows</code> - the specification of the <a href="../../../../../org/apache/kafka/streams/kstream/JoinWindows.html" title="class in org.apache.kafka.streams.kstream"><code>JoinWindows</code></a></dd>
<dt><span class="strong">Returns:</span></dt><dd>a <code>KStream</code> that contains join-records for each key and values computed by the given
 <a href="../../../../../org/apache/kafka/streams/kstream/ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueJoiner</code></a>, one for each matched record-pair with the same key plus one for each non-matching record of
 both <code>KStream</code> and within the joining window intervals</dd><dt><span class="strong">See Also:</span></dt><dd><a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#join(org.apache.kafka.streams.kstream.KStream,%20org.apache.kafka.streams.kstream.ValueJoiner,%20org.apache.kafka.streams.kstream.JoinWindows)"><code>join(KStream, ValueJoiner, JoinWindows)</code></a>, 
<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#leftJoin(org.apache.kafka.streams.kstream.KStream,%20org.apache.kafka.streams.kstream.ValueJoiner,%20org.apache.kafka.streams.kstream.JoinWindows)"><code>leftJoin(KStream, ValueJoiner, JoinWindows)</code></a></dd></dl>
</li>
</ul>
<a name="outerJoin(org.apache.kafka.streams.kstream.KStream, org.apache.kafka.streams.kstream.ValueJoiner, org.apache.kafka.streams.kstream.JoinWindows, org.apache.kafka.common.serialization.Serde, org.apache.kafka.common.serialization.Serde, org.apache.kafka.common.serialization.Serde)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>outerJoin</h4>
<pre>&lt;VO,VR&gt;&nbsp;<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="interface in org.apache.kafka.streams.kstream">KStream</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">K</a>,VR&gt;&nbsp;outerJoin(<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="interface in org.apache.kafka.streams.kstream">KStream</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">K</a>,VO&gt;&nbsp;otherStream,
                              <a href="../../../../../org/apache/kafka/streams/kstream/ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream">ValueJoiner</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">V</a>,? super VO,? extends VR&gt;&nbsp;joiner,
                              <a href="../../../../../org/apache/kafka/streams/kstream/JoinWindows.html" title="class in org.apache.kafka.streams.kstream">JoinWindows</a>&nbsp;windows,
                              <a href="../../../../../org/apache/kafka/common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization">Serde</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">K</a>&gt;&nbsp;keySerde,
                              <a href="../../../../../org/apache/kafka/common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization">Serde</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">V</a>&gt;&nbsp;thisValueSerde,
                              <a href="../../../../../org/apache/kafka/common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization">Serde</a>&lt;VO&gt;&nbsp;otherValueSerde)</pre>
<div class="block">Join records of this stream with another <code>KStream</code>'s records using windowed left equi join.
 In contrast to <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#join(org.apache.kafka.streams.kstream.KStream,%20org.apache.kafka.streams.kstream.ValueJoiner,%20org.apache.kafka.streams.kstream.JoinWindows,%20org.apache.kafka.common.serialization.Serde,%20org.apache.kafka.common.serialization.Serde,%20org.apache.kafka.common.serialization.Serde)"><code>inner-join</code></a> or
 <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#leftJoin(org.apache.kafka.streams.kstream.KStream,%20org.apache.kafka.streams.kstream.ValueJoiner,%20org.apache.kafka.streams.kstream.JoinWindows,%20org.apache.kafka.common.serialization.Serde,%20org.apache.kafka.common.serialization.Serde,%20org.apache.kafka.common.serialization.Serde)"><code>left-join</code></a>, all records from both
 streams will produce at least one output record (cf. below).
 The join is computed on the records' key with join attribute <code>thisKStream.key == otherKStream.key</code>.
 Furthermore, two records are only joined if their timestamps are close to each other as defined by the given
 <a href="../../../../../org/apache/kafka/streams/kstream/JoinWindows.html" title="class in org.apache.kafka.streams.kstream"><code>JoinWindows</code></a>, i.e., the window defines an additional join predicate on the record timestamps.
 <p>
 For each pair of records meeting both join predicates the provided <a href="../../../../../org/apache/kafka/streams/kstream/ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueJoiner</code></a> will be called to compute
 a value (with arbitrary type) for the result record.
 The key of the result record is the same as for both joining input records.
 Furthermore, for each input record of both <code>KStream</code>s that does not satisfy the join predicate the provided
 <a href="../../../../../org/apache/kafka/streams/kstream/ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueJoiner</code></a> will be called with a <code>null</code> value for this/other stream, respectively.
 If an input record key or value is <code>null</code> the record will not be included in the join operation and thus no
 output record will be added to the resulting <code>KStream</code>.
 <p>
 Example (assuming all input records belong to the correct windows):
 <table border='1'>
 <tr>
 <th>this</th>
 <th>other</th>
 <th>result</th>
 </tr>
 <tr>
 <td>&lt;K1:A&gt;</td>
 <td></td>
 <td>&lt;K1:ValueJoiner(A,null)&gt;</td>
 </tr>
 <tr>
 <td>&lt;K2:B&gt;</td>
 <td>&lt;K2:b&gt;</td>
 <td>&lt;K2:ValueJoiner(null,b)&gt;<br />&lt;K2:ValueJoiner(B,b)&gt;</td>
 </tr>
 <tr>
 <td></td>
 <td>&lt;K3:c&gt;</td>
 <td>&lt;K3:ValueJoiner(null,c)&gt;</td>
 </tr>
 </table>
 Both input streams (or to be more precise, their underlying source topics) need to have the same number of
 partitions.
 If this is not the case, you would need to call <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#through(java.lang.String)"><code>through(String)</code></a> (for one input stream) before doing the
 join, using a pre-created topic with the "correct" number of partitions.
 Furthermore, both input streams need to be co-partitioned on the join key (i.e., use the same partitioner).
 If this requirement is not met, Kafka Streams will automatically repartition the data, i.e., it will create an
 internal repartitioning topic in Kafka and write and re-read the data via this topic before the actual join.
 The repartitioning topic will be named "${applicationId}-XXX-repartition", where "applicationId" is
 user-specified in <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html" title="class in org.apache.kafka.streams"><code>StreamsConfig</code></a> via parameter
 <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html#APPLICATION_ID_CONFIG"><code>APPLICATION_ID_CONFIG</code></a>, "XXX" is an internally generated name, and
 "-repartition" is a fixed suffix.
 You can retrieve all generated internal topic names via <a href="../../../../../org/apache/kafka/streams/KafkaStreams.html#toString()"><code>KafkaStreams.toString()</code></a>.
 <p>
 Repartitioning can happen for one or both of the joining <code>KStream</code>s.
 For this case, all data of the stream will be redistributed through the repartitioning topic by writing all
 records to it, and rereading all records from it, such that the join input <code>KStream</code> is partitioned
 correctly on its key.
 <p>
 Both of the joining <code>KStream</code>s will be materialized in local state stores with auto-generated store names.
 For failure and recovery each store will be backed by an internal changelog topic that will be created in Kafka.
 The changelog topic will be named "${applicationId}-storeName-changelog", where "applicationId" is user-specified
 in <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html" title="class in org.apache.kafka.streams"><code>StreamsConfig</code></a> via parameter <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html#APPLICATION_ID_CONFIG"><code>APPLICATION_ID_CONFIG</code></a>,
 "storeName" is an internally generated name, and "-changelog" is a fixed suffix.
 You can retrieve all generated internal topic names via <a href="../../../../../org/apache/kafka/streams/KafkaStreams.html#toString()"><code>KafkaStreams.toString()</code></a>.</div>
<dl><dt><span class="strong">Type Parameters:</span></dt><dd><code>VO</code> - the value type of the other stream</dd><dd><code>VR</code> - the value type of the result stream</dd><dt><span class="strong">Parameters:</span></dt><dd><code>otherStream</code> - the <code>KStream</code> to be joined with this stream</dd><dd><code>joiner</code> - a <a href="../../../../../org/apache/kafka/streams/kstream/ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueJoiner</code></a> that computes the join result for a pair of matching records</dd><dd><code>windows</code> - the specification of the <a href="../../../../../org/apache/kafka/streams/kstream/JoinWindows.html" title="class in org.apache.kafka.streams.kstream"><code>JoinWindows</code></a></dd><dd><code>keySerde</code> - key serdes for materializing both streams,
                        if not specified the default serdes defined in the configs will be used</dd><dd><code>thisValueSerde</code> - value serdes for materializing this stream,
                        if not specified the default serdes defined in the configs will be used</dd><dd><code>otherValueSerde</code> - value serdes for materializing the other stream,
                        if not specified the default serdes defined in the configs will be used</dd>
<dt><span class="strong">Returns:</span></dt><dd>a <code>KStream</code> that contains join-records for each key and values computed by the given
 <a href="../../../../../org/apache/kafka/streams/kstream/ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueJoiner</code></a>, one for each matched record-pair with the same key plus one for each non-matching record of
 both <code>KStream</code>s and within the joining window intervals</dd><dt><span class="strong">See Also:</span></dt><dd><a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#join(org.apache.kafka.streams.kstream.KStream,%20org.apache.kafka.streams.kstream.ValueJoiner,%20org.apache.kafka.streams.kstream.JoinWindows,%20org.apache.kafka.common.serialization.Serde,%20org.apache.kafka.common.serialization.Serde,%20org.apache.kafka.common.serialization.Serde)"><code>join(KStream, ValueJoiner, JoinWindows, Serde, Serde, Serde)</code></a>, 
<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#leftJoin(org.apache.kafka.streams.kstream.KStream,%20org.apache.kafka.streams.kstream.ValueJoiner,%20org.apache.kafka.streams.kstream.JoinWindows,%20org.apache.kafka.common.serialization.Serde,%20org.apache.kafka.common.serialization.Serde,%20org.apache.kafka.common.serialization.Serde)"><code>leftJoin(KStream, ValueJoiner, JoinWindows, Serde, Serde, Serde)</code></a></dd></dl>
</li>
</ul>
<a name="join(org.apache.kafka.streams.kstream.KTable, org.apache.kafka.streams.kstream.ValueJoiner)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>join</h4>
<pre>&lt;VT,VR&gt;&nbsp;<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="interface in org.apache.kafka.streams.kstream">KStream</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">K</a>,VR&gt;&nbsp;join(<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">K</a>,VT&gt;&nbsp;table,
                         <a href="../../../../../org/apache/kafka/streams/kstream/ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream">ValueJoiner</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">V</a>,? super VT,? extends VR&gt;&nbsp;joiner)</pre>
<div class="block">Join records of this stream with <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a>'s records using non-windowed inner equi join with default
 serializers and deserializers.
 The join is a primary key table lookup join with join attribute <code>stream.key == table.key</code>.
 "Table lookup join" means, that results are only computed if <code>KStream</code> records are processed.
 This is done by performing a lookup for matching records in the <em>current</em> (i.e., processing time) internal
 <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> state.
 In contrast, processing <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> input records will only update the internal <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> state and
 will not produce any result records.
 <p>
 For each <code>KStream</code> record that finds a corresponding record in <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> the provided
 <a href="../../../../../org/apache/kafka/streams/kstream/ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueJoiner</code></a> will be called to compute a value (with arbitrary type) for the result record.
 The key of the result record is the same as for both joining input records.
 If an <code>KStream</code> input record key or value is <code>null</code> the record will not be included in the join
 operation and thus no output record will be added to the resulting <code>KStream</code>.
 <p>
 Example:
 <table border='1'>
 <tr>
 <th>KStream</th>
 <th>KTable</th>
 <th>state</th>
 <th>result</th>
 </tr>
 <tr>
 <td>&lt;K1:A&gt;</td>
 <td></td>
 <td></td>
 <td></td>
 </tr>
 <tr>
 <td></td>
 <td>&lt;K1:b&gt;</td>
 <td>&lt;K1:b&gt;</td>
 <td></td>
 </tr>
 <tr>
 <td>&lt;K1:C&gt;</td>
 <td></td>
 <td>&lt;K1:b&gt;</td>
 <td>&lt;K1:ValueJoiner(C,b)&gt;</td>
 </tr>
 </table>
 Both input streams (or to be more precise, their underlying source topics) need to have the same number of
 partitions.
 If this is not the case, you would need to call <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#through(java.lang.String)"><code>through(String)</code></a> for this <code>KStream</code> before doing
 the join, using a pre-created topic with the same number of partitions as the given <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a>.
 Furthermore, both input streams need to be co-partitioned on the join key (i.e., use the same partitioner);
 cf. <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#join(org.apache.kafka.streams.kstream.GlobalKTable,%20org.apache.kafka.streams.kstream.KeyValueMapper,%20org.apache.kafka.streams.kstream.ValueJoiner)"><code>join(GlobalKTable, KeyValueMapper, ValueJoiner)</code></a>.
 If this requirement is not met, Kafka Streams will automatically repartition the data, i.e., it will create an
 internal repartitioning topic in Kafka and write and re-read the data via this topic before the actual join.
 The repartitioning topic will be named "${applicationId}-XXX-repartition", where "applicationId" is
 user-specified in <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html" title="class in org.apache.kafka.streams"><code>StreamsConfig</code></a> via parameter
 <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html#APPLICATION_ID_CONFIG"><code>APPLICATION_ID_CONFIG</code></a>, "XXX" is an internally generated name, and
 "-repartition" is a fixed suffix.
 You can retrieve all generated internal topic names via <a href="../../../../../org/apache/kafka/streams/KafkaStreams.html#toString()"><code>KafkaStreams.toString()</code></a>.
 <p>
 Repartitioning can happen only for this <code>KStream</code> but not for the provided <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a>.
 For this case, all data of the stream will be redistributed through the repartitioning topic by writing all
 records to it, and rereading all records from it, such that the join input <code>KStream</code> is partitioned
 correctly on its key.</div>
<dl><dt><span class="strong">Type Parameters:</span></dt><dd><code>VT</code> - the value type of the table</dd><dd><code>VR</code> - the value type of the result stream</dd><dt><span class="strong">Parameters:</span></dt><dd><code>table</code> - the <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> to be joined with this stream</dd><dd><code>joiner</code> - a <a href="../../../../../org/apache/kafka/streams/kstream/ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueJoiner</code></a> that computes the join result for a pair of matching records</dd>
<dt><span class="strong">Returns:</span></dt><dd>a <code>KStream</code> that contains join-records for each key and values computed by the given
 <a href="../../../../../org/apache/kafka/streams/kstream/ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueJoiner</code></a>, one for each matched record-pair with the same key</dd><dt><span class="strong">See Also:</span></dt><dd><a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#leftJoin(org.apache.kafka.streams.kstream.KTable,%20org.apache.kafka.streams.kstream.ValueJoiner)"><code>leftJoin(KTable, ValueJoiner)</code></a>, 
<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#join(org.apache.kafka.streams.kstream.GlobalKTable,%20org.apache.kafka.streams.kstream.KeyValueMapper,%20org.apache.kafka.streams.kstream.ValueJoiner)"><code>join(GlobalKTable, KeyValueMapper, ValueJoiner)</code></a></dd></dl>
</li>
</ul>
<a name="join(org.apache.kafka.streams.kstream.KTable, org.apache.kafka.streams.kstream.ValueJoiner, org.apache.kafka.common.serialization.Serde, org.apache.kafka.common.serialization.Serde)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>join</h4>
<pre>&lt;VT,VR&gt;&nbsp;<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="interface in org.apache.kafka.streams.kstream">KStream</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">K</a>,VR&gt;&nbsp;join(<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">K</a>,VT&gt;&nbsp;table,
                         <a href="../../../../../org/apache/kafka/streams/kstream/ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream">ValueJoiner</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">V</a>,? super VT,? extends VR&gt;&nbsp;joiner,
                         <a href="../../../../../org/apache/kafka/common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization">Serde</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">K</a>&gt;&nbsp;keySerde,
                         <a href="../../../../../org/apache/kafka/common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization">Serde</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">V</a>&gt;&nbsp;valSerde)</pre>
<div class="block">Join records of this stream with <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a>'s records using non-windowed inner equi join.
 The join is a primary key table lookup join with join attribute <code>stream.key == table.key</code>.
 "Table lookup join" means, that results are only computed if <code>KStream</code> records are processed.
 This is done by performing a lookup for matching records in the <em>current</em> (i.e., processing time) internal
 <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> state.
 In contrast, processing <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> input records will only update the internal <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> state and
 will not produce any result records.
 <p>
 For each <code>KStream</code> record that finds a corresponding record in <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> the provided
 <a href="../../../../../org/apache/kafka/streams/kstream/ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueJoiner</code></a> will be called to compute a value (with arbitrary type) for the result record.
 The key of the result record is the same as for both joining input records.
 If an <code>KStream</code> input record key or value is <code>null</code> the record will not be included in the join
 operation and thus no output record will be added to the resulting <code>KStream</code>.
 <p>
 Example:
 <table border='1'>
 <tr>
 <th>KStream</th>
 <th>KTable</th>
 <th>state</th>
 <th>result</th>
 </tr>
 <tr>
 <td>&lt;K1:A&gt;</td>
 <td></td>
 <td></td>
 <td></td>
 </tr>
 <tr>
 <td></td>
 <td>&lt;K1:b&gt;</td>
 <td>&lt;K1:b&gt;</td>
 <td></td>
 </tr>
 <tr>
 <td>&lt;K1:C&gt;</td>
 <td></td>
 <td>&lt;K1:b&gt;</td>
 <td>&lt;K1:ValueJoiner(C,b)&gt;</td>
 </tr>
 </table>
 Both input streams (or to be more precise, their underlying source topics) need to have the same number of
 partitions.
 If this is not the case, you would need to call <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#through(java.lang.String)"><code>through(String)</code></a> for this <code>KStream</code> before doing
 the join, using a pre-created topic with the same number of partitions as the given <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a>.
 Furthermore, both input streams need to be co-partitioned on the join key (i.e., use the same partitioner);
 cf. <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#join(org.apache.kafka.streams.kstream.GlobalKTable,%20org.apache.kafka.streams.kstream.KeyValueMapper,%20org.apache.kafka.streams.kstream.ValueJoiner)"><code>join(GlobalKTable, KeyValueMapper, ValueJoiner)</code></a>.
 If this requirement is not met, Kafka Streams will automatically repartition the data, i.e., it will create an
 internal repartitioning topic in Kafka and write and re-read the data via this topic before the actual join.
 The repartitioning topic will be named "${applicationId}-XXX-repartition", where "applicationId" is
 user-specified in <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html" title="class in org.apache.kafka.streams"><code>StreamsConfig</code></a> via parameter
 <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html#APPLICATION_ID_CONFIG"><code>APPLICATION_ID_CONFIG</code></a>, "XXX" is an internally generated name, and
 "-repartition" is a fixed suffix.
 You can retrieve all generated internal topic names via <a href="../../../../../org/apache/kafka/streams/KafkaStreams.html#toString()"><code>KafkaStreams.toString()</code></a>.
 <p>
 Repartitioning can happen only for this <code>KStream</code> but not for the provided <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a>.
 For this case, all data of the stream will be redistributed through the repartitioning topic by writing all
 records to it, and rereading all records from it, such that the join input <code>KStream</code> is partitioned
 correctly on its key.</div>
<dl><dt><span class="strong">Type Parameters:</span></dt><dd><code>VT</code> - the value type of the table</dd><dd><code>VR</code> - the value type of the result stream</dd><dt><span class="strong">Parameters:</span></dt><dd><code>table</code> - the <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> to be joined with this stream</dd><dd><code>joiner</code> - a <a href="../../../../../org/apache/kafka/streams/kstream/ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueJoiner</code></a> that computes the join result for a pair of matching records</dd><dd><code>keySerde</code> - key serdes for materializing this stream.
                 If not specified the default serdes defined in the configs will be used</dd><dd><code>valSerde</code> - value serdes for materializing this stream,
                 if not specified the default serdes defined in the configs will be used</dd>
<dt><span class="strong">Returns:</span></dt><dd>a <code>KStream</code> that contains join-records for each key and values computed by the given
 <a href="../../../../../org/apache/kafka/streams/kstream/ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueJoiner</code></a>, one for each matched record-pair with the same key</dd><dt><span class="strong">See Also:</span></dt><dd><a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#leftJoin(org.apache.kafka.streams.kstream.KTable,%20org.apache.kafka.streams.kstream.ValueJoiner,%20org.apache.kafka.common.serialization.Serde,%20org.apache.kafka.common.serialization.Serde)"><code>leftJoin(KTable, ValueJoiner, Serde, Serde)</code></a>, 
<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#join(org.apache.kafka.streams.kstream.GlobalKTable,%20org.apache.kafka.streams.kstream.KeyValueMapper,%20org.apache.kafka.streams.kstream.ValueJoiner)"><code>join(GlobalKTable, KeyValueMapper, ValueJoiner)</code></a></dd></dl>
</li>
</ul>
<a name="leftJoin(org.apache.kafka.streams.kstream.KTable, org.apache.kafka.streams.kstream.ValueJoiner)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>leftJoin</h4>
<pre>&lt;VT,VR&gt;&nbsp;<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="interface in org.apache.kafka.streams.kstream">KStream</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">K</a>,VR&gt;&nbsp;leftJoin(<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">K</a>,VT&gt;&nbsp;table,
                             <a href="../../../../../org/apache/kafka/streams/kstream/ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream">ValueJoiner</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">V</a>,? super VT,? extends VR&gt;&nbsp;joiner)</pre>
<div class="block">Join records of this stream with <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a>'s records using non-windowed left equi join with default
 serializers and deserializers.
 In contrast to <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#join(org.apache.kafka.streams.kstream.KTable,%20org.apache.kafka.streams.kstream.ValueJoiner)"><code>inner-join</code></a>, all records from this stream will produce an
 output record (cf. below).
 The join is a primary key table lookup join with join attribute <code>stream.key == table.key</code>.
 "Table lookup join" means, that results are only computed if <code>KStream</code> records are processed.
 This is done by performing a lookup for matching records in the <em>current</em> (i.e., processing time) internal
 <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> state.
 In contrast, processing <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> input records will only update the internal <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> state and
 will not produce any result records.
 <p>
 For each <code>KStream</code> record whether or not it finds a corresponding record in <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> the provided
 <a href="../../../../../org/apache/kafka/streams/kstream/ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueJoiner</code></a> will be called to compute a value (with arbitrary type) for the result record.
 If no <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> record was found during lookup, a <code>null</code> value will be provided to <a href="../../../../../org/apache/kafka/streams/kstream/ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueJoiner</code></a>.
 The key of the result record is the same as for both joining input records.
 If an <code>KStream</code> input record key or value is <code>null</code> the record will not be included in the join
 operation and thus no output record will be added to the resulting <code>KStream</code>.
 <p>
 Example:
 <table border='1'>
 <tr>
 <th>KStream</th>
 <th>KTable</th>
 <th>state</th>
 <th>result</th>
 </tr>
 <tr>
 <td>&lt;K1:A&gt;</td>
 <td></td>
 <td></td>
 <td>&lt;K1:ValueJoiner(A,null)&gt;</td>
 </tr>
 <tr>
 <td></td>
 <td>&lt;K1:b&gt;</td>
 <td>&lt;K1:b&gt;</td>
 <td></td>
 </tr>
 <tr>
 <td>&lt;K1:C&gt;</td>
 <td></td>
 <td>&lt;K1:b&gt;</td>
 <td>&lt;K1:ValueJoiner(C,b)&gt;</td>
 </tr>
 </table>
 Both input streams (or to be more precise, their underlying source topics) need to have the same number of
 partitions.
 If this is not the case, you would need to call <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#through(java.lang.String)"><code>through(String)</code></a> for this <code>KStream</code> before doing
 the join, using a pre-created topic with the same number of partitions as the given <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a>.
 Furthermore, both input streams need to be co-partitioned on the join key (i.e., use the same partitioner);
 cf. <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#join(org.apache.kafka.streams.kstream.GlobalKTable,%20org.apache.kafka.streams.kstream.KeyValueMapper,%20org.apache.kafka.streams.kstream.ValueJoiner)"><code>join(GlobalKTable, KeyValueMapper, ValueJoiner)</code></a>.
 If this requirement is not met, Kafka Streams will automatically repartition the data, i.e., it will create an
 internal repartitioning topic in Kafka and write and re-read the data via this topic before the actual join.
 The repartitioning topic will be named "${applicationId}-XXX-repartition", where "applicationId" is
 user-specified in <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html" title="class in org.apache.kafka.streams"><code>StreamsConfig</code></a> via parameter
 <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html#APPLICATION_ID_CONFIG"><code>APPLICATION_ID_CONFIG</code></a>, "XXX" is an internally generated name, and
 "-repartition" is a fixed suffix.
 You can retrieve all generated internal topic names via <a href="../../../../../org/apache/kafka/streams/KafkaStreams.html#toString()"><code>KafkaStreams.toString()</code></a>.
 <p>
 Repartitioning can happen only for this <code>KStream</code> but not for the provided <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a>.
 For this case, all data of the stream will be redistributed through the repartitioning topic by writing all
 records to it, and rereading all records from it, such that the join input <code>KStream</code> is partitioned
 correctly on its key.</div>
<dl><dt><span class="strong">Type Parameters:</span></dt><dd><code>VT</code> - the value type of the table</dd><dd><code>VR</code> - the value type of the result stream</dd><dt><span class="strong">Parameters:</span></dt><dd><code>table</code> - the <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> to be joined with this stream</dd><dd><code>joiner</code> - a <a href="../../../../../org/apache/kafka/streams/kstream/ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueJoiner</code></a> that computes the join result for a pair of matching records</dd>
<dt><span class="strong">Returns:</span></dt><dd>a <code>KStream</code> that contains join-records for each key and values computed by the given
 <a href="../../../../../org/apache/kafka/streams/kstream/ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueJoiner</code></a>, one output for each input <code>KStream</code> record</dd><dt><span class="strong">See Also:</span></dt><dd><a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#join(org.apache.kafka.streams.kstream.KTable,%20org.apache.kafka.streams.kstream.ValueJoiner)"><code>join(KTable, ValueJoiner)</code></a>, 
<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#leftJoin(org.apache.kafka.streams.kstream.GlobalKTable,%20org.apache.kafka.streams.kstream.KeyValueMapper,%20org.apache.kafka.streams.kstream.ValueJoiner)"><code>leftJoin(GlobalKTable, KeyValueMapper, ValueJoiner)</code></a></dd></dl>
</li>
</ul>
<a name="leftJoin(org.apache.kafka.streams.kstream.KTable, org.apache.kafka.streams.kstream.ValueJoiner, org.apache.kafka.common.serialization.Serde, org.apache.kafka.common.serialization.Serde)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>leftJoin</h4>
<pre>&lt;VT,VR&gt;&nbsp;<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="interface in org.apache.kafka.streams.kstream">KStream</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">K</a>,VR&gt;&nbsp;leftJoin(<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">K</a>,VT&gt;&nbsp;table,
                             <a href="../../../../../org/apache/kafka/streams/kstream/ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream">ValueJoiner</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">V</a>,? super VT,? extends VR&gt;&nbsp;joiner,
                             <a href="../../../../../org/apache/kafka/common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization">Serde</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">K</a>&gt;&nbsp;keySerde,
                             <a href="../../../../../org/apache/kafka/common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization">Serde</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">V</a>&gt;&nbsp;valSerde)</pre>
<div class="block">Join records of this stream with <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a>'s records using non-windowed left equi join.
 In contrast to <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#join(org.apache.kafka.streams.kstream.KTable,%20org.apache.kafka.streams.kstream.ValueJoiner)"><code>inner-join</code></a>, all records from this stream will produce an
 output record (cf. below).
 The join is a primary key table lookup join with join attribute <code>stream.key == table.key</code>.
 "Table lookup join" means, that results are only computed if <code>KStream</code> records are processed.
 This is done by performing a lookup for matching records in the <em>current</em> (i.e., processing time) internal
 <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> state.
 In contrast, processing <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> input records will only update the internal <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> state and
 will not produce any result records.
 <p>
 For each <code>KStream</code> record whether or not it finds a corresponding record in <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> the provided
 <a href="../../../../../org/apache/kafka/streams/kstream/ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueJoiner</code></a> will be called to compute a value (with arbitrary type) for the result record.
 If no <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> record was found during lookup, a <code>null</code> value will be provided to <a href="../../../../../org/apache/kafka/streams/kstream/ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueJoiner</code></a>.
 The key of the result record is the same as for both joining input records.
 If an <code>KStream</code> input record key or value is <code>null</code> the record will not be included in the join
 operation and thus no output record will be added to the resulting <code>KStream</code>.
 <p>
 Example:
 <table border='1'>
 <tr>
 <th>KStream</th>
 <th>KTable</th>
 <th>state</th>
 <th>result</th>
 </tr>
 <tr>
 <td>&lt;K1:A&gt;</td>
 <td></td>
 <td></td>
 <td>&lt;K1:ValueJoiner(A,null)&gt;</td>
 </tr>
 <tr>
 <td></td>
 <td>&lt;K1:b&gt;</td>
 <td>&lt;K1:b&gt;</td>
 <td></td>
 </tr>
 <tr>
 <td>&lt;K1:C&gt;</td>
 <td></td>
 <td>&lt;K1:b&gt;</td>
 <td>&lt;K1:ValueJoiner(C,b)&gt;</td>
 </tr>
 </table>
 Both input streams (or to be more precise, their underlying source topics) need to have the same number of
 partitions.
 If this is not the case, you would need to call <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#through(java.lang.String)"><code>through(String)</code></a> for this <code>KStream</code> before doing
 the join, using a pre-created topic with the same number of partitions as the given <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a>.
 Furthermore, both input streams need to be co-partitioned on the join key (i.e., use the same partitioner);
 cf. <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#join(org.apache.kafka.streams.kstream.GlobalKTable,%20org.apache.kafka.streams.kstream.KeyValueMapper,%20org.apache.kafka.streams.kstream.ValueJoiner)"><code>join(GlobalKTable, KeyValueMapper, ValueJoiner)</code></a>.
 If this requirement is not met, Kafka Streams will automatically repartition the data, i.e., it will create an
 internal repartitioning topic in Kafka and write and re-read the data via this topic before the actual join.
 The repartitioning topic will be named "${applicationId}-XXX-repartition", where "applicationId" is
 user-specified in <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html" title="class in org.apache.kafka.streams"><code>StreamsConfig</code></a> via parameter
 <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html#APPLICATION_ID_CONFIG"><code>APPLICATION_ID_CONFIG</code></a>, "XXX" is an internally generated name, and
 "-repartition" is a fixed suffix.
 You can retrieve all generated internal topic names via <a href="../../../../../org/apache/kafka/streams/KafkaStreams.html#toString()"><code>KafkaStreams.toString()</code></a>.
 <p>
 Repartitioning can happen only for this <code>KStream</code> but not for the provided <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a>.
 For this case, all data of the stream will be redistributed through the repartitioning topic by writing all
 records to it, and rereading all records from it, such that the join input <code>KStream</code> is partitioned
 correctly on its key.</div>
<dl><dt><span class="strong">Type Parameters:</span></dt><dd><code>VT</code> - the value type of the table</dd><dd><code>VR</code> - the value type of the result stream</dd><dt><span class="strong">Parameters:</span></dt><dd><code>table</code> - the <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> to be joined with this stream</dd><dd><code>joiner</code> - a <a href="../../../../../org/apache/kafka/streams/kstream/ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueJoiner</code></a> that computes the join result for a pair of matching records</dd><dd><code>keySerde</code> - key serdes for materializing this stream.
                 If not specified the default serdes defined in the configs will be used</dd><dd><code>valSerde</code> - value serdes for materializing this stream,
                 if not specified the default serdes defined in the configs will be used</dd>
<dt><span class="strong">Returns:</span></dt><dd>a <code>KStream</code> that contains join-records for each key and values computed by the given
 <a href="../../../../../org/apache/kafka/streams/kstream/ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueJoiner</code></a>, one output for each input <code>KStream</code> record</dd><dt><span class="strong">See Also:</span></dt><dd><a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#join(org.apache.kafka.streams.kstream.KTable,%20org.apache.kafka.streams.kstream.ValueJoiner,%20org.apache.kafka.common.serialization.Serde,%20org.apache.kafka.common.serialization.Serde)"><code>join(KTable, ValueJoiner, Serde, Serde)</code></a>, 
<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#leftJoin(org.apache.kafka.streams.kstream.GlobalKTable,%20org.apache.kafka.streams.kstream.KeyValueMapper,%20org.apache.kafka.streams.kstream.ValueJoiner)"><code>leftJoin(GlobalKTable, KeyValueMapper, ValueJoiner)</code></a></dd></dl>
</li>
</ul>
<a name="join(org.apache.kafka.streams.kstream.GlobalKTable, org.apache.kafka.streams.kstream.KeyValueMapper, org.apache.kafka.streams.kstream.ValueJoiner)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>join</h4>
<pre>&lt;GK,GV,RV&gt;&nbsp;<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="interface in org.apache.kafka.streams.kstream">KStream</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">K</a>,RV&gt;&nbsp;join(<a href="../../../../../org/apache/kafka/streams/kstream/GlobalKTable.html" title="interface in org.apache.kafka.streams.kstream">GlobalKTable</a>&lt;GK,GV&gt;&nbsp;globalKTable,
                            <a href="../../../../../org/apache/kafka/streams/kstream/KeyValueMapper.html" title="interface in org.apache.kafka.streams.kstream">KeyValueMapper</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">K</a>,? super <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">V</a>,? extends GK&gt;&nbsp;keyValueMapper,
                            <a href="../../../../../org/apache/kafka/streams/kstream/ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream">ValueJoiner</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">V</a>,? super GV,? extends RV&gt;&nbsp;joiner)</pre>
<div class="block">Join records of this stream with <a href="../../../../../org/apache/kafka/streams/kstream/GlobalKTable.html" title="interface in org.apache.kafka.streams.kstream"><code>GlobalKTable</code></a>'s records using non-windowed inner equi join.
 The join is a primary key table lookup join with join attribute
 <code>keyValueMapper.map(stream.keyValue) == table.key</code>.
 "Table lookup join" means, that results are only computed if <code>KStream</code> records are processed.
 This is done by performing a lookup for matching records in the <em>current</em> internal <a href="../../../../../org/apache/kafka/streams/kstream/GlobalKTable.html" title="interface in org.apache.kafka.streams.kstream"><code>GlobalKTable</code></a>
 state.
 In contrast, processing <a href="../../../../../org/apache/kafka/streams/kstream/GlobalKTable.html" title="interface in org.apache.kafka.streams.kstream"><code>GlobalKTable</code></a> input records will only update the internal <a href="../../../../../org/apache/kafka/streams/kstream/GlobalKTable.html" title="interface in org.apache.kafka.streams.kstream"><code>GlobalKTable</code></a>
 state and will not produce any result records.
 <p>
 For each <code>KStream</code> record that finds a corresponding record in <a href="../../../../../org/apache/kafka/streams/kstream/GlobalKTable.html" title="interface in org.apache.kafka.streams.kstream"><code>GlobalKTable</code></a> the provided
 <a href="../../../../../org/apache/kafka/streams/kstream/ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueJoiner</code></a> will be called to compute a value (with arbitrary type) for the result record.
 The key of the result record is the same as the key of this <code>KStream</code>.
 If an <code>KStream</code> input record key or value is <code>null</code> the record will not be included in the join
 operation and thus no output record will be added to the resulting <code>KStream</code>.</div>
<dl><dt><span class="strong">Type Parameters:</span></dt><dd><code>GK</code> - the key type of <a href="../../../../../org/apache/kafka/streams/kstream/GlobalKTable.html" title="interface in org.apache.kafka.streams.kstream"><code>GlobalKTable</code></a></dd><dd><code>GV</code> - the value type of the <a href="../../../../../org/apache/kafka/streams/kstream/GlobalKTable.html" title="interface in org.apache.kafka.streams.kstream"><code>GlobalKTable</code></a></dd><dd><code>RV</code> - the value type of the resulting <code>KStream</code></dd><dt><span class="strong">Parameters:</span></dt><dd><code>globalKTable</code> - the <a href="../../../../../org/apache/kafka/streams/kstream/GlobalKTable.html" title="interface in org.apache.kafka.streams.kstream"><code>GlobalKTable</code></a> to be joined with this stream</dd><dd><code>keyValueMapper</code> - instance of <a href="../../../../../org/apache/kafka/streams/kstream/KeyValueMapper.html" title="interface in org.apache.kafka.streams.kstream"><code>KeyValueMapper</code></a> used to map from the (key, value) of this stream
                       to the key of the <a href="../../../../../org/apache/kafka/streams/kstream/GlobalKTable.html" title="interface in org.apache.kafka.streams.kstream"><code>GlobalKTable</code></a></dd><dd><code>joiner</code> - a <a href="../../../../../org/apache/kafka/streams/kstream/ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueJoiner</code></a> that computes the join result for a pair of matching records</dd>
<dt><span class="strong">Returns:</span></dt><dd>a <code>KStream</code> that contains join-records for each key and values computed by the given
 <a href="../../../../../org/apache/kafka/streams/kstream/ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueJoiner</code></a>, one output for each input <code>KStream</code> record</dd><dt><span class="strong">See Also:</span></dt><dd><a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#leftJoin(org.apache.kafka.streams.kstream.GlobalKTable,%20org.apache.kafka.streams.kstream.KeyValueMapper,%20org.apache.kafka.streams.kstream.ValueJoiner)"><code>leftJoin(GlobalKTable, KeyValueMapper, ValueJoiner)</code></a></dd></dl>
</li>
</ul>
<a name="leftJoin(org.apache.kafka.streams.kstream.GlobalKTable, org.apache.kafka.streams.kstream.KeyValueMapper, org.apache.kafka.streams.kstream.ValueJoiner)">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>leftJoin</h4>
<pre>&lt;GK,GV,RV&gt;&nbsp;<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="interface in org.apache.kafka.streams.kstream">KStream</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">K</a>,RV&gt;&nbsp;leftJoin(<a href="../../../../../org/apache/kafka/streams/kstream/GlobalKTable.html" title="interface in org.apache.kafka.streams.kstream">GlobalKTable</a>&lt;GK,GV&gt;&nbsp;globalKTable,
                                <a href="../../../../../org/apache/kafka/streams/kstream/KeyValueMapper.html" title="interface in org.apache.kafka.streams.kstream">KeyValueMapper</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">K</a>,? super <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">V</a>,? extends GK&gt;&nbsp;keyValueMapper,
                                <a href="../../../../../org/apache/kafka/streams/kstream/ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream">ValueJoiner</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="type parameter in KStream">V</a>,? super GV,? extends RV&gt;&nbsp;valueJoiner)</pre>
<div class="block">Join records of this stream with <a href="../../../../../org/apache/kafka/streams/kstream/GlobalKTable.html" title="interface in org.apache.kafka.streams.kstream"><code>GlobalKTable</code></a>'s records using non-windowed left equi join.
 In contrast to <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#join(org.apache.kafka.streams.kstream.GlobalKTable,%20org.apache.kafka.streams.kstream.KeyValueMapper,%20org.apache.kafka.streams.kstream.ValueJoiner)"><code>inner-join</code></a>, all records from this stream
 will produce an output record (cf. below).
 The join is a primary key table lookup join with join attribute
 <code>keyValueMapper.map(stream.keyValue) == table.key</code>.
 "Table lookup join" means, that results are only computed if <code>KStream</code> records are processed.
 This is done by performing a lookup for matching records in the <em>current</em> internal <a href="../../../../../org/apache/kafka/streams/kstream/GlobalKTable.html" title="interface in org.apache.kafka.streams.kstream"><code>GlobalKTable</code></a>
 state.
 In contrast, processing <a href="../../../../../org/apache/kafka/streams/kstream/GlobalKTable.html" title="interface in org.apache.kafka.streams.kstream"><code>GlobalKTable</code></a> input records will only update the internal <a href="../../../../../org/apache/kafka/streams/kstream/GlobalKTable.html" title="interface in org.apache.kafka.streams.kstream"><code>GlobalKTable</code></a>
 state and will not produce any result records.
 <p>
 For each <code>KStream</code> record whether or not it finds a corresponding record in <a href="../../../../../org/apache/kafka/streams/kstream/GlobalKTable.html" title="interface in org.apache.kafka.streams.kstream"><code>GlobalKTable</code></a> the
 provided <a href="../../../../../org/apache/kafka/streams/kstream/ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueJoiner</code></a> will be called to compute a value (with arbitrary type) for the result record.
 If no <a href="../../../../../org/apache/kafka/streams/kstream/GlobalKTable.html" title="interface in org.apache.kafka.streams.kstream"><code>GlobalKTable</code></a> record was found during lookup, a <code>null</code> value will be provided to
 <a href="../../../../../org/apache/kafka/streams/kstream/ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueJoiner</code></a>.
 The key of the result record is the same as this <code>KStream</code>.
 If an <code>KStream</code> input record key or value is <code>null</code> the record will not be included in the join
 operation and thus no output record will be added to the resulting <code>KStream</code>.</div>
<dl><dt><span class="strong">Type Parameters:</span></dt><dd><code>GK</code> - the key type of <a href="../../../../../org/apache/kafka/streams/kstream/GlobalKTable.html" title="interface in org.apache.kafka.streams.kstream"><code>GlobalKTable</code></a></dd><dd><code>GV</code> - the value type of the <a href="../../../../../org/apache/kafka/streams/kstream/GlobalKTable.html" title="interface in org.apache.kafka.streams.kstream"><code>GlobalKTable</code></a></dd><dd><code>RV</code> - the value type of the resulting <code>KStream</code></dd><dt><span class="strong">Parameters:</span></dt><dd><code>globalKTable</code> - the <a href="../../../../../org/apache/kafka/streams/kstream/GlobalKTable.html" title="interface in org.apache.kafka.streams.kstream"><code>GlobalKTable</code></a> to be joined with this stream</dd><dd><code>keyValueMapper</code> - instance of <a href="../../../../../org/apache/kafka/streams/kstream/KeyValueMapper.html" title="interface in org.apache.kafka.streams.kstream"><code>KeyValueMapper</code></a> used to map from the (key, value) of this stream
                       to the key of the <a href="../../../../../org/apache/kafka/streams/kstream/GlobalKTable.html" title="interface in org.apache.kafka.streams.kstream"><code>GlobalKTable</code></a></dd><dd><code>valueJoiner</code> - a <a href="../../../../../org/apache/kafka/streams/kstream/ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueJoiner</code></a> that computes the join result for a pair of matching records</dd>
<dt><span class="strong">Returns:</span></dt><dd>a <code>KStream</code> that contains join-records for each key and values computed by the given
 <a href="../../../../../org/apache/kafka/streams/kstream/ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueJoiner</code></a>, one output for each input <code>KStream</code> record</dd><dt><span class="strong">See Also:</span></dt><dd><a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#join(org.apache.kafka.streams.kstream.GlobalKTable,%20org.apache.kafka.streams.kstream.KeyValueMapper,%20org.apache.kafka.streams.kstream.ValueJoiner)"><code>join(GlobalKTable, KeyValueMapper, ValueJoiner)</code></a></dd></dl>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<!-- ========= END OF CLASS DATA ========= -->
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a name="navbar_bottom">
<!--   -->
</a><a href="#skip-navbar_bottom" title="Skip navigation links"></a><a name="navbar_bottom_firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../../../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../../index-all.html">Index</a></li>
<li><a href="../../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html" title="interface in org.apache.kafka.streams.kstream"><span class="strong">Prev Class</span></a></li>
<li><a href="../../../../../org/apache/kafka/streams/kstream/KStreamBuilder.html" title="class in org.apache.kafka.streams.kstream"><span class="strong">Next Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../../../../index.html?org/apache/kafka/streams/kstream/KStream.html" target="_top">Frames</a></li>
<li><a href="KStream.html" target="_top">No Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="../../../../../allclasses-noframe.html">All Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method_summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method_detail">Method</a></li>
</ul>
</div>
<a name="skip-navbar_bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
</body>
</html>

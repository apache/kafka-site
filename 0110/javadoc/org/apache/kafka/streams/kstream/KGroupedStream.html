<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (version 1.7.0_80) on Fri Nov 10 23:49:17 GMT 2017 -->
<title>KGroupedStream (kafka 0.11.0.2 API)</title>
<meta name="date" content="2017-11-10">
<link rel="stylesheet" type="text/css" href="../../../../../stylesheet.css" title="Style">
</head>
<body>
<script type="text/javascript"><!--
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="KGroupedStream (kafka 0.11.0.2 API)";
    }
//-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a name="navbar_top">
<!--   -->
</a><a href="#skip-navbar_top" title="Skip navigation links"></a><a name="navbar_top_firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../../../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../../index-all.html">Index</a></li>
<li><a href="../../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../../../../org/apache/kafka/streams/kstream/KeyValueMapper.html" title="interface in org.apache.kafka.streams.kstream"><span class="strong">Prev Class</span></a></li>
<li><a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html" title="interface in org.apache.kafka.streams.kstream"><span class="strong">Next Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../../../../index.html?org/apache/kafka/streams/kstream/KGroupedStream.html" target="_top">Frames</a></li>
<li><a href="KGroupedStream.html" target="_top">No Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_top">
<li><a href="../../../../../allclasses-noframe.html">All Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method_summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method_detail">Method</a></li>
</ul>
</div>
<a name="skip-navbar_top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="subTitle">org.apache.kafka.streams.kstream</div>
<h2 title="Interface KGroupedStream" class="title">Interface KGroupedStream&lt;K,V&gt;</h2>
</div>
<div class="contentContainer">
<div class="description">
<ul class="blockList">
<li class="blockList">
<dl><dt><span class="strong">Type Parameters:</span></dt><dd><code>K</code> - Type of keys</dd><dd><code>V</code> - Type of values</dd></dl>
<hr>
<br>
<pre><a href="../../../../../org/apache/kafka/common/annotation/InterfaceStability.Evolving.html" title="annotation in org.apache.kafka.common.annotation">@InterfaceStability.Evolving</a>
public interface <span class="strong">KGroupedStream&lt;K,V&gt;</span></pre>
<div class="block"><code>KGroupedStream</code> is an abstraction of a <i>grouped</i> record stream of <a href="../../../../../org/apache/kafka/streams/KeyValue.html" title="class in org.apache.kafka.streams"><code>KeyValue</code></a> pairs.
 It is an intermediate representation of a <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="interface in org.apache.kafka.streams.kstream"><code>KStream</code></a> in order to apply an aggregation operation on the original
 <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="interface in org.apache.kafka.streams.kstream"><code>KStream</code></a> records.
 <p>
 It is an intermediate representation after a grouping of a <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="interface in org.apache.kafka.streams.kstream"><code>KStream</code></a> before an aggregation is applied to the
 new partitions resulting in a <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a>.
 <p>
 A <code>KGroupedStream</code> must be obtained from a <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="interface in org.apache.kafka.streams.kstream"><code>KStream</code></a> via <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#groupByKey()"><code>groupByKey()</code></a> or
 <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#groupBy(org.apache.kafka.streams.kstream.KeyValueMapper)"><code>groupBy(...)</code></a>.</div>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="interface in org.apache.kafka.streams.kstream"><code>KStream</code></a></dd></dl>
</li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- ========== METHOD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="method_summary">
<!--   -->
</a>
<h3>Method Summary</h3>
<table class="overviewSummary" border="0" cellpadding="3" cellspacing="0" summary="Method Summary table, listing methods, and an explanation">
<caption><span>Methods</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Method and Description</th>
</tr>
<tr class="altColor">
<td class="colFirst"><code>&lt;T&gt;&nbsp;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/Windowed.html" title="class in org.apache.kafka.streams.kstream">Windowed</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html" title="type parameter in KGroupedStream">K</a>&gt;,T&gt;</code></td>
<td class="colLast"><code><strong><a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html#aggregate(org.apache.kafka.streams.kstream.Initializer,%20org.apache.kafka.streams.kstream.Aggregator,%20org.apache.kafka.streams.kstream.Merger,%20org.apache.kafka.streams.kstream.SessionWindows,%20org.apache.kafka.common.serialization.Serde)">aggregate</a></strong>(<a href="../../../../../org/apache/kafka/streams/kstream/Initializer.html" title="interface in org.apache.kafka.streams.kstream">Initializer</a>&lt;T&gt;&nbsp;initializer,
         <a href="../../../../../org/apache/kafka/streams/kstream/Aggregator.html" title="interface in org.apache.kafka.streams.kstream">Aggregator</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html" title="type parameter in KGroupedStream">K</a>,? super <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html" title="type parameter in KGroupedStream">V</a>,T&gt;&nbsp;aggregator,
         <a href="../../../../../org/apache/kafka/streams/kstream/Merger.html" title="interface in org.apache.kafka.streams.kstream">Merger</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html" title="type parameter in KGroupedStream">K</a>,T&gt;&nbsp;sessionMerger,
         <a href="../../../../../org/apache/kafka/streams/kstream/SessionWindows.html" title="class in org.apache.kafka.streams.kstream">SessionWindows</a>&nbsp;sessionWindows,
         <a href="../../../../../org/apache/kafka/common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization">Serde</a>&lt;T&gt;&nbsp;aggValueSerde)</code>
<div class="block">Aggregate the values of records in this stream by the grouped key and defined <a href="../../../../../org/apache/kafka/streams/kstream/SessionWindows.html" title="class in org.apache.kafka.streams.kstream"><code>SessionWindows</code></a>.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>&lt;T&gt;&nbsp;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/Windowed.html" title="class in org.apache.kafka.streams.kstream">Windowed</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html" title="type parameter in KGroupedStream">K</a>&gt;,T&gt;</code></td>
<td class="colLast"><code><strong><a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html#aggregate(org.apache.kafka.streams.kstream.Initializer,%20org.apache.kafka.streams.kstream.Aggregator,%20org.apache.kafka.streams.kstream.Merger,%20org.apache.kafka.streams.kstream.SessionWindows,%20org.apache.kafka.common.serialization.Serde,%20org.apache.kafka.streams.processor.StateStoreSupplier)">aggregate</a></strong>(<a href="../../../../../org/apache/kafka/streams/kstream/Initializer.html" title="interface in org.apache.kafka.streams.kstream">Initializer</a>&lt;T&gt;&nbsp;initializer,
         <a href="../../../../../org/apache/kafka/streams/kstream/Aggregator.html" title="interface in org.apache.kafka.streams.kstream">Aggregator</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html" title="type parameter in KGroupedStream">K</a>,? super <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html" title="type parameter in KGroupedStream">V</a>,T&gt;&nbsp;aggregator,
         <a href="../../../../../org/apache/kafka/streams/kstream/Merger.html" title="interface in org.apache.kafka.streams.kstream">Merger</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html" title="type parameter in KGroupedStream">K</a>,T&gt;&nbsp;sessionMerger,
         <a href="../../../../../org/apache/kafka/streams/kstream/SessionWindows.html" title="class in org.apache.kafka.streams.kstream">SessionWindows</a>&nbsp;sessionWindows,
         <a href="../../../../../org/apache/kafka/common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization">Serde</a>&lt;T&gt;&nbsp;aggValueSerde,
         <a href="../../../../../org/apache/kafka/streams/processor/StateStoreSupplier.html" title="interface in org.apache.kafka.streams.processor">StateStoreSupplier</a>&lt;<a href="../../../../../org/apache/kafka/streams/state/SessionStore.html" title="interface in org.apache.kafka.streams.state">SessionStore</a>&gt;&nbsp;storeSupplier)</code>
<div class="block">Aggregate the values of records in this stream by the grouped key and defined <a href="../../../../../org/apache/kafka/streams/kstream/SessionWindows.html" title="class in org.apache.kafka.streams.kstream"><code>SessionWindows</code></a>.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>&lt;T&gt;&nbsp;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/Windowed.html" title="class in org.apache.kafka.streams.kstream">Windowed</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html" title="type parameter in KGroupedStream">K</a>&gt;,T&gt;</code></td>
<td class="colLast"><code><strong><a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html#aggregate(org.apache.kafka.streams.kstream.Initializer,%20org.apache.kafka.streams.kstream.Aggregator,%20org.apache.kafka.streams.kstream.Merger,%20org.apache.kafka.streams.kstream.SessionWindows,%20org.apache.kafka.common.serialization.Serde,%20java.lang.String)">aggregate</a></strong>(<a href="../../../../../org/apache/kafka/streams/kstream/Initializer.html" title="interface in org.apache.kafka.streams.kstream">Initializer</a>&lt;T&gt;&nbsp;initializer,
         <a href="../../../../../org/apache/kafka/streams/kstream/Aggregator.html" title="interface in org.apache.kafka.streams.kstream">Aggregator</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html" title="type parameter in KGroupedStream">K</a>,? super <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html" title="type parameter in KGroupedStream">V</a>,T&gt;&nbsp;aggregator,
         <a href="../../../../../org/apache/kafka/streams/kstream/Merger.html" title="interface in org.apache.kafka.streams.kstream">Merger</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html" title="type parameter in KGroupedStream">K</a>,T&gt;&nbsp;sessionMerger,
         <a href="../../../../../org/apache/kafka/streams/kstream/SessionWindows.html" title="class in org.apache.kafka.streams.kstream">SessionWindows</a>&nbsp;sessionWindows,
         <a href="../../../../../org/apache/kafka/common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization">Serde</a>&lt;T&gt;&nbsp;aggValueSerde,
         java.lang.String&nbsp;queryableStoreName)</code>
<div class="block">Aggregate the values of records in this stream by the grouped key and defined <a href="../../../../../org/apache/kafka/streams/kstream/SessionWindows.html" title="class in org.apache.kafka.streams.kstream"><code>SessionWindows</code></a>.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>&lt;VR&gt;&nbsp;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html" title="type parameter in KGroupedStream">K</a>,VR&gt;</code></td>
<td class="colLast"><code><strong><a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html#aggregate(org.apache.kafka.streams.kstream.Initializer,%20org.apache.kafka.streams.kstream.Aggregator,%20org.apache.kafka.common.serialization.Serde)">aggregate</a></strong>(<a href="../../../../../org/apache/kafka/streams/kstream/Initializer.html" title="interface in org.apache.kafka.streams.kstream">Initializer</a>&lt;VR&gt;&nbsp;initializer,
         <a href="../../../../../org/apache/kafka/streams/kstream/Aggregator.html" title="interface in org.apache.kafka.streams.kstream">Aggregator</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html" title="type parameter in KGroupedStream">K</a>,? super <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html" title="type parameter in KGroupedStream">V</a>,VR&gt;&nbsp;aggregator,
         <a href="../../../../../org/apache/kafka/common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization">Serde</a>&lt;VR&gt;&nbsp;aggValueSerde)</code>
<div class="block">Aggregate the values of records in this stream by the grouped key.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>&lt;VR&gt;&nbsp;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html" title="type parameter in KGroupedStream">K</a>,VR&gt;</code></td>
<td class="colLast"><code><strong><a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html#aggregate(org.apache.kafka.streams.kstream.Initializer,%20org.apache.kafka.streams.kstream.Aggregator,%20org.apache.kafka.common.serialization.Serde,%20java.lang.String)">aggregate</a></strong>(<a href="../../../../../org/apache/kafka/streams/kstream/Initializer.html" title="interface in org.apache.kafka.streams.kstream">Initializer</a>&lt;VR&gt;&nbsp;initializer,
         <a href="../../../../../org/apache/kafka/streams/kstream/Aggregator.html" title="interface in org.apache.kafka.streams.kstream">Aggregator</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html" title="type parameter in KGroupedStream">K</a>,? super <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html" title="type parameter in KGroupedStream">V</a>,VR&gt;&nbsp;aggregator,
         <a href="../../../../../org/apache/kafka/common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization">Serde</a>&lt;VR&gt;&nbsp;aggValueSerde,
         java.lang.String&nbsp;queryableStoreName)</code>
<div class="block">Aggregate the values of records in this stream by the grouped key.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>&lt;VR&gt;&nbsp;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html" title="type parameter in KGroupedStream">K</a>,VR&gt;</code></td>
<td class="colLast"><code><strong><a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html#aggregate(org.apache.kafka.streams.kstream.Initializer,%20org.apache.kafka.streams.kstream.Aggregator,%20org.apache.kafka.streams.processor.StateStoreSupplier)">aggregate</a></strong>(<a href="../../../../../org/apache/kafka/streams/kstream/Initializer.html" title="interface in org.apache.kafka.streams.kstream">Initializer</a>&lt;VR&gt;&nbsp;initializer,
         <a href="../../../../../org/apache/kafka/streams/kstream/Aggregator.html" title="interface in org.apache.kafka.streams.kstream">Aggregator</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html" title="type parameter in KGroupedStream">K</a>,? super <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html" title="type parameter in KGroupedStream">V</a>,VR&gt;&nbsp;aggregator,
         <a href="../../../../../org/apache/kafka/streams/processor/StateStoreSupplier.html" title="interface in org.apache.kafka.streams.processor">StateStoreSupplier</a>&lt;<a href="../../../../../org/apache/kafka/streams/state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state">KeyValueStore</a>&gt;&nbsp;storeSupplier)</code>
<div class="block">Aggregate the values of records in this stream by the grouped key.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>&lt;W extends <a href="../../../../../org/apache/kafka/streams/kstream/Window.html" title="class in org.apache.kafka.streams.kstream">Window</a>,VR&gt;&nbsp;<br><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/Windowed.html" title="class in org.apache.kafka.streams.kstream">Windowed</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html" title="type parameter in KGroupedStream">K</a>&gt;,VR&gt;</code></td>
<td class="colLast"><code><strong><a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html#aggregate(org.apache.kafka.streams.kstream.Initializer,%20org.apache.kafka.streams.kstream.Aggregator,%20org.apache.kafka.streams.kstream.Windows,%20org.apache.kafka.common.serialization.Serde)">aggregate</a></strong>(<a href="../../../../../org/apache/kafka/streams/kstream/Initializer.html" title="interface in org.apache.kafka.streams.kstream">Initializer</a>&lt;VR&gt;&nbsp;initializer,
         <a href="../../../../../org/apache/kafka/streams/kstream/Aggregator.html" title="interface in org.apache.kafka.streams.kstream">Aggregator</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html" title="type parameter in KGroupedStream">K</a>,? super <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html" title="type parameter in KGroupedStream">V</a>,VR&gt;&nbsp;aggregator,
         <a href="../../../../../org/apache/kafka/streams/kstream/Windows.html" title="class in org.apache.kafka.streams.kstream">Windows</a>&lt;W&gt;&nbsp;windows,
         <a href="../../../../../org/apache/kafka/common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization">Serde</a>&lt;VR&gt;&nbsp;aggValueSerde)</code>
<div class="block">Aggregate the values of records in this stream by the grouped key and defined windows.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>&lt;W extends <a href="../../../../../org/apache/kafka/streams/kstream/Window.html" title="class in org.apache.kafka.streams.kstream">Window</a>,VR&gt;&nbsp;<br><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/Windowed.html" title="class in org.apache.kafka.streams.kstream">Windowed</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html" title="type parameter in KGroupedStream">K</a>&gt;,VR&gt;</code></td>
<td class="colLast"><code><strong><a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html#aggregate(org.apache.kafka.streams.kstream.Initializer,%20org.apache.kafka.streams.kstream.Aggregator,%20org.apache.kafka.streams.kstream.Windows,%20org.apache.kafka.common.serialization.Serde,%20java.lang.String)">aggregate</a></strong>(<a href="../../../../../org/apache/kafka/streams/kstream/Initializer.html" title="interface in org.apache.kafka.streams.kstream">Initializer</a>&lt;VR&gt;&nbsp;initializer,
         <a href="../../../../../org/apache/kafka/streams/kstream/Aggregator.html" title="interface in org.apache.kafka.streams.kstream">Aggregator</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html" title="type parameter in KGroupedStream">K</a>,? super <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html" title="type parameter in KGroupedStream">V</a>,VR&gt;&nbsp;aggregator,
         <a href="../../../../../org/apache/kafka/streams/kstream/Windows.html" title="class in org.apache.kafka.streams.kstream">Windows</a>&lt;W&gt;&nbsp;windows,
         <a href="../../../../../org/apache/kafka/common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization">Serde</a>&lt;VR&gt;&nbsp;aggValueSerde,
         java.lang.String&nbsp;queryableStoreName)</code>
<div class="block">Aggregate the values of records in this stream by the grouped key and defined windows.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>&lt;W extends <a href="../../../../../org/apache/kafka/streams/kstream/Window.html" title="class in org.apache.kafka.streams.kstream">Window</a>,VR&gt;&nbsp;<br><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/Windowed.html" title="class in org.apache.kafka.streams.kstream">Windowed</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html" title="type parameter in KGroupedStream">K</a>&gt;,VR&gt;</code></td>
<td class="colLast"><code><strong><a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html#aggregate(org.apache.kafka.streams.kstream.Initializer,%20org.apache.kafka.streams.kstream.Aggregator,%20org.apache.kafka.streams.kstream.Windows,%20org.apache.kafka.streams.processor.StateStoreSupplier)">aggregate</a></strong>(<a href="../../../../../org/apache/kafka/streams/kstream/Initializer.html" title="interface in org.apache.kafka.streams.kstream">Initializer</a>&lt;VR&gt;&nbsp;initializer,
         <a href="../../../../../org/apache/kafka/streams/kstream/Aggregator.html" title="interface in org.apache.kafka.streams.kstream">Aggregator</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html" title="type parameter in KGroupedStream">K</a>,? super <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html" title="type parameter in KGroupedStream">V</a>,VR&gt;&nbsp;aggregator,
         <a href="../../../../../org/apache/kafka/streams/kstream/Windows.html" title="class in org.apache.kafka.streams.kstream">Windows</a>&lt;W&gt;&nbsp;windows,
         <a href="../../../../../org/apache/kafka/streams/processor/StateStoreSupplier.html" title="interface in org.apache.kafka.streams.processor">StateStoreSupplier</a>&lt;<a href="../../../../../org/apache/kafka/streams/state/WindowStore.html" title="interface in org.apache.kafka.streams.state">WindowStore</a>&gt;&nbsp;storeSupplier)</code>
<div class="block">Aggregate the values of records in this stream by the grouped key and defined windows.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html" title="type parameter in KGroupedStream">K</a>,java.lang.Long&gt;</code></td>
<td class="colLast"><code><strong><a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html#count()">count</a></strong>()</code>
<div class="block">Count the number of records in this stream by the grouped key.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/Windowed.html" title="class in org.apache.kafka.streams.kstream">Windowed</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html" title="type parameter in KGroupedStream">K</a>&gt;,java.lang.Long&gt;</code></td>
<td class="colLast"><code><strong><a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html#count(org.apache.kafka.streams.kstream.SessionWindows)">count</a></strong>(<a href="../../../../../org/apache/kafka/streams/kstream/SessionWindows.html" title="class in org.apache.kafka.streams.kstream">SessionWindows</a>&nbsp;sessionWindows)</code>
<div class="block">Count the number of records in this stream by the grouped key into <a href="../../../../../org/apache/kafka/streams/kstream/SessionWindows.html" title="class in org.apache.kafka.streams.kstream"><code>SessionWindows</code></a>.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/Windowed.html" title="class in org.apache.kafka.streams.kstream">Windowed</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html" title="type parameter in KGroupedStream">K</a>&gt;,java.lang.Long&gt;</code></td>
<td class="colLast"><code><strong><a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html#count(org.apache.kafka.streams.kstream.SessionWindows,%20org.apache.kafka.streams.processor.StateStoreSupplier)">count</a></strong>(<a href="../../../../../org/apache/kafka/streams/kstream/SessionWindows.html" title="class in org.apache.kafka.streams.kstream">SessionWindows</a>&nbsp;sessionWindows,
     <a href="../../../../../org/apache/kafka/streams/processor/StateStoreSupplier.html" title="interface in org.apache.kafka.streams.processor">StateStoreSupplier</a>&lt;<a href="../../../../../org/apache/kafka/streams/state/SessionStore.html" title="interface in org.apache.kafka.streams.state">SessionStore</a>&gt;&nbsp;storeSupplier)</code>
<div class="block">Count the number of records in this stream by the grouped key into <a href="../../../../../org/apache/kafka/streams/kstream/SessionWindows.html" title="class in org.apache.kafka.streams.kstream"><code>SessionWindows</code></a>.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/Windowed.html" title="class in org.apache.kafka.streams.kstream">Windowed</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html" title="type parameter in KGroupedStream">K</a>&gt;,java.lang.Long&gt;</code></td>
<td class="colLast"><code><strong><a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html#count(org.apache.kafka.streams.kstream.SessionWindows,%20java.lang.String)">count</a></strong>(<a href="../../../../../org/apache/kafka/streams/kstream/SessionWindows.html" title="class in org.apache.kafka.streams.kstream">SessionWindows</a>&nbsp;sessionWindows,
     java.lang.String&nbsp;queryableStoreName)</code>
<div class="block">Count the number of records in this stream by the grouped key into <a href="../../../../../org/apache/kafka/streams/kstream/SessionWindows.html" title="class in org.apache.kafka.streams.kstream"><code>SessionWindows</code></a>.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html" title="type parameter in KGroupedStream">K</a>,java.lang.Long&gt;</code></td>
<td class="colLast"><code><strong><a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html#count(org.apache.kafka.streams.processor.StateStoreSupplier)">count</a></strong>(<a href="../../../../../org/apache/kafka/streams/processor/StateStoreSupplier.html" title="interface in org.apache.kafka.streams.processor">StateStoreSupplier</a>&lt;<a href="../../../../../org/apache/kafka/streams/state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state">KeyValueStore</a>&gt;&nbsp;storeSupplier)</code>
<div class="block">Count the number of records in this stream by the grouped key.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html" title="type parameter in KGroupedStream">K</a>,java.lang.Long&gt;</code></td>
<td class="colLast"><code><strong><a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html#count(java.lang.String)">count</a></strong>(java.lang.String&nbsp;queryableStoreName)</code>
<div class="block">Count the number of records in this stream by the grouped key.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>&lt;W extends <a href="../../../../../org/apache/kafka/streams/kstream/Window.html" title="class in org.apache.kafka.streams.kstream">Window</a>&gt;&nbsp;<br><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/Windowed.html" title="class in org.apache.kafka.streams.kstream">Windowed</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html" title="type parameter in KGroupedStream">K</a>&gt;,java.lang.Long&gt;</code></td>
<td class="colLast"><code><strong><a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html#count(org.apache.kafka.streams.kstream.Windows)">count</a></strong>(<a href="../../../../../org/apache/kafka/streams/kstream/Windows.html" title="class in org.apache.kafka.streams.kstream">Windows</a>&lt;W&gt;&nbsp;windows)</code>
<div class="block">Count the number of records in this stream by the grouped key and the defined windows.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>&lt;W extends <a href="../../../../../org/apache/kafka/streams/kstream/Window.html" title="class in org.apache.kafka.streams.kstream">Window</a>&gt;&nbsp;<br><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/Windowed.html" title="class in org.apache.kafka.streams.kstream">Windowed</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html" title="type parameter in KGroupedStream">K</a>&gt;,java.lang.Long&gt;</code></td>
<td class="colLast"><code><strong><a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html#count(org.apache.kafka.streams.kstream.Windows,%20org.apache.kafka.streams.processor.StateStoreSupplier)">count</a></strong>(<a href="../../../../../org/apache/kafka/streams/kstream/Windows.html" title="class in org.apache.kafka.streams.kstream">Windows</a>&lt;W&gt;&nbsp;windows,
     <a href="../../../../../org/apache/kafka/streams/processor/StateStoreSupplier.html" title="interface in org.apache.kafka.streams.processor">StateStoreSupplier</a>&lt;<a href="../../../../../org/apache/kafka/streams/state/WindowStore.html" title="interface in org.apache.kafka.streams.state">WindowStore</a>&gt;&nbsp;storeSupplier)</code>
<div class="block">Count the number of records in this stream by the grouped key and the defined windows.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>&lt;W extends <a href="../../../../../org/apache/kafka/streams/kstream/Window.html" title="class in org.apache.kafka.streams.kstream">Window</a>&gt;&nbsp;<br><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/Windowed.html" title="class in org.apache.kafka.streams.kstream">Windowed</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html" title="type parameter in KGroupedStream">K</a>&gt;,java.lang.Long&gt;</code></td>
<td class="colLast"><code><strong><a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html#count(org.apache.kafka.streams.kstream.Windows,%20java.lang.String)">count</a></strong>(<a href="../../../../../org/apache/kafka/streams/kstream/Windows.html" title="class in org.apache.kafka.streams.kstream">Windows</a>&lt;W&gt;&nbsp;windows,
     java.lang.String&nbsp;queryableStoreName)</code>
<div class="block">Count the number of records in this stream by the grouped key and the defined windows.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html" title="type parameter in KGroupedStream">K</a>,<a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html" title="type parameter in KGroupedStream">V</a>&gt;</code></td>
<td class="colLast"><code><strong><a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html#reduce(org.apache.kafka.streams.kstream.Reducer)">reduce</a></strong>(<a href="../../../../../org/apache/kafka/streams/kstream/Reducer.html" title="interface in org.apache.kafka.streams.kstream">Reducer</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html" title="type parameter in KGroupedStream">V</a>&gt;&nbsp;reducer)</code>
<div class="block">Combine the values of records in this stream by the grouped key.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/Windowed.html" title="class in org.apache.kafka.streams.kstream">Windowed</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html" title="type parameter in KGroupedStream">K</a>&gt;,<a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html" title="type parameter in KGroupedStream">V</a>&gt;</code></td>
<td class="colLast"><code><strong><a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html#reduce(org.apache.kafka.streams.kstream.Reducer,%20org.apache.kafka.streams.kstream.SessionWindows)">reduce</a></strong>(<a href="../../../../../org/apache/kafka/streams/kstream/Reducer.html" title="interface in org.apache.kafka.streams.kstream">Reducer</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html" title="type parameter in KGroupedStream">V</a>&gt;&nbsp;reducer,
      <a href="../../../../../org/apache/kafka/streams/kstream/SessionWindows.html" title="class in org.apache.kafka.streams.kstream">SessionWindows</a>&nbsp;sessionWindows)</code>
<div class="block">Combine values of this stream by the grouped key into <a href="../../../../../org/apache/kafka/streams/kstream/SessionWindows.html" title="class in org.apache.kafka.streams.kstream"><code>SessionWindows</code></a>.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/Windowed.html" title="class in org.apache.kafka.streams.kstream">Windowed</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html" title="type parameter in KGroupedStream">K</a>&gt;,<a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html" title="type parameter in KGroupedStream">V</a>&gt;</code></td>
<td class="colLast"><code><strong><a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html#reduce(org.apache.kafka.streams.kstream.Reducer,%20org.apache.kafka.streams.kstream.SessionWindows,%20org.apache.kafka.streams.processor.StateStoreSupplier)">reduce</a></strong>(<a href="../../../../../org/apache/kafka/streams/kstream/Reducer.html" title="interface in org.apache.kafka.streams.kstream">Reducer</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html" title="type parameter in KGroupedStream">V</a>&gt;&nbsp;reducer,
      <a href="../../../../../org/apache/kafka/streams/kstream/SessionWindows.html" title="class in org.apache.kafka.streams.kstream">SessionWindows</a>&nbsp;sessionWindows,
      <a href="../../../../../org/apache/kafka/streams/processor/StateStoreSupplier.html" title="interface in org.apache.kafka.streams.processor">StateStoreSupplier</a>&lt;<a href="../../../../../org/apache/kafka/streams/state/SessionStore.html" title="interface in org.apache.kafka.streams.state">SessionStore</a>&gt;&nbsp;storeSupplier)</code>
<div class="block">Combine values of this stream by the grouped key into <a href="../../../../../org/apache/kafka/streams/kstream/SessionWindows.html" title="class in org.apache.kafka.streams.kstream"><code>SessionWindows</code></a>.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/Windowed.html" title="class in org.apache.kafka.streams.kstream">Windowed</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html" title="type parameter in KGroupedStream">K</a>&gt;,<a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html" title="type parameter in KGroupedStream">V</a>&gt;</code></td>
<td class="colLast"><code><strong><a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html#reduce(org.apache.kafka.streams.kstream.Reducer,%20org.apache.kafka.streams.kstream.SessionWindows,%20java.lang.String)">reduce</a></strong>(<a href="../../../../../org/apache/kafka/streams/kstream/Reducer.html" title="interface in org.apache.kafka.streams.kstream">Reducer</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html" title="type parameter in KGroupedStream">V</a>&gt;&nbsp;reducer,
      <a href="../../../../../org/apache/kafka/streams/kstream/SessionWindows.html" title="class in org.apache.kafka.streams.kstream">SessionWindows</a>&nbsp;sessionWindows,
      java.lang.String&nbsp;queryableStoreName)</code>
<div class="block">Combine values of this stream by the grouped key into <a href="../../../../../org/apache/kafka/streams/kstream/SessionWindows.html" title="class in org.apache.kafka.streams.kstream"><code>SessionWindows</code></a>.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html" title="type parameter in KGroupedStream">K</a>,<a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html" title="type parameter in KGroupedStream">V</a>&gt;</code></td>
<td class="colLast"><code><strong><a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html#reduce(org.apache.kafka.streams.kstream.Reducer,%20org.apache.kafka.streams.processor.StateStoreSupplier)">reduce</a></strong>(<a href="../../../../../org/apache/kafka/streams/kstream/Reducer.html" title="interface in org.apache.kafka.streams.kstream">Reducer</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html" title="type parameter in KGroupedStream">V</a>&gt;&nbsp;reducer,
      <a href="../../../../../org/apache/kafka/streams/processor/StateStoreSupplier.html" title="interface in org.apache.kafka.streams.processor">StateStoreSupplier</a>&lt;<a href="../../../../../org/apache/kafka/streams/state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state">KeyValueStore</a>&gt;&nbsp;storeSupplier)</code>
<div class="block">Combine the value of records in this stream by the grouped key.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html" title="type parameter in KGroupedStream">K</a>,<a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html" title="type parameter in KGroupedStream">V</a>&gt;</code></td>
<td class="colLast"><code><strong><a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html#reduce(org.apache.kafka.streams.kstream.Reducer,%20java.lang.String)">reduce</a></strong>(<a href="../../../../../org/apache/kafka/streams/kstream/Reducer.html" title="interface in org.apache.kafka.streams.kstream">Reducer</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html" title="type parameter in KGroupedStream">V</a>&gt;&nbsp;reducer,
      java.lang.String&nbsp;queryableStoreName)</code>
<div class="block">Combine the values of records in this stream by the grouped key.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>&lt;W extends <a href="../../../../../org/apache/kafka/streams/kstream/Window.html" title="class in org.apache.kafka.streams.kstream">Window</a>&gt;&nbsp;<br><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/Windowed.html" title="class in org.apache.kafka.streams.kstream">Windowed</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html" title="type parameter in KGroupedStream">K</a>&gt;,<a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html" title="type parameter in KGroupedStream">V</a>&gt;</code></td>
<td class="colLast"><code><strong><a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html#reduce(org.apache.kafka.streams.kstream.Reducer,%20org.apache.kafka.streams.kstream.Windows)">reduce</a></strong>(<a href="../../../../../org/apache/kafka/streams/kstream/Reducer.html" title="interface in org.apache.kafka.streams.kstream">Reducer</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html" title="type parameter in KGroupedStream">V</a>&gt;&nbsp;reducer,
      <a href="../../../../../org/apache/kafka/streams/kstream/Windows.html" title="class in org.apache.kafka.streams.kstream">Windows</a>&lt;W&gt;&nbsp;windows)</code>
<div class="block">Combine the number of records in this stream by the grouped key and the defined windows.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>&lt;W extends <a href="../../../../../org/apache/kafka/streams/kstream/Window.html" title="class in org.apache.kafka.streams.kstream">Window</a>&gt;&nbsp;<br><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/Windowed.html" title="class in org.apache.kafka.streams.kstream">Windowed</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html" title="type parameter in KGroupedStream">K</a>&gt;,<a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html" title="type parameter in KGroupedStream">V</a>&gt;</code></td>
<td class="colLast"><code><strong><a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html#reduce(org.apache.kafka.streams.kstream.Reducer,%20org.apache.kafka.streams.kstream.Windows,%20org.apache.kafka.streams.processor.StateStoreSupplier)">reduce</a></strong>(<a href="../../../../../org/apache/kafka/streams/kstream/Reducer.html" title="interface in org.apache.kafka.streams.kstream">Reducer</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html" title="type parameter in KGroupedStream">V</a>&gt;&nbsp;reducer,
      <a href="../../../../../org/apache/kafka/streams/kstream/Windows.html" title="class in org.apache.kafka.streams.kstream">Windows</a>&lt;W&gt;&nbsp;windows,
      <a href="../../../../../org/apache/kafka/streams/processor/StateStoreSupplier.html" title="interface in org.apache.kafka.streams.processor">StateStoreSupplier</a>&lt;<a href="../../../../../org/apache/kafka/streams/state/WindowStore.html" title="interface in org.apache.kafka.streams.state">WindowStore</a>&gt;&nbsp;storeSupplier)</code>
<div class="block">Combine the values of records in this stream by the grouped key and the defined windows.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>&lt;W extends <a href="../../../../../org/apache/kafka/streams/kstream/Window.html" title="class in org.apache.kafka.streams.kstream">Window</a>&gt;&nbsp;<br><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/Windowed.html" title="class in org.apache.kafka.streams.kstream">Windowed</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html" title="type parameter in KGroupedStream">K</a>&gt;,<a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html" title="type parameter in KGroupedStream">V</a>&gt;</code></td>
<td class="colLast"><code><strong><a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html#reduce(org.apache.kafka.streams.kstream.Reducer,%20org.apache.kafka.streams.kstream.Windows,%20java.lang.String)">reduce</a></strong>(<a href="../../../../../org/apache/kafka/streams/kstream/Reducer.html" title="interface in org.apache.kafka.streams.kstream">Reducer</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html" title="type parameter in KGroupedStream">V</a>&gt;&nbsp;reducer,
      <a href="../../../../../org/apache/kafka/streams/kstream/Windows.html" title="class in org.apache.kafka.streams.kstream">Windows</a>&lt;W&gt;&nbsp;windows,
      java.lang.String&nbsp;queryableStoreName)</code>
<div class="block">Combine the number of records in this stream by the grouped key and the defined windows.</div>
</td>
</tr>
</table>
</li>
</ul>
</li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ============ METHOD DETAIL ========== -->
<ul class="blockList">
<li class="blockList"><a name="method_detail">
<!--   -->
</a>
<h3>Method Detail</h3>
<a name="count(java.lang.String)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>count</h4>
<pre><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html" title="type parameter in KGroupedStream">K</a>,java.lang.Long&gt;&nbsp;count(java.lang.String&nbsp;queryableStoreName)</pre>
<div class="block">Count the number of records in this stream by the grouped key.
 Records with <code>null</code> key or value are ignored.
 The result is written into a local <a href="../../../../../org/apache/kafka/streams/state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state"><code>KeyValueStore</code></a> (which is basically an ever-updating materialized view)
 that can be queried using the provided <code>queryableStoreName</code>.
 Furthermore, updates to the store are sent downstream into a <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> changelog stream.
 <p>
 Not all updates might get sent downstream, as an internal cache is used to deduplicate consecutive updates to
 the same key.
 The rate of propagated updates depends on your input data rate, the number of distinct keys, the number of
 parallel running Kafka Streams instances, and the <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html" title="class in org.apache.kafka.streams"><code>configuration</code></a> parameters for
 <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html#CACHE_MAX_BYTES_BUFFERING_CONFIG"><code>cache size</code></a>, and
 <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html#COMMIT_INTERVAL_MS_CONFIG"><code>commit intervall</code></a>.
 <p>
 To query the local <a href="../../../../../org/apache/kafka/streams/state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state"><code>KeyValueStore</code></a> it must be obtained via
 <a href="../../../../../org/apache/kafka/streams/KafkaStreams.html#store(java.lang.String,%20org.apache.kafka.streams.state.QueryableStoreType)"><code>KafkaStreams#store(...)</code></a>:
 <pre class="line-numbers"><code>KafkaStreams streams = ... // counting words
 ReadOnlyKeyValueStore&lt;String,Long&gt; localStore = streams.store(queryableStoreName, QueryableStoreTypes.&lt;String, Long&gt;keyValueStore());
 String key = "some-word";
 Long countForWord = localStore.get(key); // key must be local (application state is shared over all running Kafka Streams instances)
 </code></pre>
 For non-local keys, a custom RPC mechanism must be implemented using <a href="../../../../../org/apache/kafka/streams/KafkaStreams.html#allMetadata()"><code>KafkaStreams.allMetadata()</code></a> to
 query the value of the key on a parallel running instance of your Kafka Streams application.
 <p>
 For failure and recovery the store will be backed by an internal changelog topic that will be created in Kafka.
 Therefore, the store name must be a valid Kafka topic name and cannot contain characters other than ASCII
 alphanumerics, '.', '_' and '-'.
 The changelog topic will be named "${applicationId}-${queryableStoreName}-changelog", where "applicationId" is
 user-specified in <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html" title="class in org.apache.kafka.streams"><code>StreamsConfig</code></a> via parameter
 <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html#APPLICATION_ID_CONFIG"><code>APPLICATION_ID_CONFIG</code></a>, "queryableStoreName" is the
 provide <code>queryableStoreName</code>, and "-changelog" is a fixed suffix.
 You can retrieve all generated internal topic names via <a href="../../../../../org/apache/kafka/streams/KafkaStreams.html#toString()"><code>KafkaStreams.toString()</code></a>.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>queryableStoreName</code> - the name of the underlying <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> state store; valid characters are ASCII
 alphanumerics, '.', '_' and '-'. If <code>null</code> then this will be equivalent to <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html#count()"><code>count()</code></a>.</dd>
<dt><span class="strong">Returns:</span></dt><dd>a <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> that contains "update" records with unmodified keys and <code>Long</code> values that
 represent the latest (rolling) count (i.e., number of records) for each key</dd></dl>
</li>
</ul>
<a name="count()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>count</h4>
<pre><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html" title="type parameter in KGroupedStream">K</a>,java.lang.Long&gt;&nbsp;count()</pre>
<div class="block">Count the number of records in this stream by the grouped key.
 Records with <code>null</code> key or value are ignored.
 The result is written into a local <a href="../../../../../org/apache/kafka/streams/state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state"><code>KeyValueStore</code></a> (which is basically an ever-updating materialized view).
 Furthermore, updates to the store are sent downstream into a <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> changelog stream.
 <p>
 Not all updates might get sent downstream, as an internal cache is used to deduplicate consecutive updates to
 the same key.
 The rate of propagated updates depends on your input data rate, the number of distinct keys, the number of
 parallel running Kafka Streams instances, and the <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html" title="class in org.apache.kafka.streams"><code>configuration</code></a> parameters for
 <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html#CACHE_MAX_BYTES_BUFFERING_CONFIG"><code>cache size</code></a>, and
 <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html#COMMIT_INTERVAL_MS_CONFIG"><code>commit intervall</code></a>.
 <p>
 For failure and recovery the store will be backed by an internal changelog topic that will be created in Kafka.
 The changelog topic will be named "${applicationId}-${internalStoreName}-changelog", where "applicationId" is
 user-specified in <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html" title="class in org.apache.kafka.streams"><code>StreamsConfig</code></a> via parameter
 <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html#APPLICATION_ID_CONFIG"><code>APPLICATION_ID_CONFIG</code></a>, "internalStoreName" is an internal name
 and "-changelog" is a fixed suffix.
 Note that the internal store name may not be queriable through Interactive Queries.
 You can retrieve all generated internal topic names via <a href="../../../../../org/apache/kafka/streams/KafkaStreams.html#toString()"><code>KafkaStreams.toString()</code></a>.</div>
<dl><dt><span class="strong">Returns:</span></dt><dd>a <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> that contains "update" records with unmodified keys and <code>Long</code> values that
 represent the latest (rolling) count (i.e., number of records) for each key</dd></dl>
</li>
</ul>
<a name="count(org.apache.kafka.streams.processor.StateStoreSupplier)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>count</h4>
<pre><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html" title="type parameter in KGroupedStream">K</a>,java.lang.Long&gt;&nbsp;count(<a href="../../../../../org/apache/kafka/streams/processor/StateStoreSupplier.html" title="interface in org.apache.kafka.streams.processor">StateStoreSupplier</a>&lt;<a href="../../../../../org/apache/kafka/streams/state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state">KeyValueStore</a>&gt;&nbsp;storeSupplier)</pre>
<div class="block">Count the number of records in this stream by the grouped key.
 Records with <code>null</code> key or value are ignored.
 The result is written into a local <a href="../../../../../org/apache/kafka/streams/state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state"><code>KeyValueStore</code></a> (which is basically an ever-updating materialized view)
 provided by the given <code>storeSupplier</code>.
 Furthermore, updates to the store are sent downstream into a <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> changelog stream.
 <p>
 Not all updates might get sent downstream, as an internal cache is used to deduplicate consecutive updates to
 the same key.
 The rate of propagated updates depends on your input data rate, the number of distinct keys, the number of
 parallel running Kafka Streams instances, and the <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html" title="class in org.apache.kafka.streams"><code>configuration</code></a> parameters for
 <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html#CACHE_MAX_BYTES_BUFFERING_CONFIG"><code>cache size</code></a>, and
 <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html#COMMIT_INTERVAL_MS_CONFIG"><code>commit intervall</code></a>.
 <p>
 To query the local <a href="../../../../../org/apache/kafka/streams/state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state"><code>KeyValueStore</code></a> it must be obtained via
 <a href="../../../../../org/apache/kafka/streams/KafkaStreams.html#store(java.lang.String,%20org.apache.kafka.streams.state.QueryableStoreType)"><code>KafkaStreams#store(...)</code></a>.
 Use <a href="../../../../../org/apache/kafka/streams/processor/StateStoreSupplier.html#name()"><code>StateStoreSupplier.name()</code></a> to get the store name:
 <pre class="line-numbers"><code>KafkaStreams streams = ... // counting words
 String queryableStoreName = storeSupplier.name();
 ReadOnlyKeyValueStore&lt;String,Long&gt; localStore = streams.store(queryableStoreName, QueryableStoreTypes.&lt;String, Long&gt;keyValueStore());
 String key = "some-word";
 Long countForWord = localStore.get(key); // key must be local (application state is shared over all running Kafka Streams instances)
 </code></pre>
 For non-local keys, a custom RPC mechanism must be implemented using <a href="../../../../../org/apache/kafka/streams/KafkaStreams.html#allMetadata()"><code>KafkaStreams.allMetadata()</code></a> to
 query the value of the key on a parallel running instance of your Kafka Streams application.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>storeSupplier</code> - user defined state store supplier. Cannot be <code>null</code>.</dd>
<dt><span class="strong">Returns:</span></dt><dd>a <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> that contains "update" records with unmodified keys and <code>Long</code> values that
 represent the latest (rolling) count (i.e., number of records) for each key</dd></dl>
</li>
</ul>
<a name="count(org.apache.kafka.streams.kstream.Windows, java.lang.String)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>count</h4>
<pre>&lt;W extends <a href="../../../../../org/apache/kafka/streams/kstream/Window.html" title="class in org.apache.kafka.streams.kstream">Window</a>&gt;&nbsp;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/Windowed.html" title="class in org.apache.kafka.streams.kstream">Windowed</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html" title="type parameter in KGroupedStream">K</a>&gt;,java.lang.Long&gt;&nbsp;count(<a href="../../../../../org/apache/kafka/streams/kstream/Windows.html" title="class in org.apache.kafka.streams.kstream">Windows</a>&lt;W&gt;&nbsp;windows,
                                                          java.lang.String&nbsp;queryableStoreName)</pre>
<div class="block">Count the number of records in this stream by the grouped key and the defined windows.
 Records with <code>null</code> key or value are ignored.
 The specified <code>windows</code> define either hopping time windows that can be overlapping or tumbling (c.f.
 <a href="../../../../../org/apache/kafka/streams/kstream/TimeWindows.html" title="class in org.apache.kafka.streams.kstream"><code>TimeWindows</code></a>) or they define landmark windows (c.f. <a href="../../../../../org/apache/kafka/streams/kstream/UnlimitedWindows.html" title="class in org.apache.kafka.streams.kstream"><code>UnlimitedWindows</code></a>).
 The result is written into a local windowed <a href="../../../../../org/apache/kafka/streams/state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state"><code>KeyValueStore</code></a> (which is basically an ever-updating
 materialized view) that can be queried using the provided <code>queryableStoreName</code>.
 Windows are retained until their retention time expires (c.f. <a href="../../../../../org/apache/kafka/streams/kstream/Windows.html#until(long)"><code>Windows.until(long)</code></a>).
 Furthermore, updates to the store are sent downstream into a windowed <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> changelog stream, where
 "windowed" implies that the <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> key is a combined key of the original record key and a window ID.
 <p>
 Not all updates might get sent downstream, as an internal cache is used to deduplicate consecutive updates to
 the same window and key.
 The rate of propagated updates depends on your input data rate, the number of distinct keys, the number of
 parallel running Kafka Streams instances, and the <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html" title="class in org.apache.kafka.streams"><code>configuration</code></a> parameters for
 <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html#CACHE_MAX_BYTES_BUFFERING_CONFIG"><code>cache size</code></a>, and
 <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html#COMMIT_INTERVAL_MS_CONFIG"><code>commit intervall</code></a>.
 <p>
 To query the local windowed <a href="../../../../../org/apache/kafka/streams/state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state"><code>KeyValueStore</code></a> it must be obtained via
 <a href="../../../../../org/apache/kafka/streams/KafkaStreams.html#store(java.lang.String,%20org.apache.kafka.streams.state.QueryableStoreType)"><code>KafkaStreams#store(...)</code></a>:
 <pre class="line-numbers"><code>KafkaStreams streams = ... // counting words
 ReadOnlyWindowStore&lt;String,Long&gt; localWindowStore = streams.store(queryableStoreName, QueryableStoreTypes.&lt;String, Long&gt;windowStore());
 String key = "some-word";
 long fromTime = ...;
 long toTime = ...;
 WindowStoreIterator&lt;Long&gt; countForWordsForWindows = localWindowStore.fetch(key, timeFrom, timeTo); // key must be local (application state is shared over all running Kafka Streams instances)
 </code></pre>
 For non-local keys, a custom RPC mechanism must be implemented using <a href="../../../../../org/apache/kafka/streams/KafkaStreams.html#allMetadata()"><code>KafkaStreams.allMetadata()</code></a> to
 query the value of the key on a parallel running instance of your Kafka Streams application.
 <p>
 For failure and recovery the store will be backed by an internal changelog topic that will be created in Kafka.
 Therefore, the store name must be a valid Kafka topic name and cannot contain characters other than ASCII
 alphanumerics, '.', '_' and '-'.
 The changelog topic will be named "${applicationId}-${queryableStoreName}-changelog", where "applicationId" is
 user-specified in <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html" title="class in org.apache.kafka.streams"><code>StreamsConfig</code></a> via parameter
 <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html#APPLICATION_ID_CONFIG"><code>APPLICATION_ID_CONFIG</code></a>, "queryableStoreName" is the
 provide <code>queryableStoreName</code>, and "-changelog" is a fixed suffix.
 You can retrieve all generated internal topic names via <a href="../../../../../org/apache/kafka/streams/KafkaStreams.html#toString()"><code>KafkaStreams.toString()</code></a>.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>windows</code> - the specification of the aggregation <a href="../../../../../org/apache/kafka/streams/kstream/Windows.html" title="class in org.apache.kafka.streams.kstream"><code>Windows</code></a></dd><dd><code>queryableStoreName</code> - the name of the underlying <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> state store; valid characters are ASCII
 alphanumerics, '.', '_' and '-'. If <code>null</code> then this will be equivalent to <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html#count(org.apache.kafka.streams.kstream.Windows)"><code>count(Windows)</code></a>.</dd>
<dt><span class="strong">Returns:</span></dt><dd>a windowed <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> that contains "update" records with unmodified keys and <code>Long</code> values
 that represent the latest (rolling) count (i.e., number of records) for each key within a window</dd></dl>
</li>
</ul>
<a name="count(org.apache.kafka.streams.kstream.Windows)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>count</h4>
<pre>&lt;W extends <a href="../../../../../org/apache/kafka/streams/kstream/Window.html" title="class in org.apache.kafka.streams.kstream">Window</a>&gt;&nbsp;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/Windowed.html" title="class in org.apache.kafka.streams.kstream">Windowed</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html" title="type parameter in KGroupedStream">K</a>&gt;,java.lang.Long&gt;&nbsp;count(<a href="../../../../../org/apache/kafka/streams/kstream/Windows.html" title="class in org.apache.kafka.streams.kstream">Windows</a>&lt;W&gt;&nbsp;windows)</pre>
<div class="block">Count the number of records in this stream by the grouped key and the defined windows.
 Records with <code>null</code> key or value are ignored.
 The specified <code>windows</code> define either hopping time windows that can be overlapping or tumbling (c.f.
 <a href="../../../../../org/apache/kafka/streams/kstream/TimeWindows.html" title="class in org.apache.kafka.streams.kstream"><code>TimeWindows</code></a>) or they define landmark windows (c.f. <a href="../../../../../org/apache/kafka/streams/kstream/UnlimitedWindows.html" title="class in org.apache.kafka.streams.kstream"><code>UnlimitedWindows</code></a>).
 The result is written into a local windowed <a href="../../../../../org/apache/kafka/streams/state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state"><code>KeyValueStore</code></a> (which is basically an ever-updating
 materialized view) that can be queried using the provided <code>queryableName</code>.
 Windows are retained until their retention time expires (c.f. <a href="../../../../../org/apache/kafka/streams/kstream/Windows.html#until(long)"><code>Windows.until(long)</code></a>).
 Furthermore, updates to the store are sent downstream into a windowed <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> changelog stream, where
 "windowed" implies that the <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> key is a combined key of the original record key and a window ID.
 <p>
 Not all updates might get sent downstream, as an internal cache is used to deduplicate consecutive updates to
 the same window and key.
 The rate of propagated updates depends on your input data rate, the number of distinct keys, the number of
 parallel running Kafka Streams instances, and the <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html" title="class in org.apache.kafka.streams"><code>configuration</code></a> parameters for
 <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html#CACHE_MAX_BYTES_BUFFERING_CONFIG"><code>cache size</code></a>, and
 <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html#COMMIT_INTERVAL_MS_CONFIG"><code>commit intervall</code></a>.
 <p>
 For failure and recovery the store will be backed by an internal changelog topic that will be created in Kafka.
 The changelog topic will be named "${applicationId}-${internalStoreName}-changelog", where "applicationId" is
 user-specified in <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html" title="class in org.apache.kafka.streams"><code>StreamsConfig</code></a> via parameter
 <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html#APPLICATION_ID_CONFIG"><code>APPLICATION_ID_CONFIG</code></a>, "internalStoreName" is an internal name
 and "-changelog" is a fixed suffix.
 Note that the internal store name may not be queriable through Interactive Queries.
 You can retrieve all generated internal topic names via <a href="../../../../../org/apache/kafka/streams/KafkaStreams.html#toString()"><code>KafkaStreams.toString()</code></a>.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>windows</code> - the specification of the aggregation <a href="../../../../../org/apache/kafka/streams/kstream/Windows.html" title="class in org.apache.kafka.streams.kstream"><code>Windows</code></a></dd>
<dt><span class="strong">Returns:</span></dt><dd>a windowed <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> that contains "update" records with unmodified keys and <code>Long</code> values
 that represent the latest (rolling) count (i.e., number of records) for each key within a window</dd></dl>
</li>
</ul>
<a name="count(org.apache.kafka.streams.kstream.Windows, org.apache.kafka.streams.processor.StateStoreSupplier)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>count</h4>
<pre>&lt;W extends <a href="../../../../../org/apache/kafka/streams/kstream/Window.html" title="class in org.apache.kafka.streams.kstream">Window</a>&gt;&nbsp;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/Windowed.html" title="class in org.apache.kafka.streams.kstream">Windowed</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html" title="type parameter in KGroupedStream">K</a>&gt;,java.lang.Long&gt;&nbsp;count(<a href="../../../../../org/apache/kafka/streams/kstream/Windows.html" title="class in org.apache.kafka.streams.kstream">Windows</a>&lt;W&gt;&nbsp;windows,
                                                          <a href="../../../../../org/apache/kafka/streams/processor/StateStoreSupplier.html" title="interface in org.apache.kafka.streams.processor">StateStoreSupplier</a>&lt;<a href="../../../../../org/apache/kafka/streams/state/WindowStore.html" title="interface in org.apache.kafka.streams.state">WindowStore</a>&gt;&nbsp;storeSupplier)</pre>
<div class="block">Count the number of records in this stream by the grouped key and the defined windows.
 Records with <code>null</code> key or value are ignored.
 The specified <code>windows</code> define either hopping time windows that can be overlapping or tumbling (c.f.
 <a href="../../../../../org/apache/kafka/streams/kstream/TimeWindows.html" title="class in org.apache.kafka.streams.kstream"><code>TimeWindows</code></a>) or they define landmark windows (c.f. <a href="../../../../../org/apache/kafka/streams/kstream/UnlimitedWindows.html" title="class in org.apache.kafka.streams.kstream"><code>UnlimitedWindows</code></a>).
 The result is written into a local windowed <a href="../../../../../org/apache/kafka/streams/state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state"><code>KeyValueStore</code></a> (which is basically an ever-updating
 materialized view) provided by the given <code>storeSupplier</code>.
 Windows are retained until their retention time expires (c.f. <a href="../../../../../org/apache/kafka/streams/kstream/Windows.html#until(long)"><code>Windows.until(long)</code></a>).
 Furthermore, updates to the store are sent downstream into a windowed <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> changelog stream, where
 "windowed" implies that the <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> key is a combined key of the original record key and a window ID.
 <p>
 Not all updates might get sent downstream, as an internal cache is used to deduplicate consecutive updates to
 the same window and key.
 The rate of propagated updates depends on your input data rate, the number of distinct keys, the number of
 parallel running Kafka Streams instances, and the <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html" title="class in org.apache.kafka.streams"><code>configuration</code></a> parameters for
 <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html#CACHE_MAX_BYTES_BUFFERING_CONFIG"><code>cache size</code></a>, and
 <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html#COMMIT_INTERVAL_MS_CONFIG"><code>commit intervall</code></a>.
 <p>
 To query the local windowed <a href="../../../../../org/apache/kafka/streams/state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state"><code>KeyValueStore</code></a> it must be obtained via
 <a href="../../../../../org/apache/kafka/streams/KafkaStreams.html#store(java.lang.String,%20org.apache.kafka.streams.state.QueryableStoreType)"><code>KafkaStreams#store(...)</code></a>.
 Use <a href="../../../../../org/apache/kafka/streams/processor/StateStoreSupplier.html#name()"><code>StateStoreSupplier.name()</code></a> to get the store name:
 <pre class="line-numbers"><code>KafkaStreams streams = ... // counting words
 String queryableStoreName = storeSupplier.name();
 ReadOnlyWindowStore&lt;String,Long&gt; localWindowStore = streams.store(queryableName, QueryableStoreTypes.&lt;String, Long&gt;windowStore());
 String key = "some-word";
 long fromTime = ...;
 long toTime = ...;
 WindowStoreIterator&lt;Long&gt; countForWordsForWindows = localWindowStore.fetch(key, timeFrom, timeTo); // key must be local (application state is shared over all running Kafka Streams instances)
 </code></pre>
 For non-local keys, a custom RPC mechanism must be implemented using <a href="../../../../../org/apache/kafka/streams/KafkaStreams.html#allMetadata()"><code>KafkaStreams.allMetadata()</code></a> to
 query the value of the key on a parallel running instance of your Kafka Streams application.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>windows</code> - the specification of the aggregation <a href="../../../../../org/apache/kafka/streams/kstream/Windows.html" title="class in org.apache.kafka.streams.kstream"><code>Windows</code></a></dd><dd><code>storeSupplier</code> - user defined state store supplier. Cannot be <code>null</code>.</dd>
<dt><span class="strong">Returns:</span></dt><dd>a windowed <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> that contains "update" records with unmodified keys and <code>Long</code> values
 that represent the latest (rolling) count (i.e., number of records) for each key within a window</dd></dl>
</li>
</ul>
<a name="count(org.apache.kafka.streams.kstream.SessionWindows, java.lang.String)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>count</h4>
<pre><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/Windowed.html" title="class in org.apache.kafka.streams.kstream">Windowed</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html" title="type parameter in KGroupedStream">K</a>&gt;,java.lang.Long&gt;&nbsp;count(<a href="../../../../../org/apache/kafka/streams/kstream/SessionWindows.html" title="class in org.apache.kafka.streams.kstream">SessionWindows</a>&nbsp;sessionWindows,
                                       java.lang.String&nbsp;queryableStoreName)</pre>
<div class="block">Count the number of records in this stream by the grouped key into <a href="../../../../../org/apache/kafka/streams/kstream/SessionWindows.html" title="class in org.apache.kafka.streams.kstream"><code>SessionWindows</code></a>.
 Records with <code>null</code> key or value are ignored.
 The result is written into a local <a href="../../../../../org/apache/kafka/streams/state/SessionStore.html" title="interface in org.apache.kafka.streams.state"><code>SessionStore</code></a> (which is basically an ever-updating
 materialized view) that can be queried using the provided <code>queryableStoreName</code>.
 SessionWindows are retained until their retention time expires (c.f. <a href="../../../../../org/apache/kafka/streams/kstream/SessionWindows.html#until(long)"><code>SessionWindows.until(long)</code></a>).
 Furthermore, updates to the store are sent downstream into a windowed <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> changelog stream, where
 "windowed" implies that the <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> key is a combined key of the original record key and a window ID.
 <p>
 Not all updates might get sent downstream, as an internal cache is used to deduplicate consecutive updates to
 the same window and key.
 The rate of propagated updates depends on your input data rate, the number of distinct keys, the number of
 parallel running Kafka Streams instances, and the <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html" title="class in org.apache.kafka.streams"><code>configuration</code></a> parameters for
 <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html#CACHE_MAX_BYTES_BUFFERING_CONFIG"><code>cache size</code></a>, and
 <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html#COMMIT_INTERVAL_MS_CONFIG"><code>commit intervall</code></a>.
 <p>
 To query the local windowed <a href="../../../../../org/apache/kafka/streams/state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state"><code>KeyValueStore</code></a> it must be obtained via
 <a href="../../../../../org/apache/kafka/streams/KafkaStreams.html#store(java.lang.String,%20org.apache.kafka.streams.state.QueryableStoreType)"><code>KafkaStreams#store(...)</code></a>.
 Use <a href="../../../../../org/apache/kafka/streams/processor/StateStoreSupplier.html#name()"><code>StateStoreSupplier.name()</code></a> to get the store name:
 <pre class="line-numbers"><code>KafkaStreams streams = ... // compute sum
 Sting queryableStoreName = storeSupplier.name();
 ReadOnlySessionStore&lt;String,Long&gt; localWindowStore = streams.store(queryableStoreName, QueryableStoreTypes.&lt;String, Long&gt;ReadOnlySessionStore&lt;String, Long&gt;);
 String key = "some-key";
 KeyValueIterator&lt;Windowed&lt;String&gt;, Long&gt; sumForKeyForWindows = localWindowStore.fetch(key); // key must be local (application state is shared over all running Kafka Streams instances)
 </code></pre>
 For non-local keys, a custom RPC mechanism must be implemented using <a href="../../../../../org/apache/kafka/streams/KafkaStreams.html#allMetadata()"><code>KafkaStreams.allMetadata()</code></a> to
 query the value of the key on a parallel running instance of your Kafka Streams application.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>sessionWindows</code> - the specification of the aggregation <a href="../../../../../org/apache/kafka/streams/kstream/SessionWindows.html" title="class in org.apache.kafka.streams.kstream"><code>SessionWindows</code></a></dd><dd><code>queryableStoreName</code> - the name of the state store created from this operation; valid characters are ASCII
 alphanumerics, '.', '_' and '-. If <code>null</code> then this will be equivalent to <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html#count(org.apache.kafka.streams.kstream.SessionWindows)"><code>count(SessionWindows)</code></a> ()}.</dd>
<dt><span class="strong">Returns:</span></dt><dd>a windowed <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> that contains "update" records with unmodified keys and <code>Long</code> values
 that represent the latest (rolling) count (i.e., number of records) for each key within a window</dd></dl>
</li>
</ul>
<a name="count(org.apache.kafka.streams.kstream.SessionWindows)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>count</h4>
<pre><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/Windowed.html" title="class in org.apache.kafka.streams.kstream">Windowed</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html" title="type parameter in KGroupedStream">K</a>&gt;,java.lang.Long&gt;&nbsp;count(<a href="../../../../../org/apache/kafka/streams/kstream/SessionWindows.html" title="class in org.apache.kafka.streams.kstream">SessionWindows</a>&nbsp;sessionWindows)</pre>
<div class="block">Count the number of records in this stream by the grouped key into <a href="../../../../../org/apache/kafka/streams/kstream/SessionWindows.html" title="class in org.apache.kafka.streams.kstream"><code>SessionWindows</code></a>.
 Records with <code>null</code> key or value are ignored.
 The result is written into a local <a href="../../../../../org/apache/kafka/streams/state/SessionStore.html" title="interface in org.apache.kafka.streams.state"><code>SessionStore</code></a> (which is basically an ever-updating
 materialized view) that can be queried using the provided <code>queryableStoreName</code>.
 SessionWindows are retained until their retention time expires (c.f. <a href="../../../../../org/apache/kafka/streams/kstream/SessionWindows.html#until(long)"><code>SessionWindows.until(long)</code></a>).
 Furthermore, updates to the store are sent downstream into a windowed <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> changelog stream, where
 "windowed" implies that the <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> key is a combined key of the original record key and a window ID.
 <p>
 Not all updates might get sent downstream, as an internal cache is used to deduplicate consecutive updates to
 the same window and key.
 The rate of propagated updates depends on your input data rate, the number of distinct keys, the number of
 parallel running Kafka Streams instances, and the <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html" title="class in org.apache.kafka.streams"><code>configuration</code></a> parameters for
 <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html#CACHE_MAX_BYTES_BUFFERING_CONFIG"><code>cache size</code></a>, and
 <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html#COMMIT_INTERVAL_MS_CONFIG"><code>commit intervall</code></a>.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>sessionWindows</code> - the specification of the aggregation <a href="../../../../../org/apache/kafka/streams/kstream/SessionWindows.html" title="class in org.apache.kafka.streams.kstream"><code>SessionWindows</code></a></dd>
<dt><span class="strong">Returns:</span></dt><dd>a windowed <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> that contains "update" records with unmodified keys and <code>Long</code> values
 that represent the latest (rolling) count (i.e., number of records) for each key within a window</dd></dl>
</li>
</ul>
<a name="count(org.apache.kafka.streams.kstream.SessionWindows, org.apache.kafka.streams.processor.StateStoreSupplier)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>count</h4>
<pre><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/Windowed.html" title="class in org.apache.kafka.streams.kstream">Windowed</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html" title="type parameter in KGroupedStream">K</a>&gt;,java.lang.Long&gt;&nbsp;count(<a href="../../../../../org/apache/kafka/streams/kstream/SessionWindows.html" title="class in org.apache.kafka.streams.kstream">SessionWindows</a>&nbsp;sessionWindows,
                                       <a href="../../../../../org/apache/kafka/streams/processor/StateStoreSupplier.html" title="interface in org.apache.kafka.streams.processor">StateStoreSupplier</a>&lt;<a href="../../../../../org/apache/kafka/streams/state/SessionStore.html" title="interface in org.apache.kafka.streams.state">SessionStore</a>&gt;&nbsp;storeSupplier)</pre>
<div class="block">Count the number of records in this stream by the grouped key into <a href="../../../../../org/apache/kafka/streams/kstream/SessionWindows.html" title="class in org.apache.kafka.streams.kstream"><code>SessionWindows</code></a>.
 Records with <code>null</code> key or value are ignored.
 The result is written into a local <a href="../../../../../org/apache/kafka/streams/state/SessionStore.html" title="interface in org.apache.kafka.streams.state"><code>SessionStore</code></a> (which is basically an ever-updating materialized view)
 provided by the given <code>storeSupplier</code>.
 SessionWindows are retained until their retention time expires (c.f. <a href="../../../../../org/apache/kafka/streams/kstream/SessionWindows.html#until(long)"><code>SessionWindows.until(long)</code></a>).
 Furthermore, updates to the store are sent downstream into a windowed <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> changelog stream, where
 "windowed" implies that the <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> key is a combined key of the original record key and a window ID.
 <p>
 Not all updates might get sent downstream, as an internal cache is used to deduplicate consecutive updates to
 the same window and key.
 The rate of propagated updates depends on your input data rate, the number of distinct keys, the number of
 parallel running Kafka Streams instances, and the <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html" title="class in org.apache.kafka.streams"><code>configuration</code></a> parameters for
 <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html#CACHE_MAX_BYTES_BUFFERING_CONFIG"><code>cache size</code></a>, and
 <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html#COMMIT_INTERVAL_MS_CONFIG"><code>commit intervall</code></a>.
 <p>
 To query the local windowed <a href="../../../../../org/apache/kafka/streams/state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state"><code>KeyValueStore</code></a> it must be obtained via
 <a href="../../../../../org/apache/kafka/streams/KafkaStreams.html#store(java.lang.String,%20org.apache.kafka.streams.state.QueryableStoreType)"><code>KafkaStreams#store(...)</code></a>.
 Use <a href="../../../../../org/apache/kafka/streams/processor/StateStoreSupplier.html#name()"><code>StateStoreSupplier.name()</code></a> to get the store name:
 <pre class="line-numbers"><code>KafkaStreams streams = ... // compute sum
 Sting queryableStoreName = storeSupplier.name();
 ReadOnlySessionStore&lt;String,Long&gt; localWindowStore = streams.store(queryableStoreName, QueryableStoreTypes.&lt;String, Long&gt;ReadOnlySessionStore&lt;String, Long&gt;);
 String key = "some-key";
 KeyValueIterator&lt;Windowed&lt;String&gt;, Long&gt; sumForKeyForWindows = localWindowStore.fetch(key); // key must be local (application state is shared over all running Kafka Streams instances)
 </code></pre>
 For non-local keys, a custom RPC mechanism must be implemented using <a href="../../../../../org/apache/kafka/streams/KafkaStreams.html#allMetadata()"><code>KafkaStreams.allMetadata()</code></a> to
 query the value of the key on a parallel running instance of your Kafka Streams application.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>sessionWindows</code> - the specification of the aggregation <a href="../../../../../org/apache/kafka/streams/kstream/SessionWindows.html" title="class in org.apache.kafka.streams.kstream"><code>SessionWindows</code></a></dd><dd><code>storeSupplier</code> - user defined state store supplier. Cannot be <code>null</code>.</dd>
<dt><span class="strong">Returns:</span></dt><dd>a windowed <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> that contains "update" records with unmodified keys and <code>Long</code> values
 that represent the latest (rolling) count (i.e., number of records) for each key within a window</dd></dl>
</li>
</ul>
<a name="reduce(org.apache.kafka.streams.kstream.Reducer)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>reduce</h4>
<pre><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html" title="type parameter in KGroupedStream">K</a>,<a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html" title="type parameter in KGroupedStream">V</a>&gt;&nbsp;reduce(<a href="../../../../../org/apache/kafka/streams/kstream/Reducer.html" title="interface in org.apache.kafka.streams.kstream">Reducer</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html" title="type parameter in KGroupedStream">V</a>&gt;&nbsp;reducer)</pre>
<div class="block">Combine the values of records in this stream by the grouped key.
 Records with <code>null</code> key or value are ignored.
 Combining implies that the type of the aggregate result is the same as the type of the input value
 (c.f. <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html#aggregate(org.apache.kafka.streams.kstream.Initializer,%20org.apache.kafka.streams.kstream.Aggregator,%20org.apache.kafka.common.serialization.Serde,%20java.lang.String)"><code>aggregate(Initializer, Aggregator, Serde, String)</code></a>).
 The result is written into a local <a href="../../../../../org/apache/kafka/streams/state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state"><code>KeyValueStore</code></a> (which is basically an ever-updating materialized view)
 that can be queried using the provided <code>queryableStoreName</code>.
 Furthermore, updates to the store are sent downstream into a <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> changelog stream.
 <p>
 The specified <a href="../../../../../org/apache/kafka/streams/kstream/Reducer.html" title="interface in org.apache.kafka.streams.kstream"><code>Reducer</code></a> is applied for each input record and computes a new aggregate using the current
 aggregate and the record's value.
 If there is no current aggregate the <a href="../../../../../org/apache/kafka/streams/kstream/Reducer.html" title="interface in org.apache.kafka.streams.kstream"><code>Reducer</code></a> is not applied and the new aggregate will be the record's
 value as-is.
 Thus, <code>reduce(Reducer, String)</code> can be used to compute aggregate functions like sum, min, or max.
 <p>
 Not all updates might get sent downstream, as an internal cache is used to deduplicate consecutive updates to
 the same key.
 The rate of propagated updates depends on your input data rate, the number of distinct keys, the number of
 parallel running Kafka Streams instances, and the <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html" title="class in org.apache.kafka.streams"><code>configuration</code></a> parameters for
 <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html#CACHE_MAX_BYTES_BUFFERING_CONFIG"><code>cache size</code></a>, and
 <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html#COMMIT_INTERVAL_MS_CONFIG"><code>commit intervall</code></a>.
 <p>
 For failure and recovery the store will be backed by an internal changelog topic that will be created in Kafka.
 The changelog topic will be named "${applicationId}-${internalStoreName}-changelog", where "applicationId" is
 user-specified in <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html" title="class in org.apache.kafka.streams"><code>StreamsConfig</code></a> via parameter
 <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html#APPLICATION_ID_CONFIG"><code>APPLICATION_ID_CONFIG</code></a>, "internalStoreName" is an internal name
 and "-changelog" is a fixed suffix.
 You can retrieve all generated internal topic names via <a href="../../../../../org/apache/kafka/streams/KafkaStreams.html#toString()"><code>KafkaStreams.toString()</code></a>.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>reducer</code> - a <a href="../../../../../org/apache/kafka/streams/kstream/Reducer.html" title="interface in org.apache.kafka.streams.kstream"><code>Reducer</code></a> that computes a new aggregate result</dd>
<dt><span class="strong">Returns:</span></dt><dd>a <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> that contains "update" records with unmodified keys, and values that represent the
 latest (rolling) aggregate for each key</dd></dl>
</li>
</ul>
<a name="reduce(org.apache.kafka.streams.kstream.Reducer, java.lang.String)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>reduce</h4>
<pre><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html" title="type parameter in KGroupedStream">K</a>,<a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html" title="type parameter in KGroupedStream">V</a>&gt;&nbsp;reduce(<a href="../../../../../org/apache/kafka/streams/kstream/Reducer.html" title="interface in org.apache.kafka.streams.kstream">Reducer</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html" title="type parameter in KGroupedStream">V</a>&gt;&nbsp;reducer,
                 java.lang.String&nbsp;queryableStoreName)</pre>
<div class="block">Combine the values of records in this stream by the grouped key.
 Records with <code>null</code> key or value are ignored.
 Combining implies that the type of the aggregate result is the same as the type of the input value
 (c.f. <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html#aggregate(org.apache.kafka.streams.kstream.Initializer,%20org.apache.kafka.streams.kstream.Aggregator,%20org.apache.kafka.common.serialization.Serde,%20java.lang.String)"><code>aggregate(Initializer, Aggregator, Serde, String)</code></a>).
 The result is written into a local <a href="../../../../../org/apache/kafka/streams/state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state"><code>KeyValueStore</code></a> (which is basically an ever-updating materialized view)
 that can be queried using the provided <code>queryableStoreName</code>.
 Furthermore, updates to the store are sent downstream into a <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> changelog stream.
 <p>
 The specified <a href="../../../../../org/apache/kafka/streams/kstream/Reducer.html" title="interface in org.apache.kafka.streams.kstream"><code>Reducer</code></a> is applied for each input record and computes a new aggregate using the current
 aggregate and the record's value.
 If there is no current aggregate the <a href="../../../../../org/apache/kafka/streams/kstream/Reducer.html" title="interface in org.apache.kafka.streams.kstream"><code>Reducer</code></a> is not applied and the new aggregate will be the record's
 value as-is.
 Thus, <code>reduce(Reducer, String)</code> can be used to compute aggregate functions like sum, min, or max.
 <p>
 Not all updates might get sent downstream, as an internal cache is used to deduplicate consecutive updates to
 the same key.
 The rate of propagated updates depends on your input data rate, the number of distinct keys, the number of
 parallel running Kafka Streams instances, and the <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html" title="class in org.apache.kafka.streams"><code>configuration</code></a> parameters for
 <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html#CACHE_MAX_BYTES_BUFFERING_CONFIG"><code>cache size</code></a>, and
 <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html#COMMIT_INTERVAL_MS_CONFIG"><code>commit intervall</code></a>.
 <p>
 To query the local <a href="../../../../../org/apache/kafka/streams/state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state"><code>KeyValueStore</code></a> it must be obtained via
 <a href="../../../../../org/apache/kafka/streams/KafkaStreams.html#store(java.lang.String,%20org.apache.kafka.streams.state.QueryableStoreType)"><code>KafkaStreams#store(...)</code></a>:
 <pre class="line-numbers"><code>KafkaStreams streams = ... // compute sum
 ReadOnlyKeyValueStore&lt;String,Long&gt; localStore = streams.store(queryableStoreName, QueryableStoreTypes.&lt;String, Long&gt;keyValueStore());
 String key = "some-key";
 Long sumForKey = localStore.get(key); // key must be local (application state is shared over all running Kafka Streams instances)
 </code></pre>
 For non-local keys, a custom RPC mechanism must be implemented using <a href="../../../../../org/apache/kafka/streams/KafkaStreams.html#allMetadata()"><code>KafkaStreams.allMetadata()</code></a> to
 query the value of the key on a parallel running instance of your Kafka Streams application.
 <p>
 For failure and recovery the store will be backed by an internal changelog topic that will be created in Kafka.
 Therefore, the store name must be a valid Kafka topic name and cannot contain characters other than ASCII
 alphanumerics, '.', '_' and '-'.
 The changelog topic will be named "${applicationId}-${queryableStoreName}-changelog", where "applicationId" is
 user-specified in <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html" title="class in org.apache.kafka.streams"><code>StreamsConfig</code></a> via parameter
 <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html#APPLICATION_ID_CONFIG"><code>APPLICATION_ID_CONFIG</code></a>, "queryableStoreName" is the
 provide <code>queryableStoreName</code>, and "-changelog" is a fixed suffix.
 You can retrieve all generated internal topic names via <a href="../../../../../org/apache/kafka/streams/KafkaStreams.html#toString()"><code>KafkaStreams.toString()</code></a>.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>reducer</code> - a <a href="../../../../../org/apache/kafka/streams/kstream/Reducer.html" title="interface in org.apache.kafka.streams.kstream"><code>Reducer</code></a> that computes a new aggregate result</dd><dd><code>queryableStoreName</code> - the name of the underlying <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> state store; valid characters are ASCII
 alphanumerics, '.', '_' and '-'. If <code>null</code> then this will be equivalent to <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html#reduce(org.apache.kafka.streams.kstream.Reducer)"><code>reduce(Reducer)</code></a> ()}.</dd>
<dt><span class="strong">Returns:</span></dt><dd>a <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> that contains "update" records with unmodified keys, and values that represent the
 latest (rolling) aggregate for each key</dd></dl>
</li>
</ul>
<a name="reduce(org.apache.kafka.streams.kstream.Reducer, org.apache.kafka.streams.processor.StateStoreSupplier)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>reduce</h4>
<pre><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html" title="type parameter in KGroupedStream">K</a>,<a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html" title="type parameter in KGroupedStream">V</a>&gt;&nbsp;reduce(<a href="../../../../../org/apache/kafka/streams/kstream/Reducer.html" title="interface in org.apache.kafka.streams.kstream">Reducer</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html" title="type parameter in KGroupedStream">V</a>&gt;&nbsp;reducer,
                 <a href="../../../../../org/apache/kafka/streams/processor/StateStoreSupplier.html" title="interface in org.apache.kafka.streams.processor">StateStoreSupplier</a>&lt;<a href="../../../../../org/apache/kafka/streams/state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state">KeyValueStore</a>&gt;&nbsp;storeSupplier)</pre>
<div class="block">Combine the value of records in this stream by the grouped key.
 Records with <code>null</code> key or value are ignored.
 Combining implies that the type of the aggregate result is the same as the type of the input value
 (c.f. <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html#aggregate(org.apache.kafka.streams.kstream.Initializer,%20org.apache.kafka.streams.kstream.Aggregator,%20org.apache.kafka.streams.processor.StateStoreSupplier)"><code>aggregate(Initializer, Aggregator, StateStoreSupplier)</code></a>).
 The result is written into a local <a href="../../../../../org/apache/kafka/streams/state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state"><code>KeyValueStore</code></a> (which is basically an ever-updating materialized view)
 provided by the given <code>storeSupplier</code>.
 Furthermore, updates to the store are sent downstream into a <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> changelog stream.
 <p>
 The specified <a href="../../../../../org/apache/kafka/streams/kstream/Reducer.html" title="interface in org.apache.kafka.streams.kstream"><code>Reducer</code></a> is applied for each input record and computes a new aggregate using the current
 aggregate and the record's value.
 If there is no current aggregate the <a href="../../../../../org/apache/kafka/streams/kstream/Reducer.html" title="interface in org.apache.kafka.streams.kstream"><code>Reducer</code></a> is not applied and the new aggregate will be the record's
 value as-is.
 Thus, <code>reduce(Reducer, StateStoreSupplier)</code> can be used to compute aggregate functions like sum, min, or
 max.
 <p>
 Not all updates might get sent downstream, as an internal cache is used to deduplicate consecutive updates to
 the same key.
 The rate of propagated updates depends on your input data rate, the number of distinct keys, the number of
 parallel running Kafka Streams instances, and the <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html" title="class in org.apache.kafka.streams"><code>configuration</code></a> parameters for
 <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html#CACHE_MAX_BYTES_BUFFERING_CONFIG"><code>cache size</code></a>, and
 <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html#COMMIT_INTERVAL_MS_CONFIG"><code>commit intervall</code></a>.
 <p>
 To query the local <a href="../../../../../org/apache/kafka/streams/state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state"><code>KeyValueStore</code></a> it must be obtained via
 <a href="../../../../../org/apache/kafka/streams/KafkaStreams.html#store(java.lang.String,%20org.apache.kafka.streams.state.QueryableStoreType)"><code>KafkaStreams#store(...)</code></a>.
 Use <a href="../../../../../org/apache/kafka/streams/processor/StateStoreSupplier.html#name()"><code>StateStoreSupplier.name()</code></a> to get the store name:
 <pre class="line-numbers"><code>KafkaStreams streams = ... // compute sum
 String queryableStoreName = storeSupplier.name();
 ReadOnlyKeyValueStore&lt;String,Long&gt; localStore = streams.store(queryableStoreName, QueryableStoreTypes.&lt;String, Long&gt;keyValueStore());
 String key = "some-key";
 Long sumForKey = localStore.get(key); // key must be local (application state is shared over all running Kafka Streams instances)
 </code></pre>
 For non-local keys, a custom RPC mechanism must be implemented using <a href="../../../../../org/apache/kafka/streams/KafkaStreams.html#allMetadata()"><code>KafkaStreams.allMetadata()</code></a> to
 query the value of the key on a parallel running instance of your Kafka Streams application.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>reducer</code> - a <a href="../../../../../org/apache/kafka/streams/kstream/Reducer.html" title="interface in org.apache.kafka.streams.kstream"><code>Reducer</code></a> that computes a new aggregate result</dd><dd><code>storeSupplier</code> - user defined state store supplier. Cannot be <code>null</code>.</dd>
<dt><span class="strong">Returns:</span></dt><dd>a <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> that contains "update" records with unmodified keys, and values that represent the
 latest (rolling) aggregate for each key</dd></dl>
</li>
</ul>
<a name="reduce(org.apache.kafka.streams.kstream.Reducer, org.apache.kafka.streams.kstream.Windows, java.lang.String)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>reduce</h4>
<pre>&lt;W extends <a href="../../../../../org/apache/kafka/streams/kstream/Window.html" title="class in org.apache.kafka.streams.kstream">Window</a>&gt;&nbsp;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/Windowed.html" title="class in org.apache.kafka.streams.kstream">Windowed</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html" title="type parameter in KGroupedStream">K</a>&gt;,<a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html" title="type parameter in KGroupedStream">V</a>&gt;&nbsp;reduce(<a href="../../../../../org/apache/kafka/streams/kstream/Reducer.html" title="interface in org.apache.kafka.streams.kstream">Reducer</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html" title="type parameter in KGroupedStream">V</a>&gt;&nbsp;reducer,
                                              <a href="../../../../../org/apache/kafka/streams/kstream/Windows.html" title="class in org.apache.kafka.streams.kstream">Windows</a>&lt;W&gt;&nbsp;windows,
                                              java.lang.String&nbsp;queryableStoreName)</pre>
<div class="block">Combine the number of records in this stream by the grouped key and the defined windows.
 Records with <code>null</code> key or value are ignored.
 Combining implies that the type of the aggregate result is the same as the type of the input value
 (c.f. <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html#aggregate(org.apache.kafka.streams.kstream.Initializer,%20org.apache.kafka.streams.kstream.Aggregator,%20org.apache.kafka.streams.kstream.Windows,%20org.apache.kafka.common.serialization.Serde,%20java.lang.String)"><code>aggregate(Initializer, Aggregator, Windows, Serde, String)</code></a>).
 The specified <code>windows</code> define either hopping time windows that can be overlapping or tumbling (c.f.
 <a href="../../../../../org/apache/kafka/streams/kstream/TimeWindows.html" title="class in org.apache.kafka.streams.kstream"><code>TimeWindows</code></a>) or they define landmark windows (c.f. <a href="../../../../../org/apache/kafka/streams/kstream/UnlimitedWindows.html" title="class in org.apache.kafka.streams.kstream"><code>UnlimitedWindows</code></a>).
 The result is written into a local windowed <a href="../../../../../org/apache/kafka/streams/state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state"><code>KeyValueStore</code></a> (which is basically an ever-updating
 materialized view) that can be queried using the provided <code>queryableStoreName</code>.
 Windows are retained until their retention time expires (c.f. <a href="../../../../../org/apache/kafka/streams/kstream/Windows.html#until(long)"><code>Windows.until(long)</code></a>).
 Furthermore, updates to the store are sent downstream into a windowed <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> changelog stream, where
 "windowed" implies that the <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> key is a combined key of the original record key and a window ID.
 <p>
 The specified <a href="../../../../../org/apache/kafka/streams/kstream/Reducer.html" title="interface in org.apache.kafka.streams.kstream"><code>Reducer</code></a> is applied for each input record and computes a new aggregate using the current
 aggregate and the record's value.
 If there is no current aggregate the <a href="../../../../../org/apache/kafka/streams/kstream/Reducer.html" title="interface in org.apache.kafka.streams.kstream"><code>Reducer</code></a> is not applied and the new aggregate will be the record's
 value as-is.
 Thus, <code>reduce(Reducer, Windows, String)</code> can be used to compute aggregate functions like sum, min, or max.
 <p>
 Not all updates might get sent downstream, as an internal cache is used to deduplicate consecutive updates to
 the same window and key.
 The rate of propagated updates depends on your input data rate, the number of distinct keys, the number of
 parallel running Kafka Streams instances, and the <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html" title="class in org.apache.kafka.streams"><code>configuration</code></a> parameters for
 <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html#CACHE_MAX_BYTES_BUFFERING_CONFIG"><code>cache size</code></a>, and
 <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html#COMMIT_INTERVAL_MS_CONFIG"><code>commit intervall</code></a>.
 <p>
 To query the local windowed <a href="../../../../../org/apache/kafka/streams/state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state"><code>KeyValueStore</code></a> it must be obtained via
 <a href="../../../../../org/apache/kafka/streams/KafkaStreams.html#store(java.lang.String,%20org.apache.kafka.streams.state.QueryableStoreType)"><code>KafkaStreams#store(...)</code></a>:
 <pre class="line-numbers"><code>KafkaStreams streams = ... // compute sum
 ReadOnlyWindowStore&lt;String,Long&gt; localWindowStore = streams.store(queryableStoreName, QueryableStoreTypes.&lt;String, Long&gt;windowStore());
 String key = "some-key";
 long fromTime = ...;
 long toTime = ...;
 WindowStoreIterator&lt;Long&gt; sumForKeyForWindows = localWindowStore.fetch(key, timeFrom, timeTo); // key must be local (application state is shared over all running Kafka Streams instances)
 </code></pre>
 For non-local keys, a custom RPC mechanism must be implemented using <a href="../../../../../org/apache/kafka/streams/KafkaStreams.html#allMetadata()"><code>KafkaStreams.allMetadata()</code></a> to
 query the value of the key on a parallel running instance of your Kafka Streams application.
 <p>
 For failure and recovery the store will be backed by an internal changelog topic that will be created in Kafka.
 Therefore, the store name must be a valid Kafka topic name and cannot contain characters other than ASCII
 alphanumerics, '.', '_' and '-'.
 The changelog topic will be named "${applicationId}-${queryableStoreName}-changelog", where "applicationId" is
 user-specified in <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html" title="class in org.apache.kafka.streams"><code>StreamsConfig</code></a> via parameter
 <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html#APPLICATION_ID_CONFIG"><code>APPLICATION_ID_CONFIG</code></a>, "queryableStoreName" is the
 provide <code>queryableStoreName</code>, and "-changelog" is a fixed suffix.
 You can retrieve all generated internal topic names via <a href="../../../../../org/apache/kafka/streams/KafkaStreams.html#toString()"><code>KafkaStreams.toString()</code></a>.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>reducer</code> - a <a href="../../../../../org/apache/kafka/streams/kstream/Reducer.html" title="interface in org.apache.kafka.streams.kstream"><code>Reducer</code></a> that computes a new aggregate result</dd><dd><code>windows</code> - the specification of the aggregation <a href="../../../../../org/apache/kafka/streams/kstream/Windows.html" title="class in org.apache.kafka.streams.kstream"><code>Windows</code></a></dd><dd><code>queryableStoreName</code> - the name of the state store created from this operation; valid characters are ASCII
 alphanumerics, '.', '_' and '-'. If <code>null</code> then this will be equivalent to <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html#reduce(org.apache.kafka.streams.kstream.Reducer,%20org.apache.kafka.streams.kstream.Windows)"><code>reduce(Reducer, Windows)</code></a> ()}.</dd>
<dt><span class="strong">Returns:</span></dt><dd>a windowed <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> that contains "update" records with unmodified keys, and values that represent
 the latest (rolling) aggregate for each key within a window</dd></dl>
</li>
</ul>
<a name="reduce(org.apache.kafka.streams.kstream.Reducer, org.apache.kafka.streams.kstream.Windows)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>reduce</h4>
<pre>&lt;W extends <a href="../../../../../org/apache/kafka/streams/kstream/Window.html" title="class in org.apache.kafka.streams.kstream">Window</a>&gt;&nbsp;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/Windowed.html" title="class in org.apache.kafka.streams.kstream">Windowed</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html" title="type parameter in KGroupedStream">K</a>&gt;,<a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html" title="type parameter in KGroupedStream">V</a>&gt;&nbsp;reduce(<a href="../../../../../org/apache/kafka/streams/kstream/Reducer.html" title="interface in org.apache.kafka.streams.kstream">Reducer</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html" title="type parameter in KGroupedStream">V</a>&gt;&nbsp;reducer,
                                              <a href="../../../../../org/apache/kafka/streams/kstream/Windows.html" title="class in org.apache.kafka.streams.kstream">Windows</a>&lt;W&gt;&nbsp;windows)</pre>
<div class="block">Combine the number of records in this stream by the grouped key and the defined windows.
 Records with <code>null</code> key or value are ignored.
 Combining implies that the type of the aggregate result is the same as the type of the input value
 (c.f. <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html#aggregate(org.apache.kafka.streams.kstream.Initializer,%20org.apache.kafka.streams.kstream.Aggregator,%20org.apache.kafka.streams.kstream.Windows,%20org.apache.kafka.common.serialization.Serde,%20java.lang.String)"><code>aggregate(Initializer, Aggregator, Windows, Serde, String)</code></a>).
 The specified <code>windows</code> define either hopping time windows that can be overlapping or tumbling (c.f.
 <a href="../../../../../org/apache/kafka/streams/kstream/TimeWindows.html" title="class in org.apache.kafka.streams.kstream"><code>TimeWindows</code></a>) or they define landmark windows (c.f. <a href="../../../../../org/apache/kafka/streams/kstream/UnlimitedWindows.html" title="class in org.apache.kafka.streams.kstream"><code>UnlimitedWindows</code></a>).
 The result is written into a local windowed <a href="../../../../../org/apache/kafka/streams/state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state"><code>KeyValueStore</code></a> (which is basically an ever-updating
 materialized view) that can be queried using the provided <code>queryableStoreName</code>.
 Windows are retained until their retention time expires (c.f. <a href="../../../../../org/apache/kafka/streams/kstream/Windows.html#until(long)"><code>Windows.until(long)</code></a>).
 Furthermore, updates to the store are sent downstream into a windowed <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> changelog stream, where
 "windowed" implies that the <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> key is a combined key of the original record key and a window ID.
 <p>
 The specified <a href="../../../../../org/apache/kafka/streams/kstream/Reducer.html" title="interface in org.apache.kafka.streams.kstream"><code>Reducer</code></a> is applied for each input record and computes a new aggregate using the current
 aggregate and the record's value.
 If there is no current aggregate the <a href="../../../../../org/apache/kafka/streams/kstream/Reducer.html" title="interface in org.apache.kafka.streams.kstream"><code>Reducer</code></a> is not applied and the new aggregate will be the record's
 value as-is.
 Thus, <code>reduce(Reducer, Windows, String)</code> can be used to compute aggregate functions like sum, min, or max.
 <p>
 Not all updates might get sent downstream, as an internal cache is used to deduplicate consecutive updates to
 the same window and key.
 The rate of propagated updates depends on your input data rate, the number of distinct keys, the number of
 parallel running Kafka Streams instances, and the <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html" title="class in org.apache.kafka.streams"><code>configuration</code></a> parameters for
 <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html#CACHE_MAX_BYTES_BUFFERING_CONFIG"><code>cache size</code></a>, and
 <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html#COMMIT_INTERVAL_MS_CONFIG"><code>commit intervall</code></a>.
 <p>
 For failure and recovery the store will be backed by an internal changelog topic that will be created in Kafka.
 The changelog topic will be named "${applicationId}-${internalStoreName}-changelog", where "applicationId" is
 user-specified in <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html" title="class in org.apache.kafka.streams"><code>StreamsConfig</code></a> via parameter
 <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html#APPLICATION_ID_CONFIG"><code>APPLICATION_ID_CONFIG</code></a>, "internalStoreName" is an internal name
 and "-changelog" is a fixed suffix.
 Note that the internal store name may not be queriable through Interactive Queries.
 You can retrieve all generated internal topic names via <a href="../../../../../org/apache/kafka/streams/KafkaStreams.html#toString()"><code>KafkaStreams.toString()</code></a>.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>reducer</code> - a <a href="../../../../../org/apache/kafka/streams/kstream/Reducer.html" title="interface in org.apache.kafka.streams.kstream"><code>Reducer</code></a> that computes a new aggregate result</dd><dd><code>windows</code> - the specification of the aggregation <a href="../../../../../org/apache/kafka/streams/kstream/Windows.html" title="class in org.apache.kafka.streams.kstream"><code>Windows</code></a></dd>
<dt><span class="strong">Returns:</span></dt><dd>a windowed <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> that contains "update" records with unmodified keys, and values that represent
 the latest (rolling) aggregate for each key within a window</dd></dl>
</li>
</ul>
<a name="reduce(org.apache.kafka.streams.kstream.Reducer, org.apache.kafka.streams.kstream.Windows, org.apache.kafka.streams.processor.StateStoreSupplier)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>reduce</h4>
<pre>&lt;W extends <a href="../../../../../org/apache/kafka/streams/kstream/Window.html" title="class in org.apache.kafka.streams.kstream">Window</a>&gt;&nbsp;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/Windowed.html" title="class in org.apache.kafka.streams.kstream">Windowed</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html" title="type parameter in KGroupedStream">K</a>&gt;,<a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html" title="type parameter in KGroupedStream">V</a>&gt;&nbsp;reduce(<a href="../../../../../org/apache/kafka/streams/kstream/Reducer.html" title="interface in org.apache.kafka.streams.kstream">Reducer</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html" title="type parameter in KGroupedStream">V</a>&gt;&nbsp;reducer,
                                              <a href="../../../../../org/apache/kafka/streams/kstream/Windows.html" title="class in org.apache.kafka.streams.kstream">Windows</a>&lt;W&gt;&nbsp;windows,
                                              <a href="../../../../../org/apache/kafka/streams/processor/StateStoreSupplier.html" title="interface in org.apache.kafka.streams.processor">StateStoreSupplier</a>&lt;<a href="../../../../../org/apache/kafka/streams/state/WindowStore.html" title="interface in org.apache.kafka.streams.state">WindowStore</a>&gt;&nbsp;storeSupplier)</pre>
<div class="block">Combine the values of records in this stream by the grouped key and the defined windows.
 Records with <code>null</code> key or value are ignored.
 Combining implies that the type of the aggregate result is the same as the type of the input value
 (c.f. <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html#aggregate(org.apache.kafka.streams.kstream.Initializer,%20org.apache.kafka.streams.kstream.Aggregator,%20org.apache.kafka.streams.kstream.Windows,%20org.apache.kafka.common.serialization.Serde,%20java.lang.String)"><code>aggregate(Initializer, Aggregator, Windows, Serde, String)</code></a>).
 The specified <code>windows</code> define either hopping time windows that can be overlapping or tumbling (c.f.
 <a href="../../../../../org/apache/kafka/streams/kstream/TimeWindows.html" title="class in org.apache.kafka.streams.kstream"><code>TimeWindows</code></a>) or they define landmark windows (c.f. <a href="../../../../../org/apache/kafka/streams/kstream/UnlimitedWindows.html" title="class in org.apache.kafka.streams.kstream"><code>UnlimitedWindows</code></a>).
 The result is written into a local windowed <a href="../../../../../org/apache/kafka/streams/state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state"><code>KeyValueStore</code></a> (which is basically an ever-updating
 materialized view) provided by the given <code>storeSupplier</code>.
 Windows are retained until their retention time expires (c.f. <a href="../../../../../org/apache/kafka/streams/kstream/Windows.html#until(long)"><code>Windows.until(long)</code></a>).
 Furthermore, updates to the store are sent downstream into a windowed <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> changelog stream, where
 "windowed" implies that the <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> key is a combined key of the original record key and a window ID.
 <p>
 The specified <a href="../../../../../org/apache/kafka/streams/kstream/Reducer.html" title="interface in org.apache.kafka.streams.kstream"><code>Reducer</code></a> is applied for each input record and computes a new aggregate using the current
 aggregate and the record's value.
 If there is no current aggregate the <a href="../../../../../org/apache/kafka/streams/kstream/Reducer.html" title="interface in org.apache.kafka.streams.kstream"><code>Reducer</code></a> is not applied and the new aggregate will be the record's
 value as-is.
 Thus, <code>reduce(Reducer, Windows, StateStoreSupplier)</code> can be used to compute aggregate functions like sum,
 min, or max.
 <p>
 Not all updates might get sent downstream, as an internal cache is used to deduplicate consecutive updates to
 the same window and key.
 The rate of propagated updates depends on your input data rate, the number of distinct keys, the number of
 parallel running Kafka Streams instances, and the <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html" title="class in org.apache.kafka.streams"><code>configuration</code></a> parameters for
 <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html#CACHE_MAX_BYTES_BUFFERING_CONFIG"><code>cache size</code></a>, and
 <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html#COMMIT_INTERVAL_MS_CONFIG"><code>commit intervall</code></a>.
 <p>
 To query the local windowed <a href="../../../../../org/apache/kafka/streams/state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state"><code>KeyValueStore</code></a> it must be obtained via
 <a href="../../../../../org/apache/kafka/streams/KafkaStreams.html#store(java.lang.String,%20org.apache.kafka.streams.state.QueryableStoreType)"><code>KafkaStreams#store(...)</code></a>.
 Use <a href="../../../../../org/apache/kafka/streams/processor/StateStoreSupplier.html#name()"><code>StateStoreSupplier.name()</code></a> to get the store name:
 <pre class="line-numbers"><code>KafkaStreams streams = ... // compute sum
 Sting queryableStoreName = storeSupplier.name();
 ReadOnlyWindowStore&lt;String,Long&gt; localWindowStore = streams.store(queryableStoreName, QueryableStoreTypes.&lt;String, Long&gt;windowStore());
 String key = "some-key";
 long fromTime = ...;
 long toTime = ...;
 WindowStoreIterator&lt;Long&gt; sumForKeyForWindows = localWindowStore.fetch(key, timeFrom, timeTo); // key must be local (application state is shared over all running Kafka Streams instances)
 </code></pre>
 For non-local keys, a custom RPC mechanism must be implemented using <a href="../../../../../org/apache/kafka/streams/KafkaStreams.html#allMetadata()"><code>KafkaStreams.allMetadata()</code></a> to
 query the value of the key on a parallel running instance of your Kafka Streams application.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>reducer</code> - a <a href="../../../../../org/apache/kafka/streams/kstream/Reducer.html" title="interface in org.apache.kafka.streams.kstream"><code>Reducer</code></a> that computes a new aggregate result</dd><dd><code>windows</code> - the specification of the aggregation <a href="../../../../../org/apache/kafka/streams/kstream/Windows.html" title="class in org.apache.kafka.streams.kstream"><code>Windows</code></a></dd><dd><code>storeSupplier</code> - user defined state store supplier. Cannot be <code>null</code>.</dd>
<dt><span class="strong">Returns:</span></dt><dd>a windowed <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> that contains "update" records with unmodified keys, and values that represent
 the latest (rolling) aggregate for each key within a window</dd></dl>
</li>
</ul>
<a name="reduce(org.apache.kafka.streams.kstream.Reducer, org.apache.kafka.streams.kstream.SessionWindows, java.lang.String)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>reduce</h4>
<pre><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/Windowed.html" title="class in org.apache.kafka.streams.kstream">Windowed</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html" title="type parameter in KGroupedStream">K</a>&gt;,<a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html" title="type parameter in KGroupedStream">V</a>&gt;&nbsp;reduce(<a href="../../../../../org/apache/kafka/streams/kstream/Reducer.html" title="interface in org.apache.kafka.streams.kstream">Reducer</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html" title="type parameter in KGroupedStream">V</a>&gt;&nbsp;reducer,
                           <a href="../../../../../org/apache/kafka/streams/kstream/SessionWindows.html" title="class in org.apache.kafka.streams.kstream">SessionWindows</a>&nbsp;sessionWindows,
                           java.lang.String&nbsp;queryableStoreName)</pre>
<div class="block">Combine values of this stream by the grouped key into <a href="../../../../../org/apache/kafka/streams/kstream/SessionWindows.html" title="class in org.apache.kafka.streams.kstream"><code>SessionWindows</code></a>.
 Records with <code>null</code> key or value are ignored.
 Combining implies that the type of the aggregate result is the same as the type of the input value
 (c.f. <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html#aggregate(org.apache.kafka.streams.kstream.Initializer,%20org.apache.kafka.streams.kstream.Aggregator,%20org.apache.kafka.streams.kstream.Merger,%20org.apache.kafka.streams.kstream.SessionWindows,%20org.apache.kafka.common.serialization.Serde,%20java.lang.String)"><code>aggregate(Initializer, Aggregator, Merger, SessionWindows, Serde, String)</code></a>).
 The result is written into a local <a href="../../../../../org/apache/kafka/streams/state/SessionStore.html" title="interface in org.apache.kafka.streams.state"><code>SessionStore</code></a> (which is basically an ever-updating
 materialized view) that can be queried using the provided <code>queryableStoreName</code>.
 SessionWindows are retained until their retention time expires (c.f. <a href="../../../../../org/apache/kafka/streams/kstream/SessionWindows.html#until(long)"><code>SessionWindows.until(long)</code></a>).
 Furthermore, updates to the store are sent downstream into a windowed <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> changelog stream, where
 "windowed" implies that the <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> key is a combined key of the original record key and a window ID.
 <p>
 The specified <a href="../../../../../org/apache/kafka/streams/kstream/Reducer.html" title="interface in org.apache.kafka.streams.kstream"><code>Reducer</code></a> is applied for each input record and computes a new aggregate using the current
 aggregate and the record's value.
 If there is no current aggregate the <a href="../../../../../org/apache/kafka/streams/kstream/Reducer.html" title="interface in org.apache.kafka.streams.kstream"><code>Reducer</code></a> is not applied and the new aggregate will be the record's
 value as-is.
 Thus, <code>reduce(Reducer, SessionWindows, String)</code> can be used to compute aggregate functions like sum, min,
 or max.
 <p>
 Not all updates might get sent downstream, as an internal cache is used to deduplicate consecutive updates to
 the same window and key.
 The rate of propagated updates depends on your input data rate, the number of distinct keys, the number of
 parallel running Kafka Streams instances, and the <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html" title="class in org.apache.kafka.streams"><code>configuration</code></a> parameters for
 <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html#CACHE_MAX_BYTES_BUFFERING_CONFIG"><code>cache size</code></a>, and
 <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html#COMMIT_INTERVAL_MS_CONFIG"><code>commit intervall</code></a>.
 <p>
 To query the local windowed <a href="../../../../../org/apache/kafka/streams/state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state"><code>KeyValueStore</code></a> it must be obtained via
 <a href="../../../../../org/apache/kafka/streams/KafkaStreams.html#store(java.lang.String,%20org.apache.kafka.streams.state.QueryableStoreType)"><code>KafkaStreams#store(...)</code></a>.
 Use <a href="../../../../../org/apache/kafka/streams/processor/StateStoreSupplier.html#name()"><code>StateStoreSupplier.name()</code></a> to get the store name:
 <pre class="line-numbers"><code>KafkaStreams streams = ... // compute sum
 Sting queryableStoreName = storeSupplier.name();
 ReadOnlySessionStore&lt;String,Long&gt; localWindowStore = streams.store(queryableStoreName, QueryableStoreTypes.&lt;String, Long&gt;ReadOnlySessionStore&lt;String, Long&gt;);
 String key = "some-key";
 KeyValueIterator&lt;Windowed&lt;String&gt;, Long&gt; sumForKeyForWindows = localWindowStore.fetch(key); // key must be local (application state is shared over all running Kafka Streams instances)
 </code></pre>
 For non-local keys, a custom RPC mechanism must be implemented using <a href="../../../../../org/apache/kafka/streams/KafkaStreams.html#allMetadata()"><code>KafkaStreams.allMetadata()</code></a> to
 query the value of the key on a parallel running instance of your Kafka Streams application.
 <p>
 For failure and recovery the store will be backed by an internal changelog topic that will be created in Kafka.
 Therefore, the store name must be a valid Kafka topic name and cannot contain characters other than ASCII
 alphanumerics, '.', '_' and '-'.
 The changelog topic will be named "${applicationId}-${queryableStoreName}-changelog", where "applicationId" is
 user-specified in <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html" title="class in org.apache.kafka.streams"><code>StreamsConfig</code></a> via parameter
 <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html#APPLICATION_ID_CONFIG"><code>APPLICATION_ID_CONFIG</code></a>, "queryableStoreName" is the
 provide <code>queryableStoreName</code>, and "-changelog" is a fixed suffix.
 You can retrieve all generated internal topic names via <a href="../../../../../org/apache/kafka/streams/KafkaStreams.html#toString()"><code>KafkaStreams.toString()</code></a>.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>reducer</code> - the instance of <a href="../../../../../org/apache/kafka/streams/kstream/Reducer.html" title="interface in org.apache.kafka.streams.kstream"><code>Reducer</code></a></dd><dd><code>sessionWindows</code> - the specification of the aggregation <a href="../../../../../org/apache/kafka/streams/kstream/SessionWindows.html" title="class in org.apache.kafka.streams.kstream"><code>SessionWindows</code></a></dd><dd><code>queryableStoreName</code> - the name of the state store created from this operation; valid characters are ASCII
 alphanumerics, '.', '_' and '-'. If <code>null</code> then this will be equivalent to <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html#reduce(org.apache.kafka.streams.kstream.Reducer,%20org.apache.kafka.streams.kstream.SessionWindows)"><code>reduce(Reducer, SessionWindows)</code></a> ()}.</dd>
<dt><span class="strong">Returns:</span></dt><dd>a windowed <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> that contains "update" records with unmodified keys, and values that represent
 the latest (rolling) aggregate for each key within a window</dd></dl>
</li>
</ul>
<a name="reduce(org.apache.kafka.streams.kstream.Reducer, org.apache.kafka.streams.kstream.SessionWindows)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>reduce</h4>
<pre><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/Windowed.html" title="class in org.apache.kafka.streams.kstream">Windowed</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html" title="type parameter in KGroupedStream">K</a>&gt;,<a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html" title="type parameter in KGroupedStream">V</a>&gt;&nbsp;reduce(<a href="../../../../../org/apache/kafka/streams/kstream/Reducer.html" title="interface in org.apache.kafka.streams.kstream">Reducer</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html" title="type parameter in KGroupedStream">V</a>&gt;&nbsp;reducer,
                           <a href="../../../../../org/apache/kafka/streams/kstream/SessionWindows.html" title="class in org.apache.kafka.streams.kstream">SessionWindows</a>&nbsp;sessionWindows)</pre>
<div class="block">Combine values of this stream by the grouped key into <a href="../../../../../org/apache/kafka/streams/kstream/SessionWindows.html" title="class in org.apache.kafka.streams.kstream"><code>SessionWindows</code></a>.
 Records with <code>null</code> key or value are ignored.
 Combining implies that the type of the aggregate result is the same as the type of the input value
 (c.f. <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html#aggregate(org.apache.kafka.streams.kstream.Initializer,%20org.apache.kafka.streams.kstream.Aggregator,%20org.apache.kafka.streams.kstream.Merger,%20org.apache.kafka.streams.kstream.SessionWindows,%20org.apache.kafka.common.serialization.Serde,%20java.lang.String)"><code>aggregate(Initializer, Aggregator, Merger, SessionWindows, Serde, String)</code></a>).
 The result is written into a local <a href="../../../../../org/apache/kafka/streams/state/SessionStore.html" title="interface in org.apache.kafka.streams.state"><code>SessionStore</code></a> (which is basically an ever-updating
 materialized view) that can be queried using the provided <code>queryableStoreName</code>.
 SessionWindows are retained until their retention time expires (c.f. <a href="../../../../../org/apache/kafka/streams/kstream/SessionWindows.html#until(long)"><code>SessionWindows.until(long)</code></a>).
 Furthermore, updates to the store are sent downstream into a windowed <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> changelog stream, where
 "windowed" implies that the <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> key is a combined key of the original record key and a window ID.
 <p>
 The specified <a href="../../../../../org/apache/kafka/streams/kstream/Reducer.html" title="interface in org.apache.kafka.streams.kstream"><code>Reducer</code></a> is applied for each input record and computes a new aggregate using the current
 aggregate and the record's value.
 If there is no current aggregate the <a href="../../../../../org/apache/kafka/streams/kstream/Reducer.html" title="interface in org.apache.kafka.streams.kstream"><code>Reducer</code></a> is not applied and the new aggregate will be the record's
 value as-is.
 Thus, <code>reduce(Reducer, SessionWindows, String)</code> can be used to compute aggregate functions like sum, min,
 or max.
 <p>
 Not all updates might get sent downstream, as an internal cache is used to deduplicate consecutive updates to
 the same window and key.
 The rate of propagated updates depends on your input data rate, the number of distinct keys, the number of
 parallel running Kafka Streams instances, and the <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html" title="class in org.apache.kafka.streams"><code>configuration</code></a> parameters for
 <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html#CACHE_MAX_BYTES_BUFFERING_CONFIG"><code>cache size</code></a>, and
 <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html#COMMIT_INTERVAL_MS_CONFIG"><code>commit intervall</code></a>.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>reducer</code> - the instance of <a href="../../../../../org/apache/kafka/streams/kstream/Reducer.html" title="interface in org.apache.kafka.streams.kstream"><code>Reducer</code></a></dd><dd><code>sessionWindows</code> - the specification of the aggregation <a href="../../../../../org/apache/kafka/streams/kstream/SessionWindows.html" title="class in org.apache.kafka.streams.kstream"><code>SessionWindows</code></a></dd>
<dt><span class="strong">Returns:</span></dt><dd>a windowed <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> that contains "update" records with unmodified keys, and values that represent
 the latest (rolling) aggregate for each key within a window</dd></dl>
</li>
</ul>
<a name="reduce(org.apache.kafka.streams.kstream.Reducer, org.apache.kafka.streams.kstream.SessionWindows, org.apache.kafka.streams.processor.StateStoreSupplier)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>reduce</h4>
<pre><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/Windowed.html" title="class in org.apache.kafka.streams.kstream">Windowed</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html" title="type parameter in KGroupedStream">K</a>&gt;,<a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html" title="type parameter in KGroupedStream">V</a>&gt;&nbsp;reduce(<a href="../../../../../org/apache/kafka/streams/kstream/Reducer.html" title="interface in org.apache.kafka.streams.kstream">Reducer</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html" title="type parameter in KGroupedStream">V</a>&gt;&nbsp;reducer,
                           <a href="../../../../../org/apache/kafka/streams/kstream/SessionWindows.html" title="class in org.apache.kafka.streams.kstream">SessionWindows</a>&nbsp;sessionWindows,
                           <a href="../../../../../org/apache/kafka/streams/processor/StateStoreSupplier.html" title="interface in org.apache.kafka.streams.processor">StateStoreSupplier</a>&lt;<a href="../../../../../org/apache/kafka/streams/state/SessionStore.html" title="interface in org.apache.kafka.streams.state">SessionStore</a>&gt;&nbsp;storeSupplier)</pre>
<div class="block">Combine values of this stream by the grouped key into <a href="../../../../../org/apache/kafka/streams/kstream/SessionWindows.html" title="class in org.apache.kafka.streams.kstream"><code>SessionWindows</code></a>.
 Records with <code>null</code> key or value are ignored.
 Combining implies that the type of the aggregate result is the same as the type of the input value
 (c.f. <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html#aggregate(org.apache.kafka.streams.kstream.Initializer,%20org.apache.kafka.streams.kstream.Aggregator,%20org.apache.kafka.streams.kstream.Merger,%20org.apache.kafka.streams.kstream.SessionWindows,%20org.apache.kafka.common.serialization.Serde,%20java.lang.String)"><code>aggregate(Initializer, Aggregator, Merger, SessionWindows, Serde, String)</code></a>).
 The result is written into a local <a href="../../../../../org/apache/kafka/streams/state/SessionStore.html" title="interface in org.apache.kafka.streams.state"><code>SessionStore</code></a> (which is basically an ever-updating materialized view)
 provided by the given <code>storeSupplier</code>.
 SessionWindows are retained until their retention time expires (c.f. <a href="../../../../../org/apache/kafka/streams/kstream/SessionWindows.html#until(long)"><code>SessionWindows.until(long)</code></a>).
 Furthermore, updates to the store are sent downstream into a windowed <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> changelog stream, where
 "windowed" implies that the <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> key is a combined key of the original record key and a window ID.
 <p>
 The specified <a href="../../../../../org/apache/kafka/streams/kstream/Reducer.html" title="interface in org.apache.kafka.streams.kstream"><code>Reducer</code></a> is applied for each input record and computes a new aggregate using the current
 aggregate and the record's value.
 If there is no current aggregate the <a href="../../../../../org/apache/kafka/streams/kstream/Reducer.html" title="interface in org.apache.kafka.streams.kstream"><code>Reducer</code></a> is not applied and the new aggregate will be the record's
 value as-is.
 Thus, <code>reduce(Reducer, SessionWindows, StateStoreSupplier)</code> can be used to compute aggregate functions like
 sum, min, or max.
 <p>
 Not all updates might get sent downstream, as an internal cache is used to deduplicate consecutive updates to
 the same window and key.
 The rate of propagated updates depends on your input data rate, the number of distinct keys, the number of
 parallel running Kafka Streams instances, and the <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html" title="class in org.apache.kafka.streams"><code>configuration</code></a> parameters for
 <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html#CACHE_MAX_BYTES_BUFFERING_CONFIG"><code>cache size</code></a>, and
 <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html#COMMIT_INTERVAL_MS_CONFIG"><code>commit intervall</code></a>.
 <p>
 To query the local windowed <a href="../../../../../org/apache/kafka/streams/state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state"><code>KeyValueStore</code></a> it must be obtained via
 <a href="../../../../../org/apache/kafka/streams/KafkaStreams.html#store(java.lang.String,%20org.apache.kafka.streams.state.QueryableStoreType)"><code>KafkaStreams#store(...)</code></a>.
 Use <a href="../../../../../org/apache/kafka/streams/processor/StateStoreSupplier.html#name()"><code>StateStoreSupplier.name()</code></a> to get the store name:
 <pre class="line-numbers"><code>KafkaStreams streams = ... // compute sum
 Sting queryableStoreName = storeSupplier.name();
 ReadOnlySessionStore&lt;String,Long&gt; localWindowStore = streams.store(queryableStoreName, QueryableStoreTypes.&lt;String, Long&gt;ReadOnlySessionStore&lt;String, Long&gt;);
 String key = "some-key";
 KeyValueIterator&lt;Windowed&lt;String&gt;, Long&gt; sumForKeyForWindows = localWindowStore.fetch(key); // key must be local (application state is shared over all running Kafka Streams instances)
 </code></pre>
 For non-local keys, a custom RPC mechanism must be implemented using <a href="../../../../../org/apache/kafka/streams/KafkaStreams.html#allMetadata()"><code>KafkaStreams.allMetadata()</code></a> to
 query the value of the key on a parallel running instance of your Kafka Streams application.
 <p>
 For failure and recovery the store will be backed by an internal changelog topic that will be created in Kafka.
 Therefore, the store name must be a valid Kafka topic name and cannot contain characters other than ASCII
 alphanumerics, '.', '_' and '-'.
 The changelog topic will be named "${applicationId}-${queryableStoreName}-changelog", where "applicationId" is
 user-specified in <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html" title="class in org.apache.kafka.streams"><code>StreamsConfig</code></a> via parameter
 <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html#APPLICATION_ID_CONFIG"><code>APPLICATION_ID_CONFIG</code></a>, "queryableStoreName" is the
 provide <code>queryableStoreName</code>, and "-changelog" is a fixed suffix.
 You can retrieve all generated internal topic names via <a href="../../../../../org/apache/kafka/streams/KafkaStreams.html#toString()"><code>KafkaStreams.toString()</code></a>.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>reducer</code> - the instance of <a href="../../../../../org/apache/kafka/streams/kstream/Reducer.html" title="interface in org.apache.kafka.streams.kstream"><code>Reducer</code></a></dd><dd><code>sessionWindows</code> - the specification of the aggregation <a href="../../../../../org/apache/kafka/streams/kstream/SessionWindows.html" title="class in org.apache.kafka.streams.kstream"><code>SessionWindows</code></a></dd><dd><code>storeSupplier</code> - user defined state store supplier. Cannot be <code>null</code>.</dd>
<dt><span class="strong">Returns:</span></dt><dd>a windowed <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> that contains "update" records with unmodified keys, and values that represent
 the latest (rolling) aggregate for each key within a window</dd></dl>
</li>
</ul>
<a name="aggregate(org.apache.kafka.streams.kstream.Initializer, org.apache.kafka.streams.kstream.Aggregator, org.apache.kafka.common.serialization.Serde, java.lang.String)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>aggregate</h4>
<pre>&lt;VR&gt;&nbsp;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html" title="type parameter in KGroupedStream">K</a>,VR&gt;&nbsp;aggregate(<a href="../../../../../org/apache/kafka/streams/kstream/Initializer.html" title="interface in org.apache.kafka.streams.kstream">Initializer</a>&lt;VR&gt;&nbsp;initializer,
                          <a href="../../../../../org/apache/kafka/streams/kstream/Aggregator.html" title="interface in org.apache.kafka.streams.kstream">Aggregator</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html" title="type parameter in KGroupedStream">K</a>,? super <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html" title="type parameter in KGroupedStream">V</a>,VR&gt;&nbsp;aggregator,
                          <a href="../../../../../org/apache/kafka/common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization">Serde</a>&lt;VR&gt;&nbsp;aggValueSerde,
                          java.lang.String&nbsp;queryableStoreName)</pre>
<div class="block">Aggregate the values of records in this stream by the grouped key.
 Records with <code>null</code> key or value are ignored.
 Aggregating is a generalization of <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html#reduce(org.apache.kafka.streams.kstream.Reducer,%20java.lang.String)"><code>combining via reduce(...)</code></a> as it, for example,
 allows the result to have a different type than the input values.
 The result is written into a local <a href="../../../../../org/apache/kafka/streams/state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state"><code>KeyValueStore</code></a> (which is basically an ever-updating materialized view)
 that can be queried using the provided <code>queryableStoreName</code>.
 Furthermore, updates to the store are sent downstream into a <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> changelog stream.
 <p>
 The specified <a href="../../../../../org/apache/kafka/streams/kstream/Initializer.html" title="interface in org.apache.kafka.streams.kstream"><code>Initializer</code></a> is applied once directly before the first input record is processed to
 provide an initial intermediate aggregation result that is used to process the first record.
 The specified <a href="../../../../../org/apache/kafka/streams/kstream/Aggregator.html" title="interface in org.apache.kafka.streams.kstream"><code>Aggregator</code></a> is applied for each input record and computes a new aggregate using the current
 aggregate (or for the very first record using the intermediate aggregation result provided via the
 <a href="../../../../../org/apache/kafka/streams/kstream/Initializer.html" title="interface in org.apache.kafka.streams.kstream"><code>Initializer</code></a>) and the record's value.
 Thus, <code>aggregate(Initializer, Aggregator, Serde, String)</code> can be used to compute aggregate functions like
 count (c.f. <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html#count(java.lang.String)"><code>count(String)</code></a>).
 <p>
 Not all updates might get sent downstream, as an internal cache is used to deduplicate consecutive updates to
 the same key.
 The rate of propagated updates depends on your input data rate, the number of distinct keys, the number of
 parallel running Kafka Streams instances, and the <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html" title="class in org.apache.kafka.streams"><code>configuration</code></a> parameters for
 <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html#CACHE_MAX_BYTES_BUFFERING_CONFIG"><code>cache size</code></a>, and
 <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html#COMMIT_INTERVAL_MS_CONFIG"><code>commit intervall</code></a>.
 <p>
 To query the local <a href="../../../../../org/apache/kafka/streams/state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state"><code>KeyValueStore</code></a> it must be obtained via
 <a href="../../../../../org/apache/kafka/streams/KafkaStreams.html#store(java.lang.String,%20org.apache.kafka.streams.state.QueryableStoreType)"><code>KafkaStreams#store(...)</code></a>:
 <pre class="line-numbers"><code>KafkaStreams streams = ... // some aggregation on value type double
 ReadOnlyKeyValueStore&lt;String,Long&gt; localStore = streams.store(queryableStoreName, QueryableStoreTypes.&lt;String, Long&gt;keyValueStore());
 String key = "some-key";
 Long aggForKey = localStore.get(key); // key must be local (application state is shared over all running Kafka Streams instances)
 </code></pre>
 For non-local keys, a custom RPC mechanism must be implemented using <a href="../../../../../org/apache/kafka/streams/KafkaStreams.html#allMetadata()"><code>KafkaStreams.allMetadata()</code></a> to
 query the value of the key on a parallel running instance of your Kafka Streams application.
 <p>
 For failure and recovery the store will be backed by an internal changelog topic that will be created in Kafka.
 Therefore, the store name must be a valid Kafka topic name and cannot contain characters other than ASCII
 alphanumerics, '.', '_' and '-'.
 The changelog topic will be named "${applicationId}-${queryableStoreName}-changelog", where "applicationId" is
 user-specified in <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html" title="class in org.apache.kafka.streams"><code>StreamsConfig</code></a> via parameter
 <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html#APPLICATION_ID_CONFIG"><code>APPLICATION_ID_CONFIG</code></a>, "queryableStoreName" is the
 provide <code>queryableStoreName</code>, and "-changelog" is a fixed suffix.
 You can retrieve all generated internal topic names via <a href="../../../../../org/apache/kafka/streams/KafkaStreams.html#toString()"><code>KafkaStreams.toString()</code></a>.</div>
<dl><dt><span class="strong">Type Parameters:</span></dt><dd><code>VR</code> - the value type of the resulting <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a></dd><dt><span class="strong">Parameters:</span></dt><dd><code>initializer</code> - an <a href="../../../../../org/apache/kafka/streams/kstream/Initializer.html" title="interface in org.apache.kafka.streams.kstream"><code>Initializer</code></a> that computes an initial intermediate aggregation result</dd><dd><code>aggregator</code> - an <a href="../../../../../org/apache/kafka/streams/kstream/Aggregator.html" title="interface in org.apache.kafka.streams.kstream"><code>Aggregator</code></a> that computes a new aggregate result</dd><dd><code>aggValueSerde</code> - aggregate value serdes for materializing the aggregated table,
                      if not specified the default serdes defined in the configs will be used</dd><dd><code>queryableStoreName</code> - the name of the state store created from this operation; valid characters are ASCII
 alphanumerics, '.', '_' and '-'. If <code>null</code> then this will be equivalent to <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html#aggregate(org.apache.kafka.streams.kstream.Initializer,%20org.apache.kafka.streams.kstream.Aggregator,%20org.apache.kafka.common.serialization.Serde)"><code>aggregate(Initializer, Aggregator, Serde)</code></a> ()} ()}.</dd>
<dt><span class="strong">Returns:</span></dt><dd>a <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> that contains "update" records with unmodified keys, and values that represent the
 latest (rolling) aggregate for each key</dd></dl>
</li>
</ul>
<a name="aggregate(org.apache.kafka.streams.kstream.Initializer, org.apache.kafka.streams.kstream.Aggregator, org.apache.kafka.common.serialization.Serde)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>aggregate</h4>
<pre>&lt;VR&gt;&nbsp;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html" title="type parameter in KGroupedStream">K</a>,VR&gt;&nbsp;aggregate(<a href="../../../../../org/apache/kafka/streams/kstream/Initializer.html" title="interface in org.apache.kafka.streams.kstream">Initializer</a>&lt;VR&gt;&nbsp;initializer,
                          <a href="../../../../../org/apache/kafka/streams/kstream/Aggregator.html" title="interface in org.apache.kafka.streams.kstream">Aggregator</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html" title="type parameter in KGroupedStream">K</a>,? super <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html" title="type parameter in KGroupedStream">V</a>,VR&gt;&nbsp;aggregator,
                          <a href="../../../../../org/apache/kafka/common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization">Serde</a>&lt;VR&gt;&nbsp;aggValueSerde)</pre>
<div class="block">Aggregate the values of records in this stream by the grouped key.
 Records with <code>null</code> key or value are ignored.
 Aggregating is a generalization of <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html#reduce(org.apache.kafka.streams.kstream.Reducer,%20java.lang.String)"><code>combining via reduce(...)</code></a> as it, for example,
 allows the result to have a different type than the input values.
 The result is written into a local <a href="../../../../../org/apache/kafka/streams/state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state"><code>KeyValueStore</code></a> (which is basically an ever-updating materialized view)
 that can be queried using the provided <code>queryableStoreName</code>.
 Furthermore, updates to the store are sent downstream into a <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> changelog stream.
 <p>
 The specified <a href="../../../../../org/apache/kafka/streams/kstream/Initializer.html" title="interface in org.apache.kafka.streams.kstream"><code>Initializer</code></a> is applied once directly before the first input record is processed to
 provide an initial intermediate aggregation result that is used to process the first record.
 The specified <a href="../../../../../org/apache/kafka/streams/kstream/Aggregator.html" title="interface in org.apache.kafka.streams.kstream"><code>Aggregator</code></a> is applied for each input record and computes a new aggregate using the current
 aggregate (or for the very first record using the intermediate aggregation result provided via the
 <a href="../../../../../org/apache/kafka/streams/kstream/Initializer.html" title="interface in org.apache.kafka.streams.kstream"><code>Initializer</code></a>) and the record's value.
 Thus, <code>aggregate(Initializer, Aggregator, Serde, String)</code> can be used to compute aggregate functions like
 count (c.f. <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html#count(java.lang.String)"><code>count(String)</code></a>).
 <p>
 Not all updates might get sent downstream, as an internal cache is used to deduplicate consecutive updates to
 the same key.
 The rate of propagated updates depends on your input data rate, the number of distinct keys, the number of
 parallel running Kafka Streams instances, and the <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html" title="class in org.apache.kafka.streams"><code>configuration</code></a> parameters for
 <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html#CACHE_MAX_BYTES_BUFFERING_CONFIG"><code>cache size</code></a>, and
 <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html#COMMIT_INTERVAL_MS_CONFIG"><code>commit intervall</code></a>.
 <p>
 For failure and recovery the store will be backed by an internal changelog topic that will be created in Kafka.
 The changelog topic will be named "${applicationId}-${internalStoreName}-changelog", where "applicationId" is
 user-specified in <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html" title="class in org.apache.kafka.streams"><code>StreamsConfig</code></a> via parameter
 <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html#APPLICATION_ID_CONFIG"><code>APPLICATION_ID_CONFIG</code></a>, "internalStoreName" is an internal name
 and "-changelog" is a fixed suffix.
 Note that the internal store name may not be queriable through Interactive Queries.
 You can retrieve all generated internal topic names via <a href="../../../../../org/apache/kafka/streams/KafkaStreams.html#toString()"><code>KafkaStreams.toString()</code></a>.</div>
<dl><dt><span class="strong">Type Parameters:</span></dt><dd><code>VR</code> - the value type of the resulting <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a></dd><dt><span class="strong">Parameters:</span></dt><dd><code>initializer</code> - an <a href="../../../../../org/apache/kafka/streams/kstream/Initializer.html" title="interface in org.apache.kafka.streams.kstream"><code>Initializer</code></a> that computes an initial intermediate aggregation result</dd><dd><code>aggregator</code> - an <a href="../../../../../org/apache/kafka/streams/kstream/Aggregator.html" title="interface in org.apache.kafka.streams.kstream"><code>Aggregator</code></a> that computes a new aggregate result</dd><dd><code>aggValueSerde</code> - aggregate value serdes for materializing the aggregated table,
                      if not specified the default serdes defined in the configs will be used</dd>
<dt><span class="strong">Returns:</span></dt><dd>a <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> that contains "update" records with unmodified keys, and values that represent the
 latest (rolling) aggregate for each key</dd></dl>
</li>
</ul>
<a name="aggregate(org.apache.kafka.streams.kstream.Initializer, org.apache.kafka.streams.kstream.Aggregator, org.apache.kafka.streams.processor.StateStoreSupplier)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>aggregate</h4>
<pre>&lt;VR&gt;&nbsp;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html" title="type parameter in KGroupedStream">K</a>,VR&gt;&nbsp;aggregate(<a href="../../../../../org/apache/kafka/streams/kstream/Initializer.html" title="interface in org.apache.kafka.streams.kstream">Initializer</a>&lt;VR&gt;&nbsp;initializer,
                          <a href="../../../../../org/apache/kafka/streams/kstream/Aggregator.html" title="interface in org.apache.kafka.streams.kstream">Aggregator</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html" title="type parameter in KGroupedStream">K</a>,? super <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html" title="type parameter in KGroupedStream">V</a>,VR&gt;&nbsp;aggregator,
                          <a href="../../../../../org/apache/kafka/streams/processor/StateStoreSupplier.html" title="interface in org.apache.kafka.streams.processor">StateStoreSupplier</a>&lt;<a href="../../../../../org/apache/kafka/streams/state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state">KeyValueStore</a>&gt;&nbsp;storeSupplier)</pre>
<div class="block">Aggregate the values of records in this stream by the grouped key.
 Records with <code>null</code> key or value are ignored.
 Aggregating is a generalization of <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html#reduce(org.apache.kafka.streams.kstream.Reducer,%20org.apache.kafka.streams.processor.StateStoreSupplier)"><code>combining via reduce(...)</code></a> as it,
 for example, allows the result to have a different type than the input values.
 The result is written into a local <a href="../../../../../org/apache/kafka/streams/state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state"><code>KeyValueStore</code></a> (which is basically an ever-updating materialized view)
 provided by the given <code>storeSupplier</code>.
 Furthermore, updates to the store are sent downstream into a <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> changelog stream.
 <p>
 The specified <a href="../../../../../org/apache/kafka/streams/kstream/Initializer.html" title="interface in org.apache.kafka.streams.kstream"><code>Initializer</code></a> is applied once directly before the first input record is processed to
 provide an initial intermediate aggregation result that is used to process the first record.
 The specified <a href="../../../../../org/apache/kafka/streams/kstream/Aggregator.html" title="interface in org.apache.kafka.streams.kstream"><code>Aggregator</code></a> is applied for each input record and computes a new aggregate using the current
 aggregate (or for the very first record using the intermediate aggregation result provided via the
 <a href="../../../../../org/apache/kafka/streams/kstream/Initializer.html" title="interface in org.apache.kafka.streams.kstream"><code>Initializer</code></a>) and the record's value.
 Thus, <code>aggregate(Initializer, Aggregator, StateStoreSupplier)</code> can be used to compute aggregate functions
 like count (c.f. <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html#count(java.lang.String)"><code>count(String)</code></a>).
 <p>
 Not all updates might get sent downstream, as an internal cache is used to deduplicate consecutive updates to
 the same key.
 The rate of propagated updates depends on your input data rate, the number of distinct keys, the number of
 parallel running Kafka Streams instances, and the <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html" title="class in org.apache.kafka.streams"><code>configuration</code></a> parameters for
 <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html#CACHE_MAX_BYTES_BUFFERING_CONFIG"><code>cache size</code></a>, and
 <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html#COMMIT_INTERVAL_MS_CONFIG"><code>commit intervall</code></a>.
 <p>
 To query the local <a href="../../../../../org/apache/kafka/streams/state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state"><code>KeyValueStore</code></a> it must be obtained via
 <a href="../../../../../org/apache/kafka/streams/KafkaStreams.html#store(java.lang.String,%20org.apache.kafka.streams.state.QueryableStoreType)"><code>KafkaStreams#store(...)</code></a>.
 Use <a href="../../../../../org/apache/kafka/streams/processor/StateStoreSupplier.html#name()"><code>StateStoreSupplier.name()</code></a> to get the store name:
 <pre class="line-numbers"><code>KafkaStreams streams = ... // some aggregation on value type double
 Sting queryableStoreName = storeSupplier.name();
 ReadOnlyKeyValueStore&lt;String,Long&gt; localStore = streams.store(queryableStoreName, QueryableStoreTypes.&lt;String, Long&gt;keyValueStore());
 String key = "some-key";
 Long aggForKey = localStore.get(key); // key must be local (application state is shared over all running Kafka Streams instances)
 </code></pre>
 For non-local keys, a custom RPC mechanism must be implemented using <a href="../../../../../org/apache/kafka/streams/KafkaStreams.html#allMetadata()"><code>KafkaStreams.allMetadata()</code></a> to
 query the value of the key on a parallel running instance of your Kafka Streams application.</div>
<dl><dt><span class="strong">Type Parameters:</span></dt><dd><code>VR</code> - the value type of the resulting <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a></dd><dt><span class="strong">Parameters:</span></dt><dd><code>initializer</code> - an <a href="../../../../../org/apache/kafka/streams/kstream/Initializer.html" title="interface in org.apache.kafka.streams.kstream"><code>Initializer</code></a> that computes an initial intermediate aggregation result</dd><dd><code>aggregator</code> - an <a href="../../../../../org/apache/kafka/streams/kstream/Aggregator.html" title="interface in org.apache.kafka.streams.kstream"><code>Aggregator</code></a> that computes a new aggregate result</dd><dd><code>storeSupplier</code> - user defined state store supplier. Cannot be <code>null</code>.</dd>
<dt><span class="strong">Returns:</span></dt><dd>a <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> that contains "update" records with unmodified keys, and values that represent the
 latest (rolling) aggregate for each key</dd></dl>
</li>
</ul>
<a name="aggregate(org.apache.kafka.streams.kstream.Initializer, org.apache.kafka.streams.kstream.Aggregator, org.apache.kafka.streams.kstream.Windows, org.apache.kafka.common.serialization.Serde, java.lang.String)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>aggregate</h4>
<pre>&lt;W extends <a href="../../../../../org/apache/kafka/streams/kstream/Window.html" title="class in org.apache.kafka.streams.kstream">Window</a>,VR&gt;&nbsp;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/Windowed.html" title="class in org.apache.kafka.streams.kstream">Windowed</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html" title="type parameter in KGroupedStream">K</a>&gt;,VR&gt;&nbsp;aggregate(<a href="../../../../../org/apache/kafka/streams/kstream/Initializer.html" title="interface in org.apache.kafka.streams.kstream">Initializer</a>&lt;VR&gt;&nbsp;initializer,
                                                     <a href="../../../../../org/apache/kafka/streams/kstream/Aggregator.html" title="interface in org.apache.kafka.streams.kstream">Aggregator</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html" title="type parameter in KGroupedStream">K</a>,? super <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html" title="type parameter in KGroupedStream">V</a>,VR&gt;&nbsp;aggregator,
                                                     <a href="../../../../../org/apache/kafka/streams/kstream/Windows.html" title="class in org.apache.kafka.streams.kstream">Windows</a>&lt;W&gt;&nbsp;windows,
                                                     <a href="../../../../../org/apache/kafka/common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization">Serde</a>&lt;VR&gt;&nbsp;aggValueSerde,
                                                     java.lang.String&nbsp;queryableStoreName)</pre>
<div class="block">Aggregate the values of records in this stream by the grouped key and defined windows.
 Records with <code>null</code> key or value are ignored.
 Aggregating is a generalization of <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html#reduce(org.apache.kafka.streams.kstream.Reducer,%20org.apache.kafka.streams.kstream.Windows,%20java.lang.String)"><code>combining via reduce(...)</code></a> as it,
 for example, allows the result to have a different type than the input values.
 The specified <code>windows</code> define either hopping time windows that can be overlapping or tumbling (c.f.
 <a href="../../../../../org/apache/kafka/streams/kstream/TimeWindows.html" title="class in org.apache.kafka.streams.kstream"><code>TimeWindows</code></a>) or they define landmark windows (c.f. <a href="../../../../../org/apache/kafka/streams/kstream/UnlimitedWindows.html" title="class in org.apache.kafka.streams.kstream"><code>UnlimitedWindows</code></a>).
 The result is written into a local windowed <a href="../../../../../org/apache/kafka/streams/state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state"><code>KeyValueStore</code></a> (which is basically an ever-updating
 materialized view) that can be queried using the provided <code>queryableStoreName</code>.
 Windows are retained until their retention time expires (c.f. <a href="../../../../../org/apache/kafka/streams/kstream/Windows.html#until(long)"><code>Windows.until(long)</code></a>).
 Furthermore, updates to the store are sent downstream into a windowed <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> changelog stream, where
 "windowed" implies that the <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> key is a combined key of the original record key and a window ID.
 <p>
 The specified <a href="../../../../../org/apache/kafka/streams/kstream/Initializer.html" title="interface in org.apache.kafka.streams.kstream"><code>Initializer</code></a> is applied once per window directly before the first input record is
 processed to provide an initial intermediate aggregation result that is used to process the first record.
 The specified <a href="../../../../../org/apache/kafka/streams/kstream/Aggregator.html" title="interface in org.apache.kafka.streams.kstream"><code>Aggregator</code></a> is applied for each input record and computes a new aggregate using the current
 aggregate (or for the very first record using the intermediate aggregation result provided via the
 <a href="../../../../../org/apache/kafka/streams/kstream/Initializer.html" title="interface in org.apache.kafka.streams.kstream"><code>Initializer</code></a>) and the record's value.
 Thus, <code>aggregate(Initializer, Aggregator, Windows, Serde, String)</code> can be used to compute aggregate
 functions like count (c.f. <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html#count(java.lang.String)"><code>count(String)</code></a>).
 <p>
 Not all updates might get sent downstream, as an internal cache is used to deduplicate consecutive updates to
 the same window and key.
 The rate of propagated updates depends on your input data rate, the number of distinct keys, the number of
 parallel running Kafka Streams instances, and the <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html" title="class in org.apache.kafka.streams"><code>configuration</code></a> parameters for
 <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html#CACHE_MAX_BYTES_BUFFERING_CONFIG"><code>cache size</code></a>, and
 <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html#COMMIT_INTERVAL_MS_CONFIG"><code>commit intervall</code></a>.
 <p>
 To query the local windowed <a href="../../../../../org/apache/kafka/streams/state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state"><code>KeyValueStore</code></a> it must be obtained via
 <a href="../../../../../org/apache/kafka/streams/KafkaStreams.html#store(java.lang.String,%20org.apache.kafka.streams.state.QueryableStoreType)"><code>KafkaStreams#store(...)</code></a>:
 <pre class="line-numbers"><code>KafkaStreams streams = ... // some windowed aggregation on value type double
 ReadOnlyWindowStore&lt;String,Long&gt; localWindowStore = streams.store(queryableStoreName, QueryableStoreTypes.&lt;String, Long&gt;windowStore());
 String key = "some-key";
 long fromTime = ...;
 long toTime = ...;
 WindowStoreIterator&lt;Long&gt; aggForKeyForWindows = localWindowStore.fetch(key, timeFrom, timeTo); // key must be local (application state is shared over all running Kafka Streams instances)
 </code></pre>
 For non-local keys, a custom RPC mechanism must be implemented using <a href="../../../../../org/apache/kafka/streams/KafkaStreams.html#allMetadata()"><code>KafkaStreams.allMetadata()</code></a> to
 query the value of the key on a parallel running instance of your Kafka Streams application.
 <p>
 For failure and recovery the store will be backed by an internal changelog topic that will be created in Kafka.
 Therefore, the store name must be a valid Kafka topic name and cannot contain characters other than ASCII
 alphanumerics, '.', '_' and '-'.
 The changelog topic will be named "${applicationId}-${queryableStoreName}-changelog", where "applicationId" is
 user-specified in <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html" title="class in org.apache.kafka.streams"><code>StreamsConfig</code></a> via parameter
 <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html#APPLICATION_ID_CONFIG"><code>APPLICATION_ID_CONFIG</code></a>, "queryableStoreName" is the
 provide <code>queryableStoreName</code>, and "-changelog" is a fixed suffix.
 You can retrieve all generated internal topic names via <a href="../../../../../org/apache/kafka/streams/KafkaStreams.html#toString()"><code>KafkaStreams.toString()</code></a>.</div>
<dl><dt><span class="strong">Type Parameters:</span></dt><dd><code>VR</code> - the value type of the resulting <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a></dd><dt><span class="strong">Parameters:</span></dt><dd><code>initializer</code> - an <a href="../../../../../org/apache/kafka/streams/kstream/Initializer.html" title="interface in org.apache.kafka.streams.kstream"><code>Initializer</code></a> that computes an initial intermediate aggregation result</dd><dd><code>aggregator</code> - an <a href="../../../../../org/apache/kafka/streams/kstream/Aggregator.html" title="interface in org.apache.kafka.streams.kstream"><code>Aggregator</code></a> that computes a new aggregate result</dd><dd><code>windows</code> - the specification of the aggregation <a href="../../../../../org/apache/kafka/streams/kstream/Windows.html" title="class in org.apache.kafka.streams.kstream"><code>Windows</code></a></dd><dd><code>aggValueSerde</code> - aggregate value serdes for materializing the aggregated table,
                      if not specified the default serdes defined in the configs will be used</dd><dd><code>queryableStoreName</code> - the name of the state store created from this operation; valid characters are ASCII
 alphanumerics, '.', '_' and '-'. If <code>null</code> then this will be equivalent to <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html#aggregate(org.apache.kafka.streams.kstream.Initializer,%20org.apache.kafka.streams.kstream.Aggregator,%20org.apache.kafka.streams.kstream.Windows,%20org.apache.kafka.common.serialization.Serde)"><code>aggregate(Initializer, Aggregator, Windows, Serde)</code></a> ()} ()}.</dd>
<dt><span class="strong">Returns:</span></dt><dd>a windowed <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> that contains "update" records with unmodified keys, and values that represent
 the latest (rolling) aggregate for each key within a window</dd></dl>
</li>
</ul>
<a name="aggregate(org.apache.kafka.streams.kstream.Initializer, org.apache.kafka.streams.kstream.Aggregator, org.apache.kafka.streams.kstream.Windows, org.apache.kafka.common.serialization.Serde)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>aggregate</h4>
<pre>&lt;W extends <a href="../../../../../org/apache/kafka/streams/kstream/Window.html" title="class in org.apache.kafka.streams.kstream">Window</a>,VR&gt;&nbsp;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/Windowed.html" title="class in org.apache.kafka.streams.kstream">Windowed</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html" title="type parameter in KGroupedStream">K</a>&gt;,VR&gt;&nbsp;aggregate(<a href="../../../../../org/apache/kafka/streams/kstream/Initializer.html" title="interface in org.apache.kafka.streams.kstream">Initializer</a>&lt;VR&gt;&nbsp;initializer,
                                                     <a href="../../../../../org/apache/kafka/streams/kstream/Aggregator.html" title="interface in org.apache.kafka.streams.kstream">Aggregator</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html" title="type parameter in KGroupedStream">K</a>,? super <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html" title="type parameter in KGroupedStream">V</a>,VR&gt;&nbsp;aggregator,
                                                     <a href="../../../../../org/apache/kafka/streams/kstream/Windows.html" title="class in org.apache.kafka.streams.kstream">Windows</a>&lt;W&gt;&nbsp;windows,
                                                     <a href="../../../../../org/apache/kafka/common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization">Serde</a>&lt;VR&gt;&nbsp;aggValueSerde)</pre>
<div class="block">Aggregate the values of records in this stream by the grouped key and defined windows.
 Records with <code>null</code> key or value are ignored.
 Aggregating is a generalization of <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html#reduce(org.apache.kafka.streams.kstream.Reducer,%20org.apache.kafka.streams.kstream.Windows,%20java.lang.String)"><code>combining via reduce(...)</code></a> as it,
 for example, allows the result to have a different type than the input values.
 The specified <code>windows</code> define either hopping time windows that can be overlapping or tumbling (c.f.
 <a href="../../../../../org/apache/kafka/streams/kstream/TimeWindows.html" title="class in org.apache.kafka.streams.kstream"><code>TimeWindows</code></a>) or they define landmark windows (c.f. <a href="../../../../../org/apache/kafka/streams/kstream/UnlimitedWindows.html" title="class in org.apache.kafka.streams.kstream"><code>UnlimitedWindows</code></a>).
 The result is written into a local windowed <a href="../../../../../org/apache/kafka/streams/state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state"><code>KeyValueStore</code></a> (which is basically an ever-updating
 materialized view) that can be queried using the provided <code>queryableStoreName</code>.
 Windows are retained until their retention time expires (c.f. <a href="../../../../../org/apache/kafka/streams/kstream/Windows.html#until(long)"><code>Windows.until(long)</code></a>).
 Furthermore, updates to the store are sent downstream into a windowed <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> changelog stream, where
 "windowed" implies that the <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> key is a combined key of the original record key and a window ID.
 <p>
 The specified <a href="../../../../../org/apache/kafka/streams/kstream/Initializer.html" title="interface in org.apache.kafka.streams.kstream"><code>Initializer</code></a> is applied once per window directly before the first input record is
 processed to provide an initial intermediate aggregation result that is used to process the first record.
 The specified <a href="../../../../../org/apache/kafka/streams/kstream/Aggregator.html" title="interface in org.apache.kafka.streams.kstream"><code>Aggregator</code></a> is applied for each input record and computes a new aggregate using the current
 aggregate (or for the very first record using the intermediate aggregation result provided via the
 <a href="../../../../../org/apache/kafka/streams/kstream/Initializer.html" title="interface in org.apache.kafka.streams.kstream"><code>Initializer</code></a>) and the record's value.
 Thus, <code>aggregate(Initializer, Aggregator, Windows, Serde, String)</code> can be used to compute aggregate
 functions like count (c.f. <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html#count(java.lang.String)"><code>count(String)</code></a>).
 <p>
 Not all updates might get sent downstream, as an internal cache is used to deduplicate consecutive updates to
 the same window and key.
 The rate of propagated updates depends on your input data rate, the number of distinct keys, the number of
 parallel running Kafka Streams instances, and the <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html" title="class in org.apache.kafka.streams"><code>configuration</code></a> parameters for
 <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html#CACHE_MAX_BYTES_BUFFERING_CONFIG"><code>cache size</code></a>, and
 <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html#COMMIT_INTERVAL_MS_CONFIG"><code>commit intervall</code></a>.
 <p>
 For failure and recovery the store will be backed by an internal changelog topic that will be created in Kafka.
 The changelog topic will be named "${applicationId}-${internalStoreName}-changelog", where "applicationId" is
 user-specified in <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html" title="class in org.apache.kafka.streams"><code>StreamsConfig</code></a> via parameter
 <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html#APPLICATION_ID_CONFIG"><code>APPLICATION_ID_CONFIG</code></a>, "internalStoreName" is an internal name
 and "-changelog" is a fixed suffix.
 Note that the internal store name may not be queriable through Interactive Queries.
 You can retrieve all generated internal topic names via <a href="../../../../../org/apache/kafka/streams/KafkaStreams.html#toString()"><code>KafkaStreams.toString()</code></a>.</div>
<dl><dt><span class="strong">Type Parameters:</span></dt><dd><code>VR</code> - the value type of the resulting <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a></dd><dt><span class="strong">Parameters:</span></dt><dd><code>initializer</code> - an <a href="../../../../../org/apache/kafka/streams/kstream/Initializer.html" title="interface in org.apache.kafka.streams.kstream"><code>Initializer</code></a> that computes an initial intermediate aggregation result</dd><dd><code>aggregator</code> - an <a href="../../../../../org/apache/kafka/streams/kstream/Aggregator.html" title="interface in org.apache.kafka.streams.kstream"><code>Aggregator</code></a> that computes a new aggregate result</dd><dd><code>windows</code> - the specification of the aggregation <a href="../../../../../org/apache/kafka/streams/kstream/Windows.html" title="class in org.apache.kafka.streams.kstream"><code>Windows</code></a></dd><dd><code>aggValueSerde</code> - aggregate value serdes for materializing the aggregated table,
                      if not specified the default serdes defined in the configs will be used</dd>
<dt><span class="strong">Returns:</span></dt><dd>a windowed <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> that contains "update" records with unmodified keys, and values that represent
 the latest (rolling) aggregate for each key within a window</dd></dl>
</li>
</ul>
<a name="aggregate(org.apache.kafka.streams.kstream.Initializer, org.apache.kafka.streams.kstream.Aggregator, org.apache.kafka.streams.kstream.Windows, org.apache.kafka.streams.processor.StateStoreSupplier)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>aggregate</h4>
<pre>&lt;W extends <a href="../../../../../org/apache/kafka/streams/kstream/Window.html" title="class in org.apache.kafka.streams.kstream">Window</a>,VR&gt;&nbsp;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/Windowed.html" title="class in org.apache.kafka.streams.kstream">Windowed</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html" title="type parameter in KGroupedStream">K</a>&gt;,VR&gt;&nbsp;aggregate(<a href="../../../../../org/apache/kafka/streams/kstream/Initializer.html" title="interface in org.apache.kafka.streams.kstream">Initializer</a>&lt;VR&gt;&nbsp;initializer,
                                                     <a href="../../../../../org/apache/kafka/streams/kstream/Aggregator.html" title="interface in org.apache.kafka.streams.kstream">Aggregator</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html" title="type parameter in KGroupedStream">K</a>,? super <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html" title="type parameter in KGroupedStream">V</a>,VR&gt;&nbsp;aggregator,
                                                     <a href="../../../../../org/apache/kafka/streams/kstream/Windows.html" title="class in org.apache.kafka.streams.kstream">Windows</a>&lt;W&gt;&nbsp;windows,
                                                     <a href="../../../../../org/apache/kafka/streams/processor/StateStoreSupplier.html" title="interface in org.apache.kafka.streams.processor">StateStoreSupplier</a>&lt;<a href="../../../../../org/apache/kafka/streams/state/WindowStore.html" title="interface in org.apache.kafka.streams.state">WindowStore</a>&gt;&nbsp;storeSupplier)</pre>
<div class="block">Aggregate the values of records in this stream by the grouped key and defined windows.
 Records with <code>null</code> key or value are ignored.
 Aggregating is a generalization of <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html#reduce(org.apache.kafka.streams.kstream.Reducer,%20org.apache.kafka.streams.kstream.Windows,%20org.apache.kafka.streams.processor.StateStoreSupplier)"><code>combining via
 reduce(...)</code></a> as it, for example, allows the result to have a different type than the input values.
 The specified <code>windows</code> define either hopping time windows that can be overlapping or tumbling (c.f.
 <a href="../../../../../org/apache/kafka/streams/kstream/TimeWindows.html" title="class in org.apache.kafka.streams.kstream"><code>TimeWindows</code></a>) or they define landmark windows (c.f. <a href="../../../../../org/apache/kafka/streams/kstream/UnlimitedWindows.html" title="class in org.apache.kafka.streams.kstream"><code>UnlimitedWindows</code></a>).
 The result is written into a local windowed <a href="../../../../../org/apache/kafka/streams/state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state"><code>KeyValueStore</code></a> (which is basically an ever-updating
 materialized view) provided by the given <code>storeSupplier</code>.
 Windows are retained until their retention time expires (c.f. <a href="../../../../../org/apache/kafka/streams/kstream/Windows.html#until(long)"><code>Windows.until(long)</code></a>).
 Furthermore, updates to the store are sent downstream into a windowed <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> changelog stream, where
 "windowed" implies that the <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> key is a combined key of the original record key and a window ID.
 <p>
 The specified <a href="../../../../../org/apache/kafka/streams/kstream/Initializer.html" title="interface in org.apache.kafka.streams.kstream"><code>Initializer</code></a> is applied once per window directly before the first input record is
 processed to provide an initial intermediate aggregation result that is used to process the first record.
 The specified <a href="../../../../../org/apache/kafka/streams/kstream/Aggregator.html" title="interface in org.apache.kafka.streams.kstream"><code>Aggregator</code></a> is applied for each input record and computes a new aggregate using the current
 aggregate (or for the very first record using the intermediate aggregation result provided via the
 <a href="../../../../../org/apache/kafka/streams/kstream/Initializer.html" title="interface in org.apache.kafka.streams.kstream"><code>Initializer</code></a>) and the record's value.
 Thus, <code>aggregate(Initializer, Aggregator, Windows, StateStoreSupplier)</code> can be used to compute aggregate
 functions like count (c.f. <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html#count(java.lang.String)"><code>count(String)</code></a>).
 <p>
 Not all updates might get sent downstream, as an internal cache is used to deduplicate consecutive updates to
 the same window and key.
 The rate of propagated updates depends on your input data rate, the number of distinct keys, the number of
 parallel running Kafka Streams instances, and the <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html" title="class in org.apache.kafka.streams"><code>configuration</code></a> parameters for
 <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html#CACHE_MAX_BYTES_BUFFERING_CONFIG"><code>cache size</code></a>, and
 <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html#COMMIT_INTERVAL_MS_CONFIG"><code>commit intervall</code></a>.
 <p>
 To query the local windowed <a href="../../../../../org/apache/kafka/streams/state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state"><code>KeyValueStore</code></a> it must be obtained via
 <a href="../../../../../org/apache/kafka/streams/KafkaStreams.html#store(java.lang.String,%20org.apache.kafka.streams.state.QueryableStoreType)"><code>KafkaStreams#store(...)</code></a>.
 Use <a href="../../../../../org/apache/kafka/streams/processor/StateStoreSupplier.html#name()"><code>StateStoreSupplier.name()</code></a> to get the store name:
 <pre class="line-numbers"><code>KafkaStreams streams = ... // some windowed aggregation on value type Long
 Sting queryableStoreName = storeSupplier.name();
 ReadOnlyWindowStore&lt;String,Long&gt; localWindowStore = streams.store(queryableStoreName, QueryableStoreTypes.&lt;String, Long&gt;windowStore());
 String key = "some-key";
 long fromTime = ...;
 long toTime = ...;
 WindowStoreIterator&lt;Long&gt; aggForKeyForWindows = localWindowStore.fetch(key, timeFrom, timeTo); // key must be local (application state is shared over all running Kafka Streams instances)
 </code></pre>
 For non-local keys, a custom RPC mechanism must be implemented using <a href="../../../../../org/apache/kafka/streams/KafkaStreams.html#allMetadata()"><code>KafkaStreams.allMetadata()</code></a> to
 query the value of the key on a parallel running instance of your Kafka Streams application.</div>
<dl><dt><span class="strong">Type Parameters:</span></dt><dd><code>VR</code> - the value type of the resulting <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a></dd><dt><span class="strong">Parameters:</span></dt><dd><code>initializer</code> - an <a href="../../../../../org/apache/kafka/streams/kstream/Initializer.html" title="interface in org.apache.kafka.streams.kstream"><code>Initializer</code></a> that computes an initial intermediate aggregation result</dd><dd><code>aggregator</code> - an <a href="../../../../../org/apache/kafka/streams/kstream/Aggregator.html" title="interface in org.apache.kafka.streams.kstream"><code>Aggregator</code></a> that computes a new aggregate result</dd><dd><code>windows</code> - the specification of the aggregation <a href="../../../../../org/apache/kafka/streams/kstream/Windows.html" title="class in org.apache.kafka.streams.kstream"><code>Windows</code></a></dd><dd><code>storeSupplier</code> - user defined state store supplier. Cannot be <code>null</code>.</dd>
<dt><span class="strong">Returns:</span></dt><dd>a windowed <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> that contains "update" records with unmodified keys, and values that represent
 the latest (rolling) aggregate for each key within a window</dd></dl>
</li>
</ul>
<a name="aggregate(org.apache.kafka.streams.kstream.Initializer, org.apache.kafka.streams.kstream.Aggregator, org.apache.kafka.streams.kstream.Merger, org.apache.kafka.streams.kstream.SessionWindows, org.apache.kafka.common.serialization.Serde, java.lang.String)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>aggregate</h4>
<pre>&lt;T&gt;&nbsp;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/Windowed.html" title="class in org.apache.kafka.streams.kstream">Windowed</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html" title="type parameter in KGroupedStream">K</a>&gt;,T&gt;&nbsp;aggregate(<a href="../../../../../org/apache/kafka/streams/kstream/Initializer.html" title="interface in org.apache.kafka.streams.kstream">Initializer</a>&lt;T&gt;&nbsp;initializer,
                                  <a href="../../../../../org/apache/kafka/streams/kstream/Aggregator.html" title="interface in org.apache.kafka.streams.kstream">Aggregator</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html" title="type parameter in KGroupedStream">K</a>,? super <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html" title="type parameter in KGroupedStream">V</a>,T&gt;&nbsp;aggregator,
                                  <a href="../../../../../org/apache/kafka/streams/kstream/Merger.html" title="interface in org.apache.kafka.streams.kstream">Merger</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html" title="type parameter in KGroupedStream">K</a>,T&gt;&nbsp;sessionMerger,
                                  <a href="../../../../../org/apache/kafka/streams/kstream/SessionWindows.html" title="class in org.apache.kafka.streams.kstream">SessionWindows</a>&nbsp;sessionWindows,
                                  <a href="../../../../../org/apache/kafka/common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization">Serde</a>&lt;T&gt;&nbsp;aggValueSerde,
                                  java.lang.String&nbsp;queryableStoreName)</pre>
<div class="block">Aggregate the values of records in this stream by the grouped key and defined <a href="../../../../../org/apache/kafka/streams/kstream/SessionWindows.html" title="class in org.apache.kafka.streams.kstream"><code>SessionWindows</code></a>.
 Records with <code>null</code> key or value are ignored.
 Aggregating is a generalization of <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html#reduce(org.apache.kafka.streams.kstream.Reducer,%20org.apache.kafka.streams.kstream.SessionWindows,%20java.lang.String)"><code>combining via
 reduce(...)</code></a> as it, for example, allows the result to have a different type than the input values.
 The result is written into a local <a href="../../../../../org/apache/kafka/streams/state/SessionStore.html" title="interface in org.apache.kafka.streams.state"><code>SessionStore</code></a> (which is basically an ever-updating
 materialized view) that can be queried using the provided <code>queryableStoreName</code>.
 SessionWindows are retained until their retention time expires (c.f. <a href="../../../../../org/apache/kafka/streams/kstream/SessionWindows.html#until(long)"><code>SessionWindows.until(long)</code></a>).
 Furthermore, updates to the store are sent downstream into a windowed <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> changelog stream, where
 "windowed" implies that the <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> key is a combined key of the original record key and a window ID.
 <p>
 The specified <a href="../../../../../org/apache/kafka/streams/kstream/Initializer.html" title="interface in org.apache.kafka.streams.kstream"><code>Initializer</code></a> is applied once per session directly before the first input record is
 processed to provide an initial intermediate aggregation result that is used to process the first record.
 The specified <a href="../../../../../org/apache/kafka/streams/kstream/Aggregator.html" title="interface in org.apache.kafka.streams.kstream"><code>Aggregator</code></a> is applied for each input record and computes a new aggregate using the current
 aggregate (or for the very first record using the intermediate aggregation result provided via the
 <a href="../../../../../org/apache/kafka/streams/kstream/Initializer.html" title="interface in org.apache.kafka.streams.kstream"><code>Initializer</code></a>) and the record's value.
 Thus, <code>aggregate(Initializer, Aggregator, Merger, SessionWindows, Serde, String)</code> can be used to compute
 aggregate functions like count (c.f. <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html#count(java.lang.String)"><code>count(String)</code></a>)
 <p>
 Not all updates might get sent downstream, as an internal cache is used to deduplicate consecutive updates to
 the same window and key.
 The rate of propagated updates depends on your input data rate, the number of distinct keys, the number of
 parallel running Kafka Streams instances, and the <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html" title="class in org.apache.kafka.streams"><code>configuration</code></a> parameters for
 <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html#CACHE_MAX_BYTES_BUFFERING_CONFIG"><code>cache size</code></a>, and
 <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html#COMMIT_INTERVAL_MS_CONFIG"><code>commit intervall</code></a>.
 <p>
 To query the local <a href="../../../../../org/apache/kafka/streams/state/SessionStore.html" title="interface in org.apache.kafka.streams.state"><code>SessionStore</code></a> it must be obtained via
 <a href="../../../../../org/apache/kafka/streams/KafkaStreams.html#store(java.lang.String,%20org.apache.kafka.streams.state.QueryableStoreType)"><code>KafkaStreams#store(...)</code></a>.
 Use <a href="../../../../../org/apache/kafka/streams/processor/StateStoreSupplier.html#name()"><code>StateStoreSupplier.name()</code></a> to get the store name:
 <pre class="line-numbers"><code>KafkaStreams streams = ... // some windowed aggregation on value type double
 Sting queryableStoreName = storeSupplier.name();
 ReadOnlySessionStore&lt;String, Long&gt; sessionStore = streams.store(queryableStoreName, QueryableStoreTypes.&lt;String, Long&gt;sessionStore());
 String key = "some-key";
 KeyValueIterator&lt;Windowed&lt;String&gt;, Long&gt; aggForKeyForSession = localWindowStore.fetch(key); // key must be local (application state is shared over all running Kafka Streams instances)
 </code></pre>
 For non-local keys, a custom RPC mechanism must be implemented using <a href="../../../../../org/apache/kafka/streams/KafkaStreams.html#allMetadata()"><code>KafkaStreams.allMetadata()</code></a> to
 query the value of the key on a parallel running instance of your Kafka Streams application.</div>
<dl><dt><span class="strong">Type Parameters:</span></dt><dd><code>T</code> - the value type of the resulting <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a></dd><dt><span class="strong">Parameters:</span></dt><dd><code>initializer</code> - the instance of <a href="../../../../../org/apache/kafka/streams/kstream/Initializer.html" title="interface in org.apache.kafka.streams.kstream"><code>Initializer</code></a></dd><dd><code>aggregator</code> - the instance of <a href="../../../../../org/apache/kafka/streams/kstream/Aggregator.html" title="interface in org.apache.kafka.streams.kstream"><code>Aggregator</code></a></dd><dd><code>sessionMerger</code> - the instance of <a href="../../../../../org/apache/kafka/streams/kstream/Merger.html" title="interface in org.apache.kafka.streams.kstream"><code>Merger</code></a></dd><dd><code>sessionWindows</code> - the specification of the aggregation <a href="../../../../../org/apache/kafka/streams/kstream/SessionWindows.html" title="class in org.apache.kafka.streams.kstream"><code>SessionWindows</code></a></dd><dd><code>aggValueSerde</code> - aggregate value serdes for materializing the aggregated table,
                      if not specified the default serdes defined in the configs will be used</dd><dd><code>queryableStoreName</code> - the name of the state store created from this operation; valid characters are ASCII
 alphanumerics, '.', '_' and '-'. If <code>null</code> then this will be equivalent to <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html#aggregate(org.apache.kafka.streams.kstream.Initializer,%20org.apache.kafka.streams.kstream.Aggregator,%20org.apache.kafka.streams.kstream.Merger,%20org.apache.kafka.streams.kstream.SessionWindows,%20org.apache.kafka.common.serialization.Serde)"><code>aggregate(Initializer, Aggregator, Merger, SessionWindows, Serde)</code></a> ()} ()}.</dd>
<dt><span class="strong">Returns:</span></dt><dd>a windowed <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> that contains "update" records with unmodified keys, and values that represent
 the latest (rolling) aggregate for each key within a window</dd></dl>
</li>
</ul>
<a name="aggregate(org.apache.kafka.streams.kstream.Initializer, org.apache.kafka.streams.kstream.Aggregator, org.apache.kafka.streams.kstream.Merger, org.apache.kafka.streams.kstream.SessionWindows, org.apache.kafka.common.serialization.Serde)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>aggregate</h4>
<pre>&lt;T&gt;&nbsp;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/Windowed.html" title="class in org.apache.kafka.streams.kstream">Windowed</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html" title="type parameter in KGroupedStream">K</a>&gt;,T&gt;&nbsp;aggregate(<a href="../../../../../org/apache/kafka/streams/kstream/Initializer.html" title="interface in org.apache.kafka.streams.kstream">Initializer</a>&lt;T&gt;&nbsp;initializer,
                                  <a href="../../../../../org/apache/kafka/streams/kstream/Aggregator.html" title="interface in org.apache.kafka.streams.kstream">Aggregator</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html" title="type parameter in KGroupedStream">K</a>,? super <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html" title="type parameter in KGroupedStream">V</a>,T&gt;&nbsp;aggregator,
                                  <a href="../../../../../org/apache/kafka/streams/kstream/Merger.html" title="interface in org.apache.kafka.streams.kstream">Merger</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html" title="type parameter in KGroupedStream">K</a>,T&gt;&nbsp;sessionMerger,
                                  <a href="../../../../../org/apache/kafka/streams/kstream/SessionWindows.html" title="class in org.apache.kafka.streams.kstream">SessionWindows</a>&nbsp;sessionWindows,
                                  <a href="../../../../../org/apache/kafka/common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization">Serde</a>&lt;T&gt;&nbsp;aggValueSerde)</pre>
<div class="block">Aggregate the values of records in this stream by the grouped key and defined <a href="../../../../../org/apache/kafka/streams/kstream/SessionWindows.html" title="class in org.apache.kafka.streams.kstream"><code>SessionWindows</code></a>.
 Records with <code>null</code> key or value are ignored.
 Aggregating is a generalization of <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html#reduce(org.apache.kafka.streams.kstream.Reducer,%20org.apache.kafka.streams.kstream.SessionWindows,%20java.lang.String)"><code>combining via
 reduce(...)</code></a> as it, for example, allows the result to have a different type than the input values.
 The result is written into a local <a href="../../../../../org/apache/kafka/streams/state/SessionStore.html" title="interface in org.apache.kafka.streams.state"><code>SessionStore</code></a> (which is basically an ever-updating
 materialized view) that can be queried using the provided <code>queryableStoreName</code>.
 SessionWindows are retained until their retention time expires (c.f. <a href="../../../../../org/apache/kafka/streams/kstream/SessionWindows.html#until(long)"><code>SessionWindows.until(long)</code></a>).
 Furthermore, updates to the store are sent downstream into a windowed <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> changelog stream, where
 "windowed" implies that the <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> key is a combined key of the original record key and a window ID.
 <p>
 The specified <a href="../../../../../org/apache/kafka/streams/kstream/Initializer.html" title="interface in org.apache.kafka.streams.kstream"><code>Initializer</code></a> is applied once per session directly before the first input record is
 processed to provide an initial intermediate aggregation result that is used to process the first record.
 The specified <a href="../../../../../org/apache/kafka/streams/kstream/Aggregator.html" title="interface in org.apache.kafka.streams.kstream"><code>Aggregator</code></a> is applied for each input record and computes a new aggregate using the current
 aggregate (or for the very first record using the intermediate aggregation result provided via the
 <a href="../../../../../org/apache/kafka/streams/kstream/Initializer.html" title="interface in org.apache.kafka.streams.kstream"><code>Initializer</code></a>) and the record's value.
 Thus, <code>aggregate(Initializer, Aggregator, Merger, SessionWindows, Serde, String)</code> can be used to compute
 aggregate functions like count (c.f. <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html#count(java.lang.String)"><code>count(String)</code></a>)
 <p>
 Not all updates might get sent downstream, as an internal cache is used to deduplicate consecutive updates to
 the same window and key.
 The rate of propagated updates depends on your input data rate, the number of distinct keys, the number of
 parallel running Kafka Streams instances, and the <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html" title="class in org.apache.kafka.streams"><code>configuration</code></a> parameters for
 <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html#CACHE_MAX_BYTES_BUFFERING_CONFIG"><code>cache size</code></a>, and
 <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html#COMMIT_INTERVAL_MS_CONFIG"><code>commit intervall</code></a>.
 <p></div>
<dl><dt><span class="strong">Type Parameters:</span></dt><dd><code>T</code> - the value type of the resulting <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a></dd><dt><span class="strong">Parameters:</span></dt><dd><code>initializer</code> - the instance of <a href="../../../../../org/apache/kafka/streams/kstream/Initializer.html" title="interface in org.apache.kafka.streams.kstream"><code>Initializer</code></a></dd><dd><code>aggregator</code> - the instance of <a href="../../../../../org/apache/kafka/streams/kstream/Aggregator.html" title="interface in org.apache.kafka.streams.kstream"><code>Aggregator</code></a></dd><dd><code>sessionMerger</code> - the instance of <a href="../../../../../org/apache/kafka/streams/kstream/Merger.html" title="interface in org.apache.kafka.streams.kstream"><code>Merger</code></a></dd><dd><code>sessionWindows</code> - the specification of the aggregation <a href="../../../../../org/apache/kafka/streams/kstream/SessionWindows.html" title="class in org.apache.kafka.streams.kstream"><code>SessionWindows</code></a></dd><dd><code>aggValueSerde</code> - aggregate value serdes for materializing the aggregated table,
                      if not specified the default serdes defined in the configs will be used</dd>
<dt><span class="strong">Returns:</span></dt><dd>a windowed <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> that contains "update" records with unmodified keys, and values that represent
 the latest (rolling) aggregate for each key within a window</dd></dl>
</li>
</ul>
<a name="aggregate(org.apache.kafka.streams.kstream.Initializer, org.apache.kafka.streams.kstream.Aggregator, org.apache.kafka.streams.kstream.Merger, org.apache.kafka.streams.kstream.SessionWindows, org.apache.kafka.common.serialization.Serde, org.apache.kafka.streams.processor.StateStoreSupplier)">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>aggregate</h4>
<pre>&lt;T&gt;&nbsp;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/Windowed.html" title="class in org.apache.kafka.streams.kstream">Windowed</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html" title="type parameter in KGroupedStream">K</a>&gt;,T&gt;&nbsp;aggregate(<a href="../../../../../org/apache/kafka/streams/kstream/Initializer.html" title="interface in org.apache.kafka.streams.kstream">Initializer</a>&lt;T&gt;&nbsp;initializer,
                                  <a href="../../../../../org/apache/kafka/streams/kstream/Aggregator.html" title="interface in org.apache.kafka.streams.kstream">Aggregator</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html" title="type parameter in KGroupedStream">K</a>,? super <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html" title="type parameter in KGroupedStream">V</a>,T&gt;&nbsp;aggregator,
                                  <a href="../../../../../org/apache/kafka/streams/kstream/Merger.html" title="interface in org.apache.kafka.streams.kstream">Merger</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html" title="type parameter in KGroupedStream">K</a>,T&gt;&nbsp;sessionMerger,
                                  <a href="../../../../../org/apache/kafka/streams/kstream/SessionWindows.html" title="class in org.apache.kafka.streams.kstream">SessionWindows</a>&nbsp;sessionWindows,
                                  <a href="../../../../../org/apache/kafka/common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization">Serde</a>&lt;T&gt;&nbsp;aggValueSerde,
                                  <a href="../../../../../org/apache/kafka/streams/processor/StateStoreSupplier.html" title="interface in org.apache.kafka.streams.processor">StateStoreSupplier</a>&lt;<a href="../../../../../org/apache/kafka/streams/state/SessionStore.html" title="interface in org.apache.kafka.streams.state">SessionStore</a>&gt;&nbsp;storeSupplier)</pre>
<div class="block">Aggregate the values of records in this stream by the grouped key and defined <a href="../../../../../org/apache/kafka/streams/kstream/SessionWindows.html" title="class in org.apache.kafka.streams.kstream"><code>SessionWindows</code></a>.
 Records with <code>null</code> key or value are ignored.
 Aggregating is a generalization of <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html#reduce(org.apache.kafka.streams.kstream.Reducer,%20org.apache.kafka.streams.kstream.SessionWindows,%20java.lang.String)"><code>combining via
 reduce(...)</code></a> as it, for example, allows the result to have a different type than the input values.
 The result is written into a local <a href="../../../../../org/apache/kafka/streams/state/SessionStore.html" title="interface in org.apache.kafka.streams.state"><code>SessionStore</code></a> (which is basically an ever-updating materialized view)
 provided by the given <code>storeSupplier</code>.
 SessionWindows are retained until their retention time expires (c.f. <a href="../../../../../org/apache/kafka/streams/kstream/SessionWindows.html#until(long)"><code>SessionWindows.until(long)</code></a>).
 Furthermore, updates to the store are sent downstream into a windowed <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> changelog stream, where
 "windowed" implies that the <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> key is a combined key of the original record key and a window ID.
 <p>
 The specified <a href="../../../../../org/apache/kafka/streams/kstream/Initializer.html" title="interface in org.apache.kafka.streams.kstream"><code>Initializer</code></a> is applied once per session directly before the first input record is
 processed to provide an initial intermediate aggregation result that is used to process the first record.
 The specified <a href="../../../../../org/apache/kafka/streams/kstream/Aggregator.html" title="interface in org.apache.kafka.streams.kstream"><code>Aggregator</code></a> is applied for each input record and computes a new aggregate using the current
 aggregate (or for the very first record using the intermediate aggregation result provided via the
 <a href="../../../../../org/apache/kafka/streams/kstream/Initializer.html" title="interface in org.apache.kafka.streams.kstream"><code>Initializer</code></a>) and the record's value.
 Thus, <code>#aggregate(Initializer, Aggregator, Merger, SessionWindows, Serde, StateStoreSupplier)</code> can be used
 to compute aggregate functions like count (c.f. <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedStream.html#count(java.lang.String)"><code>count(String)</code></a>).
 <p>
 Not all updates might get sent downstream, as an internal cache is used to deduplicate consecutive updates to
 the same window and key.
 The rate of propagated updates depends on your input data rate, the number of distinct keys, the number of
 parallel running Kafka Streams instances, and the <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html" title="class in org.apache.kafka.streams"><code>configuration</code></a> parameters for
 <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html#CACHE_MAX_BYTES_BUFFERING_CONFIG"><code>cache size</code></a>, and
 <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html#COMMIT_INTERVAL_MS_CONFIG"><code>commit intervall</code></a>.
 <p>
 To query the local <a href="../../../../../org/apache/kafka/streams/state/SessionStore.html" title="interface in org.apache.kafka.streams.state"><code>SessionStore</code></a> it must be obtained via
 <a href="../../../../../org/apache/kafka/streams/KafkaStreams.html#store(java.lang.String,%20org.apache.kafka.streams.state.QueryableStoreType)"><code>KafkaStreams#store(...)</code></a>.
 Use <a href="../../../../../org/apache/kafka/streams/processor/StateStoreSupplier.html#name()"><code>StateStoreSupplier.name()</code></a> to get the store name:
 <pre class="line-numbers"><code>KafkaStreams streams = ... // some windowed aggregation on value type double
 Sting queryableStoreName = storeSupplier.name();
 ReadOnlySessionStore&lt;String, Long&gt; sessionStore = streams.store(queryableStoreName, QueryableStoreTypes.&lt;String, Long&gt;sessionStore());
 String key = "some-key";
 KeyValueIterator&lt;Windowed&lt;String&gt;, Long&gt; aggForKeyForSession = localWindowStore.fetch(key); // key must be local (application state is shared over all running Kafka Streams instances)
 </code></pre>
 For non-local keys, a custom RPC mechanism must be implemented using <a href="../../../../../org/apache/kafka/streams/KafkaStreams.html#allMetadata()"><code>KafkaStreams.allMetadata()</code></a> to
 query the value of the key on a parallel running instance of your Kafka Streams application.</div>
<dl><dt><span class="strong">Type Parameters:</span></dt><dd><code>T</code> - the value type of the resulting <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a></dd><dt><span class="strong">Parameters:</span></dt><dd><code>initializer</code> - the instance of <a href="../../../../../org/apache/kafka/streams/kstream/Initializer.html" title="interface in org.apache.kafka.streams.kstream"><code>Initializer</code></a></dd><dd><code>aggregator</code> - the instance of <a href="../../../../../org/apache/kafka/streams/kstream/Aggregator.html" title="interface in org.apache.kafka.streams.kstream"><code>Aggregator</code></a></dd><dd><code>sessionMerger</code> - the instance of <a href="../../../../../org/apache/kafka/streams/kstream/Merger.html" title="interface in org.apache.kafka.streams.kstream"><code>Merger</code></a></dd><dd><code>sessionWindows</code> - the specification of the aggregation <a href="../../../../../org/apache/kafka/streams/kstream/SessionWindows.html" title="class in org.apache.kafka.streams.kstream"><code>SessionWindows</code></a></dd><dd><code>aggValueSerde</code> - aggregate value serdes for materializing the aggregated table,
                       if not specified the default serdes defined in the configs will be used</dd><dd><code>storeSupplier</code> - user defined state store supplier. Cannot be <code>null</code>.</dd>
<dt><span class="strong">Returns:</span></dt><dd>a windowed <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> that contains "update" records with unmodified keys, and values that represent
 the latest (rolling) aggregate for each key within a window</dd></dl>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<!-- ========= END OF CLASS DATA ========= -->
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a name="navbar_bottom">
<!--   -->
</a><a href="#skip-navbar_bottom" title="Skip navigation links"></a><a name="navbar_bottom_firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../../../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../../index-all.html">Index</a></li>
<li><a href="../../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../../../../org/apache/kafka/streams/kstream/KeyValueMapper.html" title="interface in org.apache.kafka.streams.kstream"><span class="strong">Prev Class</span></a></li>
<li><a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html" title="interface in org.apache.kafka.streams.kstream"><span class="strong">Next Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../../../../index.html?org/apache/kafka/streams/kstream/KGroupedStream.html" target="_top">Frames</a></li>
<li><a href="KGroupedStream.html" target="_top">No Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="../../../../../allclasses-noframe.html">All Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method_summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method_detail">Method</a></li>
</ul>
</div>
<a name="skip-navbar_bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
</body>
</html>

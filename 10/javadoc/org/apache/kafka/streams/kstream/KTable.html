<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (1.8.0_74) on Mon Mar 05 13:44:00 PST 2018 -->
<title>KTable (kafka 1.0.1 API)</title>
<meta name="date" content="2018-03-05">
<link rel="stylesheet" type="text/css" href="../../../../../stylesheet.css" title="Style">
<script type="text/javascript" src="../../../../../script.js"></script>
</head>
<body>
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="KTable (kafka 1.0.1 API)";
        }
    }
    catch(err) {
    }
//-->
var methods = {"i0":6,"i1":6,"i2":38,"i3":38,"i4":6,"i5":6,"i6":38,"i7":38,"i8":38,"i9":6,"i10":38,"i11":6,"i12":6,"i13":6,"i14":38,"i15":38,"i16":6,"i17":6,"i18":38,"i19":38,"i20":6,"i21":6,"i22":38,"i23":38,"i24":6,"i25":6,"i26":38,"i27":38,"i28":38,"i29":38,"i30":38,"i31":38,"i32":6,"i33":38,"i34":38,"i35":38,"i36":38,"i37":38,"i38":38,"i39":38,"i40":38,"i41":38,"i42":38,"i43":38,"i44":38,"i45":38,"i46":38,"i47":38,"i48":38,"i49":6,"i50":6,"i51":38,"i52":38,"i53":38,"i54":38};
var tabs = {65535:["t0","All Methods"],2:["t2","Instance Methods"],4:["t3","Abstract Methods"],32:["t6","Deprecated Methods"]};
var altColor = "altColor";
var rowColor = "rowColor";
var tableTab = "tableTab";
var activeTableTab = "activeTableTab";
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a name="navbar.top">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<a name="navbar.top.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../../../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../../index-all.html">Index</a></li>
<li><a href="../../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../../../../org/apache/kafka/streams/kstream/KStreamBuilder.html" title="class in org.apache.kafka.streams.kstream"><span class="typeNameLink">Prev&nbsp;Class</span></a></li>
<li><a href="../../../../../org/apache/kafka/streams/kstream/Materialized.html" title="class in org.apache.kafka.streams.kstream"><span class="typeNameLink">Next&nbsp;Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../../../../index.html?org/apache/kafka/streams/kstream/KTable.html" target="_top">Frames</a></li>
<li><a href="KTable.html" target="_top">No&nbsp;Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_top">
<li><a href="../../../../../allclasses-noframe.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a name="skip.navbar.top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="subTitle">org.apache.kafka.streams.kstream</div>
<h2 title="Interface KTable" class="title">Interface KTable&lt;K,V&gt;</h2>
</div>
<div class="contentContainer">
<div class="description">
<ul class="blockList">
<li class="blockList">
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>K</code> - Type of primary keys</dd>
<dd><code>V</code> - Type of value changes</dd>
</dl>
<hr>
<br>
<pre><a href="../../../../../org/apache/kafka/common/annotation/InterfaceStability.Evolving.html" title="annotation in org.apache.kafka.common.annotation">@InterfaceStability.Evolving</a>
public interface <span class="typeNameLabel">KTable&lt;K,V&gt;</span></pre>
<div class="block"><code>KTable</code> is an abstraction of a <i>changelog stream</i> from a primary-keyed table.
 Each record in this changelog stream is an update on the primary-keyed table with the record key as the primary key.
 <p>
 A <code>KTable</code> is either <a href="../../../../../org/apache/kafka/streams/StreamsBuilder.html#table-java.lang.String-"><code>defined from a single Kafka topic</code></a> that is
 consumed message by message or the result of a <code>KTable</code> transformation.
 An aggregation of a <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="interface in org.apache.kafka.streams.kstream"><code>KStream</code></a> also yields a <code>KTable</code>.
 <p>
 A <code>KTable</code> can be transformed record by record, joined with another <code>KTable</code> or <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="interface in org.apache.kafka.streams.kstream"><code>KStream</code></a>, or
 can be re-partitioned and aggregated into a new <code>KTable</code>.
 <p>
 Some <code>KTable</code>s have an internal state (a <a href="../../../../../org/apache/kafka/streams/state/ReadOnlyKeyValueStore.html" title="interface in org.apache.kafka.streams.state"><code>ReadOnlyKeyValueStore</code></a>) and are therefore queryable via the
 interactive queries API.
 For example:
 <pre><code>
     final KTable table = ...
     ...
     final KafkaStreams streams = ...;
     streams.start()
     ...
     final String queryableStoreName = table.queryableStoreName(); // returns null if KTable is not queryable
     ReadOnlyKeyValueStore view = streams.store(queryableStoreName, QueryableStoreTypes.keyValueStore());
     view.get(key);
</code></pre>
<p>
 Records from the source topic that have null keys are dropped.</div>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="interface in org.apache.kafka.streams.kstream"><code>KStream</code></a>, 
<a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KGroupedTable</code></a>, 
<a href="../../../../../org/apache/kafka/streams/kstream/GlobalKTable.html" title="interface in org.apache.kafka.streams.kstream"><code>GlobalKTable</code></a>, 
<a href="../../../../../org/apache/kafka/streams/StreamsBuilder.html#table-java.lang.String-"><code>StreamsBuilder.table(String)</code></a></dd>
</dl>
</li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- ========== METHOD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="method.summary">
<!--   -->
</a>
<h3>Method Summary</h3>
<table class="memberSummary" border="0" cellpadding="3" cellspacing="0" summary="Method Summary table, listing methods, and an explanation">
<caption><span id="t0" class="activeTableTab"><span>All Methods</span><span class="tabEnd">&nbsp;</span></span><span id="t2" class="tableTab"><span><a href="javascript:show(2);">Instance Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t3" class="tableTab"><span><a href="javascript:show(4);">Abstract Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t6" class="tableTab"><span><a href="javascript:show(32);">Deprecated Methods</a></span><span class="tabEnd">&nbsp;</span></span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Method and Description</th>
</tr>
<tr id="i0" class="altColor">
<td class="colFirst"><code><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#filter-org.apache.kafka.streams.kstream.Predicate-">filter</a></span>(<a href="../../../../../org/apache/kafka/streams/kstream/Predicate.html" title="interface in org.apache.kafka.streams.kstream">Predicate</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,? super <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>&gt;&nbsp;predicate)</code>
<div class="block">Create a new <code>KTable</code> that consists of all records of this <code>KTable</code> which satisfy the given
 predicate.</div>
</td>
</tr>
<tr id="i1" class="rowColor">
<td class="colFirst"><code><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#filter-org.apache.kafka.streams.kstream.Predicate-org.apache.kafka.streams.kstream.Materialized-">filter</a></span>(<a href="../../../../../org/apache/kafka/streams/kstream/Predicate.html" title="interface in org.apache.kafka.streams.kstream">Predicate</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,? super <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>&gt;&nbsp;predicate,
      <a href="../../../../../org/apache/kafka/streams/kstream/Materialized.html" title="class in org.apache.kafka.streams.kstream">Materialized</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>,<a href="../../../../../org/apache/kafka/streams/state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state">KeyValueStore</a>&lt;org.apache.kafka.common.utils.Bytes,byte[]&gt;&gt;&nbsp;materialized)</code>
<div class="block">Create a new <code>KTable</code> that consists of all records of this <code>KTable</code> which satisfy the given
 predicate.</div>
</td>
</tr>
<tr id="i2" class="altColor">
<td class="colFirst"><code><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#filter-org.apache.kafka.streams.kstream.Predicate-org.apache.kafka.streams.processor.StateStoreSupplier-">filter</a></span>(<a href="../../../../../org/apache/kafka/streams/kstream/Predicate.html" title="interface in org.apache.kafka.streams.kstream">Predicate</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,? super <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>&gt;&nbsp;predicate,
      <a href="../../../../../org/apache/kafka/streams/processor/StateStoreSupplier.html" title="interface in org.apache.kafka.streams.processor">StateStoreSupplier</a>&lt;<a href="../../../../../org/apache/kafka/streams/state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state">KeyValueStore</a>&gt;&nbsp;storeSupplier)</code>
<div class="block"><span class="deprecatedLabel">Deprecated.</span>&nbsp;
<div class="block"><span class="deprecationComment">use <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#filter-org.apache.kafka.streams.kstream.Predicate-org.apache.kafka.streams.kstream.Materialized-"><code>filter(predicate, Materialized.as(KeyValueByteStoreSupplier))</code></a></span></div>
</div>
</td>
</tr>
<tr id="i3" class="rowColor">
<td class="colFirst"><code><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#filter-org.apache.kafka.streams.kstream.Predicate-java.lang.String-">filter</a></span>(<a href="../../../../../org/apache/kafka/streams/kstream/Predicate.html" title="interface in org.apache.kafka.streams.kstream">Predicate</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,? super <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>&gt;&nbsp;predicate,
      java.lang.String&nbsp;queryableStoreName)</code>
<div class="block"><span class="deprecatedLabel">Deprecated.</span>&nbsp;
<div class="block"><span class="deprecationComment">use <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#filter-org.apache.kafka.streams.kstream.Predicate-org.apache.kafka.streams.kstream.Materialized-"><code>filter(predicate, Materialized.as(queryableStoreName))</code></a></span></div>
</div>
</td>
</tr>
<tr id="i4" class="altColor">
<td class="colFirst"><code><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#filterNot-org.apache.kafka.streams.kstream.Predicate-">filterNot</a></span>(<a href="../../../../../org/apache/kafka/streams/kstream/Predicate.html" title="interface in org.apache.kafka.streams.kstream">Predicate</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,? super <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>&gt;&nbsp;predicate)</code>
<div class="block">Create a new <code>KTable</code> that consists all records of this <code>KTable</code> which do <em>not</em> satisfy the
 given predicate.</div>
</td>
</tr>
<tr id="i5" class="rowColor">
<td class="colFirst"><code><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#filterNot-org.apache.kafka.streams.kstream.Predicate-org.apache.kafka.streams.kstream.Materialized-">filterNot</a></span>(<a href="../../../../../org/apache/kafka/streams/kstream/Predicate.html" title="interface in org.apache.kafka.streams.kstream">Predicate</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,? super <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>&gt;&nbsp;predicate,
         <a href="../../../../../org/apache/kafka/streams/kstream/Materialized.html" title="class in org.apache.kafka.streams.kstream">Materialized</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>,<a href="../../../../../org/apache/kafka/streams/state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state">KeyValueStore</a>&lt;org.apache.kafka.common.utils.Bytes,byte[]&gt;&gt;&nbsp;materialized)</code>
<div class="block">Create a new <code>KTable</code> that consists all records of this <code>KTable</code> which do <em>not</em> satisfy the
 given predicate.</div>
</td>
</tr>
<tr id="i6" class="altColor">
<td class="colFirst"><code><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#filterNot-org.apache.kafka.streams.kstream.Predicate-org.apache.kafka.streams.processor.StateStoreSupplier-">filterNot</a></span>(<a href="../../../../../org/apache/kafka/streams/kstream/Predicate.html" title="interface in org.apache.kafka.streams.kstream">Predicate</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,? super <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>&gt;&nbsp;predicate,
         <a href="../../../../../org/apache/kafka/streams/processor/StateStoreSupplier.html" title="interface in org.apache.kafka.streams.processor">StateStoreSupplier</a>&lt;<a href="../../../../../org/apache/kafka/streams/state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state">KeyValueStore</a>&gt;&nbsp;storeSupplier)</code>
<div class="block"><span class="deprecatedLabel">Deprecated.</span>&nbsp;
<div class="block"><span class="deprecationComment">use <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#filterNot-org.apache.kafka.streams.kstream.Predicate-org.apache.kafka.streams.kstream.Materialized-"><code>filterNot(predicate, Materialized.as(KeyValueByteStoreSupplier))</code></a></span></div>
</div>
</td>
</tr>
<tr id="i7" class="rowColor">
<td class="colFirst"><code><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#filterNot-org.apache.kafka.streams.kstream.Predicate-java.lang.String-">filterNot</a></span>(<a href="../../../../../org/apache/kafka/streams/kstream/Predicate.html" title="interface in org.apache.kafka.streams.kstream">Predicate</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,? super <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>&gt;&nbsp;predicate,
         java.lang.String&nbsp;queryableStoreName)</code>
<div class="block"><span class="deprecatedLabel">Deprecated.</span>&nbsp;
<div class="block"><span class="deprecationComment">use <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#filter-org.apache.kafka.streams.kstream.Predicate-org.apache.kafka.streams.kstream.Materialized-"><code>filterNot(predicate, Materialized.as(queryableStoreName))</code></a></span></div>
</div>
</td>
</tr>
<tr id="i8" class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#foreach-org.apache.kafka.streams.kstream.ForeachAction-">foreach</a></span>(<a href="../../../../../org/apache/kafka/streams/kstream/ForeachAction.html" title="interface in org.apache.kafka.streams.kstream">ForeachAction</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,? super <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>&gt;&nbsp;action)</code>
<div class="block"><span class="deprecatedLabel">Deprecated.</span>&nbsp;
<div class="block"><span class="deprecationComment">Use the Interactive Queries APIs (e.g., <a href="../../../../../org/apache/kafka/streams/KafkaStreams.html#store-java.lang.String-org.apache.kafka.streams.state.QueryableStoreType-"><code>KafkaStreams.store(String, QueryableStoreType)</code></a>
 followed by <a href="../../../../../org/apache/kafka/streams/state/ReadOnlyKeyValueStore.html#all--"><code>ReadOnlyKeyValueStore.all()</code></a>) to iterate over the keys of a KTable. Alternatively
 convert to a <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="interface in org.apache.kafka.streams.kstream"><code>KStream</code></a> using <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#toStream--"><code>toStream()</code></a> and then use
 <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#foreach-org.apache.kafka.streams.kstream.ForeachAction-"><code>foreach(action)</code></a> on the result.</span></div>
</div>
</td>
</tr>
<tr id="i9" class="rowColor">
<td class="colFirst"><code>&lt;KR,VR&gt;&nbsp;<a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html" title="interface in org.apache.kafka.streams.kstream">KGroupedTable</a>&lt;KR,VR&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#groupBy-org.apache.kafka.streams.kstream.KeyValueMapper-">groupBy</a></span>(<a href="../../../../../org/apache/kafka/streams/kstream/KeyValueMapper.html" title="interface in org.apache.kafka.streams.kstream">KeyValueMapper</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,? super <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>,<a href="../../../../../org/apache/kafka/streams/KeyValue.html" title="class in org.apache.kafka.streams">KeyValue</a>&lt;KR,VR&gt;&gt;&nbsp;selector)</code>
<div class="block">Re-groups the records of this <code>KTable</code> using the provided <a href="../../../../../org/apache/kafka/streams/kstream/KeyValueMapper.html" title="interface in org.apache.kafka.streams.kstream"><code>KeyValueMapper</code></a> and default serializers
 and deserializers.</div>
</td>
</tr>
<tr id="i10" class="altColor">
<td class="colFirst"><code>&lt;KR,VR&gt;&nbsp;<a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html" title="interface in org.apache.kafka.streams.kstream">KGroupedTable</a>&lt;KR,VR&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#groupBy-org.apache.kafka.streams.kstream.KeyValueMapper-org.apache.kafka.common.serialization.Serde-org.apache.kafka.common.serialization.Serde-">groupBy</a></span>(<a href="../../../../../org/apache/kafka/streams/kstream/KeyValueMapper.html" title="interface in org.apache.kafka.streams.kstream">KeyValueMapper</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,? super <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>,<a href="../../../../../org/apache/kafka/streams/KeyValue.html" title="class in org.apache.kafka.streams">KeyValue</a>&lt;KR,VR&gt;&gt;&nbsp;selector,
       <a href="../../../../../org/apache/kafka/common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization">Serde</a>&lt;KR&gt;&nbsp;keySerde,
       <a href="../../../../../org/apache/kafka/common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization">Serde</a>&lt;VR&gt;&nbsp;valueSerde)</code>
<div class="block"><span class="deprecatedLabel">Deprecated.</span>&nbsp;
<div class="block"><span class="deprecationComment">use <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#groupBy-org.apache.kafka.streams.kstream.KeyValueMapper-org.apache.kafka.streams.kstream.Serialized-"><code>groupBy(selector, Serialized.with(keySerde, valueSerde)</code></a></span></div>
</div>
</td>
</tr>
<tr id="i11" class="rowColor">
<td class="colFirst"><code>&lt;KR,VR&gt;&nbsp;<a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html" title="interface in org.apache.kafka.streams.kstream">KGroupedTable</a>&lt;KR,VR&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#groupBy-org.apache.kafka.streams.kstream.KeyValueMapper-org.apache.kafka.streams.kstream.Serialized-">groupBy</a></span>(<a href="../../../../../org/apache/kafka/streams/kstream/KeyValueMapper.html" title="interface in org.apache.kafka.streams.kstream">KeyValueMapper</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,? super <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>,<a href="../../../../../org/apache/kafka/streams/KeyValue.html" title="class in org.apache.kafka.streams">KeyValue</a>&lt;KR,VR&gt;&gt;&nbsp;selector,
       <a href="../../../../../org/apache/kafka/streams/kstream/Serialized.html" title="class in org.apache.kafka.streams.kstream">Serialized</a>&lt;KR,VR&gt;&nbsp;serialized)</code>
<div class="block">Re-groups the records of this <code>KTable</code> using the provided <a href="../../../../../org/apache/kafka/streams/kstream/KeyValueMapper.html" title="interface in org.apache.kafka.streams.kstream"><code>KeyValueMapper</code></a>
 and <a href="../../../../../org/apache/kafka/common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization"><code>Serde</code></a>s as specified by <a href="../../../../../org/apache/kafka/streams/kstream/Serialized.html" title="class in org.apache.kafka.streams.kstream"><code>Serialized</code></a>.</div>
</td>
</tr>
<tr id="i12" class="altColor">
<td class="colFirst"><code>&lt;VO,VR&gt;&nbsp;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,VR&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#join-org.apache.kafka.streams.kstream.KTable-org.apache.kafka.streams.kstream.ValueJoiner-">join</a></span>(<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,VO&gt;&nbsp;other,
    <a href="../../../../../org/apache/kafka/streams/kstream/ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream">ValueJoiner</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>,? super VO,? extends VR&gt;&nbsp;joiner)</code>
<div class="block">Join records of this <code>KTable</code> with another <code>KTable</code>'s records using non-windowed inner equi join.</div>
</td>
</tr>
<tr id="i13" class="rowColor">
<td class="colFirst"><code>&lt;VO,VR&gt;&nbsp;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,VR&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#join-org.apache.kafka.streams.kstream.KTable-org.apache.kafka.streams.kstream.ValueJoiner-org.apache.kafka.streams.kstream.Materialized-">join</a></span>(<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,VO&gt;&nbsp;other,
    <a href="../../../../../org/apache/kafka/streams/kstream/ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream">ValueJoiner</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>,? super VO,? extends VR&gt;&nbsp;joiner,
    <a href="../../../../../org/apache/kafka/streams/kstream/Materialized.html" title="class in org.apache.kafka.streams.kstream">Materialized</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,VR,<a href="../../../../../org/apache/kafka/streams/state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state">KeyValueStore</a>&lt;org.apache.kafka.common.utils.Bytes,byte[]&gt;&gt;&nbsp;materialized)</code>
<div class="block">Join records of this <code>KTable</code> with another <code>KTable</code>'s records using non-windowed inner equi join.</div>
</td>
</tr>
<tr id="i14" class="altColor">
<td class="colFirst"><code>&lt;VO,VR&gt;&nbsp;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,VR&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#join-org.apache.kafka.streams.kstream.KTable-org.apache.kafka.streams.kstream.ValueJoiner-org.apache.kafka.common.serialization.Serde-java.lang.String-">join</a></span>(<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,VO&gt;&nbsp;other,
    <a href="../../../../../org/apache/kafka/streams/kstream/ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream">ValueJoiner</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>,? super VO,? extends VR&gt;&nbsp;joiner,
    <a href="../../../../../org/apache/kafka/common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization">Serde</a>&lt;VR&gt;&nbsp;joinSerde,
    java.lang.String&nbsp;queryableStoreName)</code>
<div class="block"><span class="deprecatedLabel">Deprecated.</span>&nbsp;
<div class="block"><span class="deprecationComment">use <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#join-org.apache.kafka.streams.kstream.KTable-org.apache.kafka.streams.kstream.ValueJoiner-org.apache.kafka.streams.kstream.Materialized-"><code>join(other, joiner, Materialized.as(queryableStoreName).withValueSerde(joinSerde)</code></a></span></div>
</div>
</td>
</tr>
<tr id="i15" class="rowColor">
<td class="colFirst"><code>&lt;VO,VR&gt;&nbsp;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,VR&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#join-org.apache.kafka.streams.kstream.KTable-org.apache.kafka.streams.kstream.ValueJoiner-org.apache.kafka.streams.processor.StateStoreSupplier-">join</a></span>(<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,VO&gt;&nbsp;other,
    <a href="../../../../../org/apache/kafka/streams/kstream/ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream">ValueJoiner</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>,? super VO,? extends VR&gt;&nbsp;joiner,
    <a href="../../../../../org/apache/kafka/streams/processor/StateStoreSupplier.html" title="interface in org.apache.kafka.streams.processor">StateStoreSupplier</a>&lt;<a href="../../../../../org/apache/kafka/streams/state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state">KeyValueStore</a>&gt;&nbsp;storeSupplier)</code>
<div class="block"><span class="deprecatedLabel">Deprecated.</span>&nbsp;
<div class="block"><span class="deprecationComment">use <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#join-org.apache.kafka.streams.kstream.KTable-org.apache.kafka.streams.kstream.ValueJoiner-org.apache.kafka.streams.kstream.Materialized-"><code>join(other, joiner, Materialized.as(KeyValueByteStoreSupplier)</code></a></span></div>
</div>
</td>
</tr>
<tr id="i16" class="altColor">
<td class="colFirst"><code>&lt;VO,VR&gt;&nbsp;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,VR&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#leftJoin-org.apache.kafka.streams.kstream.KTable-org.apache.kafka.streams.kstream.ValueJoiner-">leftJoin</a></span>(<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,VO&gt;&nbsp;other,
        <a href="../../../../../org/apache/kafka/streams/kstream/ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream">ValueJoiner</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>,? super VO,? extends VR&gt;&nbsp;joiner)</code>
<div class="block">Join records of this <code>KTable</code> (left input) with another <code>KTable</code>'s (right input) records using
 non-windowed left equi join.</div>
</td>
</tr>
<tr id="i17" class="rowColor">
<td class="colFirst"><code>&lt;VO,VR&gt;&nbsp;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,VR&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#leftJoin-org.apache.kafka.streams.kstream.KTable-org.apache.kafka.streams.kstream.ValueJoiner-org.apache.kafka.streams.kstream.Materialized-">leftJoin</a></span>(<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,VO&gt;&nbsp;other,
        <a href="../../../../../org/apache/kafka/streams/kstream/ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream">ValueJoiner</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>,? super VO,? extends VR&gt;&nbsp;joiner,
        <a href="../../../../../org/apache/kafka/streams/kstream/Materialized.html" title="class in org.apache.kafka.streams.kstream">Materialized</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,VR,<a href="../../../../../org/apache/kafka/streams/state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state">KeyValueStore</a>&lt;org.apache.kafka.common.utils.Bytes,byte[]&gt;&gt;&nbsp;materialized)</code>
<div class="block">Join records of this <code>KTable</code> (left input) with another <code>KTable</code>'s (right input) records using
 non-windowed left equi join.</div>
</td>
</tr>
<tr id="i18" class="altColor">
<td class="colFirst"><code>&lt;VO,VR&gt;&nbsp;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,VR&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#leftJoin-org.apache.kafka.streams.kstream.KTable-org.apache.kafka.streams.kstream.ValueJoiner-org.apache.kafka.common.serialization.Serde-java.lang.String-">leftJoin</a></span>(<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,VO&gt;&nbsp;other,
        <a href="../../../../../org/apache/kafka/streams/kstream/ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream">ValueJoiner</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>,? super VO,? extends VR&gt;&nbsp;joiner,
        <a href="../../../../../org/apache/kafka/common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization">Serde</a>&lt;VR&gt;&nbsp;joinSerde,
        java.lang.String&nbsp;queryableStoreName)</code>
<div class="block"><span class="deprecatedLabel">Deprecated.</span>&nbsp;
<div class="block"><span class="deprecationComment">use <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#leftJoin-org.apache.kafka.streams.kstream.KTable-org.apache.kafka.streams.kstream.ValueJoiner-org.apache.kafka.streams.kstream.Materialized-"><code>leftJoin(other, joiner, Materialized.as(queryableStoreName).withValueSerde(joinSerde)</code></a></span></div>
</div>
</td>
</tr>
<tr id="i19" class="rowColor">
<td class="colFirst"><code>&lt;VO,VR&gt;&nbsp;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,VR&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#leftJoin-org.apache.kafka.streams.kstream.KTable-org.apache.kafka.streams.kstream.ValueJoiner-org.apache.kafka.streams.processor.StateStoreSupplier-">leftJoin</a></span>(<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,VO&gt;&nbsp;other,
        <a href="../../../../../org/apache/kafka/streams/kstream/ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream">ValueJoiner</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>,? super VO,? extends VR&gt;&nbsp;joiner,
        <a href="../../../../../org/apache/kafka/streams/processor/StateStoreSupplier.html" title="interface in org.apache.kafka.streams.processor">StateStoreSupplier</a>&lt;<a href="../../../../../org/apache/kafka/streams/state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state">KeyValueStore</a>&gt;&nbsp;storeSupplier)</code>
<div class="block"><span class="deprecatedLabel">Deprecated.</span>&nbsp;
<div class="block"><span class="deprecationComment">use <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#leftJoin-org.apache.kafka.streams.kstream.KTable-org.apache.kafka.streams.kstream.ValueJoiner-org.apache.kafka.streams.kstream.Materialized-"><code>leftJoin(other, joiner, Materialized.as(KeyValueByteStoreSupplier)</code></a></span></div>
</div>
</td>
</tr>
<tr id="i20" class="altColor">
<td class="colFirst"><code>&lt;VR&gt;&nbsp;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,VR&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#mapValues-org.apache.kafka.streams.kstream.ValueMapper-">mapValues</a></span>(<a href="../../../../../org/apache/kafka/streams/kstream/ValueMapper.html" title="interface in org.apache.kafka.streams.kstream">ValueMapper</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>,? extends VR&gt;&nbsp;mapper)</code>
<div class="block">Create a new <code>KTable</code> by transforming the value of each record in this <code>KTable</code> into a new value
 (with possible new type)in the new <code>KTable</code>.</div>
</td>
</tr>
<tr id="i21" class="rowColor">
<td class="colFirst"><code>&lt;VR&gt;&nbsp;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,VR&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#mapValues-org.apache.kafka.streams.kstream.ValueMapper-org.apache.kafka.streams.kstream.Materialized-">mapValues</a></span>(<a href="../../../../../org/apache/kafka/streams/kstream/ValueMapper.html" title="interface in org.apache.kafka.streams.kstream">ValueMapper</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>,? extends VR&gt;&nbsp;mapper,
         <a href="../../../../../org/apache/kafka/streams/kstream/Materialized.html" title="class in org.apache.kafka.streams.kstream">Materialized</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,VR,<a href="../../../../../org/apache/kafka/streams/state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state">KeyValueStore</a>&lt;org.apache.kafka.common.utils.Bytes,byte[]&gt;&gt;&nbsp;materialized)</code>
<div class="block">Create a new <code>KTable</code> by transforming the value of each record in this <code>KTable</code> into a new value
 (with possible new type)in the new <code>KTable</code>.</div>
</td>
</tr>
<tr id="i22" class="altColor">
<td class="colFirst"><code>&lt;VR&gt;&nbsp;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,VR&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#mapValues-org.apache.kafka.streams.kstream.ValueMapper-org.apache.kafka.common.serialization.Serde-org.apache.kafka.streams.processor.StateStoreSupplier-">mapValues</a></span>(<a href="../../../../../org/apache/kafka/streams/kstream/ValueMapper.html" title="interface in org.apache.kafka.streams.kstream">ValueMapper</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>,? extends VR&gt;&nbsp;mapper,
         <a href="../../../../../org/apache/kafka/common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization">Serde</a>&lt;VR&gt;&nbsp;valueSerde,
         <a href="../../../../../org/apache/kafka/streams/processor/StateStoreSupplier.html" title="interface in org.apache.kafka.streams.processor">StateStoreSupplier</a>&lt;<a href="../../../../../org/apache/kafka/streams/state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state">KeyValueStore</a>&gt;&nbsp;storeSupplier)</code>
<div class="block"><span class="deprecatedLabel">Deprecated.</span>&nbsp;
<div class="block"><span class="deprecationComment">use <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#mapValues-org.apache.kafka.streams.kstream.ValueMapper-org.apache.kafka.streams.kstream.Materialized-"><code>mapValues(mapper, Materialized.as(KeyValueByteStoreSupplier).withValueSerde(valueSerde))</code></a></span></div>
</div>
</td>
</tr>
<tr id="i23" class="rowColor">
<td class="colFirst"><code>&lt;VR&gt;&nbsp;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,VR&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#mapValues-org.apache.kafka.streams.kstream.ValueMapper-org.apache.kafka.common.serialization.Serde-java.lang.String-">mapValues</a></span>(<a href="../../../../../org/apache/kafka/streams/kstream/ValueMapper.html" title="interface in org.apache.kafka.streams.kstream">ValueMapper</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>,? extends VR&gt;&nbsp;mapper,
         <a href="../../../../../org/apache/kafka/common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization">Serde</a>&lt;VR&gt;&nbsp;valueSerde,
         java.lang.String&nbsp;queryableStoreName)</code>
<div class="block"><span class="deprecatedLabel">Deprecated.</span>&nbsp;
<div class="block"><span class="deprecationComment">use <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#mapValues-org.apache.kafka.streams.kstream.ValueMapper-org.apache.kafka.streams.kstream.Materialized-"><code>mapValues(mapper, Materialized.as(queryableStoreName).withValueSerde(valueSerde))</code></a></span></div>
</div>
</td>
</tr>
<tr id="i24" class="altColor">
<td class="colFirst"><code>&lt;VO,VR&gt;&nbsp;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,VR&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#outerJoin-org.apache.kafka.streams.kstream.KTable-org.apache.kafka.streams.kstream.ValueJoiner-">outerJoin</a></span>(<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,VO&gt;&nbsp;other,
         <a href="../../../../../org/apache/kafka/streams/kstream/ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream">ValueJoiner</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>,? super VO,? extends VR&gt;&nbsp;joiner)</code>
<div class="block">Join records of this <code>KTable</code> (left input) with another <code>KTable</code>'s (right input) records using
 non-windowed outer equi join.</div>
</td>
</tr>
<tr id="i25" class="rowColor">
<td class="colFirst"><code>&lt;VO,VR&gt;&nbsp;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,VR&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#outerJoin-org.apache.kafka.streams.kstream.KTable-org.apache.kafka.streams.kstream.ValueJoiner-org.apache.kafka.streams.kstream.Materialized-">outerJoin</a></span>(<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,VO&gt;&nbsp;other,
         <a href="../../../../../org/apache/kafka/streams/kstream/ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream">ValueJoiner</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>,? super VO,? extends VR&gt;&nbsp;joiner,
         <a href="../../../../../org/apache/kafka/streams/kstream/Materialized.html" title="class in org.apache.kafka.streams.kstream">Materialized</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,VR,<a href="../../../../../org/apache/kafka/streams/state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state">KeyValueStore</a>&lt;org.apache.kafka.common.utils.Bytes,byte[]&gt;&gt;&nbsp;materialized)</code>
<div class="block">Join records of this <code>KTable</code> (left input) with another <code>KTable</code>'s (right input) records using
 non-windowed outer equi join.</div>
</td>
</tr>
<tr id="i26" class="altColor">
<td class="colFirst"><code>&lt;VO,VR&gt;&nbsp;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,VR&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#outerJoin-org.apache.kafka.streams.kstream.KTable-org.apache.kafka.streams.kstream.ValueJoiner-org.apache.kafka.common.serialization.Serde-java.lang.String-">outerJoin</a></span>(<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,VO&gt;&nbsp;other,
         <a href="../../../../../org/apache/kafka/streams/kstream/ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream">ValueJoiner</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>,? super VO,? extends VR&gt;&nbsp;joiner,
         <a href="../../../../../org/apache/kafka/common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization">Serde</a>&lt;VR&gt;&nbsp;joinSerde,
         java.lang.String&nbsp;queryableStoreName)</code>
<div class="block"><span class="deprecatedLabel">Deprecated.</span>&nbsp;
<div class="block"><span class="deprecationComment">use <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#outerJoin-org.apache.kafka.streams.kstream.KTable-org.apache.kafka.streams.kstream.ValueJoiner-org.apache.kafka.streams.kstream.Materialized-"><code>outerJoin(other, joiner, Materialized.as(queryableStoreName).withValueSerde(joinSerde)</code></a></span></div>
</div>
</td>
</tr>
<tr id="i27" class="rowColor">
<td class="colFirst"><code>&lt;VO,VR&gt;&nbsp;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,VR&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#outerJoin-org.apache.kafka.streams.kstream.KTable-org.apache.kafka.streams.kstream.ValueJoiner-org.apache.kafka.streams.processor.StateStoreSupplier-">outerJoin</a></span>(<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,VO&gt;&nbsp;other,
         <a href="../../../../../org/apache/kafka/streams/kstream/ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream">ValueJoiner</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>,? super VO,? extends VR&gt;&nbsp;joiner,
         <a href="../../../../../org/apache/kafka/streams/processor/StateStoreSupplier.html" title="interface in org.apache.kafka.streams.processor">StateStoreSupplier</a>&lt;<a href="../../../../../org/apache/kafka/streams/state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state">KeyValueStore</a>&gt;&nbsp;storeSupplier)</code>
<div class="block"><span class="deprecatedLabel">Deprecated.</span>&nbsp;
<div class="block"><span class="deprecationComment">use <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#outerJoin-org.apache.kafka.streams.kstream.KTable-org.apache.kafka.streams.kstream.ValueJoiner-org.apache.kafka.streams.kstream.Materialized-"><code>outerJoin(other, joiner, Materialized.as(KeyValueByteStoreSupplier)</code></a></span></div>
</div>
</td>
</tr>
<tr id="i28" class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#print--">print</a></span>()</code>
<div class="block"><span class="deprecatedLabel">Deprecated.</span>&nbsp;
<div class="block"><span class="deprecationComment">Use the Interactive Queries APIs (e.g., <a href="../../../../../org/apache/kafka/streams/KafkaStreams.html#store-java.lang.String-org.apache.kafka.streams.state.QueryableStoreType-"><code>KafkaStreams.store(String, QueryableStoreType)</code></a>
 followed by <a href="../../../../../org/apache/kafka/streams/state/ReadOnlyKeyValueStore.html#all--"><code>ReadOnlyKeyValueStore.all()</code></a>) to iterate over the keys of a KTable. Alternatively
 convert to a <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="interface in org.apache.kafka.streams.kstream"><code>KStream</code></a> using <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#toStream--"><code>toStream()</code></a> and then use
 <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#print-org.apache.kafka.streams.kstream.Printed-"><code>print(Printed.toSysOut())</code></a> on the result.</span></div>
</div>
</td>
</tr>
<tr id="i29" class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#print-org.apache.kafka.common.serialization.Serde-org.apache.kafka.common.serialization.Serde-">print</a></span>(<a href="../../../../../org/apache/kafka/common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization">Serde</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>&gt;&nbsp;keySerde,
     <a href="../../../../../org/apache/kafka/common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization">Serde</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>&gt;&nbsp;valSerde)</code>
<div class="block"><span class="deprecatedLabel">Deprecated.</span>&nbsp;
<div class="block"><span class="deprecationComment">Use the Interactive Queries APIs (e.g., <a href="../../../../../org/apache/kafka/streams/KafkaStreams.html#store-java.lang.String-org.apache.kafka.streams.state.QueryableStoreType-"><code>KafkaStreams.store(String, QueryableStoreType)</code></a>
 followed by <a href="../../../../../org/apache/kafka/streams/state/ReadOnlyKeyValueStore.html#all--"><code>ReadOnlyKeyValueStore.all()</code></a>) to iterate over the keys of a KTable. Alternatively
 convert to a <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="interface in org.apache.kafka.streams.kstream"><code>KStream</code></a> using <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#toStream--"><code>toStream()</code></a> and then use
 <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#print-org.apache.kafka.streams.kstream.Printed-"><code>print(Printed.toSysOut().withKeyValueMapper(...)</code></a> on the result.</span></div>
</div>
</td>
</tr>
<tr id="i30" class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#print-org.apache.kafka.common.serialization.Serde-org.apache.kafka.common.serialization.Serde-java.lang.String-">print</a></span>(<a href="../../../../../org/apache/kafka/common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization">Serde</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>&gt;&nbsp;keySerde,
     <a href="../../../../../org/apache/kafka/common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization">Serde</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>&gt;&nbsp;valSerde,
     java.lang.String&nbsp;label)</code>
<div class="block"><span class="deprecatedLabel">Deprecated.</span>&nbsp;
<div class="block"><span class="deprecationComment">Use the Interactive Queries APIs (e.g., <a href="../../../../../org/apache/kafka/streams/KafkaStreams.html#store-java.lang.String-org.apache.kafka.streams.state.QueryableStoreType-"><code>KafkaStreams.store(String, QueryableStoreType)</code></a>
 followed by <a href="../../../../../org/apache/kafka/streams/state/ReadOnlyKeyValueStore.html#all--"><code>ReadOnlyKeyValueStore.all()</code></a>) to iterate over the keys of a KTable. Alternatively
 convert to a <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="interface in org.apache.kafka.streams.kstream"><code>KStream</code></a> using <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#toStream--"><code>toStream()</code></a> and then use
 <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#print-org.apache.kafka.streams.kstream.Printed-"><code>print(Printed.toSysOut().withLabel(label).withKeyValueMapper(...)</code></a> on the result.</span></div>
</div>
</td>
</tr>
<tr id="i31" class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#print-java.lang.String-">print</a></span>(java.lang.String&nbsp;label)</code>
<div class="block"><span class="deprecatedLabel">Deprecated.</span>&nbsp;
<div class="block"><span class="deprecationComment">Use the Interactive Queries APIs (e.g., <a href="../../../../../org/apache/kafka/streams/KafkaStreams.html#store-java.lang.String-org.apache.kafka.streams.state.QueryableStoreType-"><code>KafkaStreams.store(String, QueryableStoreType)</code></a>
 followed by <a href="../../../../../org/apache/kafka/streams/state/ReadOnlyKeyValueStore.html#all--"><code>ReadOnlyKeyValueStore.all()</code></a>) to iterate over the keys of a KTable. Alternatively
 convert to a <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="interface in org.apache.kafka.streams.kstream"><code>KStream</code></a> using <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#toStream--"><code>toStream()</code></a> and then use
 <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#print-org.apache.kafka.streams.kstream.Printed-"><code>print(Printed.toSysOut().withLabel(lable))</code></a> on the result.</span></div>
</div>
</td>
</tr>
<tr id="i32" class="altColor">
<td class="colFirst"><code>java.lang.String</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#queryableStoreName--">queryableStoreName</a></span>()</code>
<div class="block">Get the name of the local state store used that can be used to query this <code>KTable</code>.</div>
</td>
</tr>
<tr id="i33" class="rowColor">
<td class="colFirst"><code><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#through-org.apache.kafka.common.serialization.Serde-org.apache.kafka.common.serialization.Serde-org.apache.kafka.streams.processor.StreamPartitioner-java.lang.String-">through</a></span>(<a href="../../../../../org/apache/kafka/common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization">Serde</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>&gt;&nbsp;keySerde,
       <a href="../../../../../org/apache/kafka/common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization">Serde</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>&gt;&nbsp;valSerde,
       <a href="../../../../../org/apache/kafka/streams/processor/StreamPartitioner.html" title="interface in org.apache.kafka.streams.processor">StreamPartitioner</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,? super <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>&gt;&nbsp;partitioner,
       java.lang.String&nbsp;topic)</code>
<div class="block"><span class="deprecatedLabel">Deprecated.</span>&nbsp;
<div class="block"><span class="deprecationComment">use <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#toStream--"><code>toStream()</code></a> followed by
 <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#to-java.lang.String-org.apache.kafka.streams.kstream.Produced-"><code>to(topic, Produced.with(keySerde, valSerde, partitioner))</code></a> and
 <a href="../../../../../org/apache/kafka/streams/StreamsBuilder.html#table-java.lang.String-"><code>StreamsBuilder#table(topic)</code></a> to read back as a <code>KTable</code></span></div>
</div>
</td>
</tr>
<tr id="i34" class="altColor">
<td class="colFirst"><code><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#through-org.apache.kafka.common.serialization.Serde-org.apache.kafka.common.serialization.Serde-org.apache.kafka.streams.processor.StreamPartitioner-java.lang.String-org.apache.kafka.streams.processor.StateStoreSupplier-">through</a></span>(<a href="../../../../../org/apache/kafka/common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization">Serde</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>&gt;&nbsp;keySerde,
       <a href="../../../../../org/apache/kafka/common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization">Serde</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>&gt;&nbsp;valSerde,
       <a href="../../../../../org/apache/kafka/streams/processor/StreamPartitioner.html" title="interface in org.apache.kafka.streams.processor">StreamPartitioner</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,? super <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>&gt;&nbsp;partitioner,
       java.lang.String&nbsp;topic,
       <a href="../../../../../org/apache/kafka/streams/processor/StateStoreSupplier.html" title="interface in org.apache.kafka.streams.processor">StateStoreSupplier</a>&lt;<a href="../../../../../org/apache/kafka/streams/state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state">KeyValueStore</a>&gt;&nbsp;storeSupplier)</code>
<div class="block"><span class="deprecatedLabel">Deprecated.</span>&nbsp;
<div class="block"><span class="deprecationComment">use <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#toStream--"><code>toStream()</code></a> followed by
 <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#to-java.lang.String-org.apache.kafka.streams.kstream.Produced-"><code>to(topic, Produced.with(keySerde, valSerde, partitioner))</code></a> and
 <a href="../../../../../org/apache/kafka/streams/StreamsBuilder.html#table-java.lang.String-org.apache.kafka.streams.kstream.Materialized-"><code>StreamsBuilder#table(topic, Materialized.as(KeyValueBytesStoreSupplier))</code></a>
 to read back as a <code>KTable</code></span></div>
</div>
</td>
</tr>
<tr id="i35" class="rowColor">
<td class="colFirst"><code><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#through-org.apache.kafka.common.serialization.Serde-org.apache.kafka.common.serialization.Serde-org.apache.kafka.streams.processor.StreamPartitioner-java.lang.String-java.lang.String-">through</a></span>(<a href="../../../../../org/apache/kafka/common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization">Serde</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>&gt;&nbsp;keySerde,
       <a href="../../../../../org/apache/kafka/common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization">Serde</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>&gt;&nbsp;valSerde,
       <a href="../../../../../org/apache/kafka/streams/processor/StreamPartitioner.html" title="interface in org.apache.kafka.streams.processor">StreamPartitioner</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,? super <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>&gt;&nbsp;partitioner,
       java.lang.String&nbsp;topic,
       java.lang.String&nbsp;queryableStoreName)</code>
<div class="block"><span class="deprecatedLabel">Deprecated.</span>&nbsp;
<div class="block"><span class="deprecationComment">use <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#toStream--"><code>toStream()</code></a> followed by
 <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#to-java.lang.String-org.apache.kafka.streams.kstream.Produced-"><code>to(topic, Produced.with(keySerde, valSerde, partitioner))</code></a> and
 <a href="../../../../../org/apache/kafka/streams/StreamsBuilder.html#table-java.lang.String-org.apache.kafka.streams.kstream.Materialized-"><code>StreamsBuilder#table(topic, Materialized.as(queryableStoreName))</code></a>
 to read back as a <code>KTable</code></span></div>
</div>
</td>
</tr>
<tr id="i36" class="altColor">
<td class="colFirst"><code><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#through-org.apache.kafka.common.serialization.Serde-org.apache.kafka.common.serialization.Serde-java.lang.String-">through</a></span>(<a href="../../../../../org/apache/kafka/common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization">Serde</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>&gt;&nbsp;keySerde,
       <a href="../../../../../org/apache/kafka/common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization">Serde</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>&gt;&nbsp;valSerde,
       java.lang.String&nbsp;topic)</code>
<div class="block"><span class="deprecatedLabel">Deprecated.</span>&nbsp;
<div class="block"><span class="deprecationComment">use <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#toStream--"><code>toStream()</code></a> followed by
 <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#to-java.lang.String-org.apache.kafka.streams.kstream.Produced-"><code>to(topic, Produced.with(keySerde, valSerde))</code></a>
 and <a href="../../../../../org/apache/kafka/streams/StreamsBuilder.html#table-java.lang.String-"><code>StreamsBuilder#table(topic)</code></a> to read back as a <code>KTable</code></span></div>
</div>
</td>
</tr>
<tr id="i37" class="rowColor">
<td class="colFirst"><code><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#through-org.apache.kafka.common.serialization.Serde-org.apache.kafka.common.serialization.Serde-java.lang.String-org.apache.kafka.streams.processor.StateStoreSupplier-">through</a></span>(<a href="../../../../../org/apache/kafka/common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization">Serde</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>&gt;&nbsp;keySerde,
       <a href="../../../../../org/apache/kafka/common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization">Serde</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>&gt;&nbsp;valSerde,
       java.lang.String&nbsp;topic,
       <a href="../../../../../org/apache/kafka/streams/processor/StateStoreSupplier.html" title="interface in org.apache.kafka.streams.processor">StateStoreSupplier</a>&lt;<a href="../../../../../org/apache/kafka/streams/state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state">KeyValueStore</a>&gt;&nbsp;storeSupplier)</code>
<div class="block"><span class="deprecatedLabel">Deprecated.</span>&nbsp;
<div class="block"><span class="deprecationComment">use <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#toStream--"><code>toStream()</code></a> followed by
 <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#to-java.lang.String-org.apache.kafka.streams.kstream.Produced-"><code>to(topic, Produced.with(keySerde, valSerde))</code></a> and
 <a href="../../../../../org/apache/kafka/streams/StreamsBuilder.html#table-java.lang.String-org.apache.kafka.streams.kstream.Materialized-"><code>StreamsBuilder#table(topic, Materialized.as(KeyValueBytesStoreSupplier)</code></a>
 to read back as a <code>KTable</code></span></div>
</div>
</td>
</tr>
<tr id="i38" class="altColor">
<td class="colFirst"><code><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#through-org.apache.kafka.common.serialization.Serde-org.apache.kafka.common.serialization.Serde-java.lang.String-java.lang.String-">through</a></span>(<a href="../../../../../org/apache/kafka/common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization">Serde</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>&gt;&nbsp;keySerde,
       <a href="../../../../../org/apache/kafka/common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization">Serde</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>&gt;&nbsp;valSerde,
       java.lang.String&nbsp;topic,
       java.lang.String&nbsp;queryableStoreName)</code>
<div class="block"><span class="deprecatedLabel">Deprecated.</span>&nbsp;
<div class="block"><span class="deprecationComment">use <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#toStream--"><code>toStream()</code></a> followed by
 <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#to-java.lang.String-org.apache.kafka.streams.kstream.Produced-"><code>to(topic, Produced.with(keySerde, valSerde))</code></a> and
 <a href="../../../../../org/apache/kafka/streams/StreamsBuilder.html#table-java.lang.String-org.apache.kafka.streams.kstream.Materialized-"><code>StreamsBuilder#table(topic, Materialized.as(queryableStoreName))</code></a>
 to read back as a <code>KTable</code></span></div>
</div>
</td>
</tr>
<tr id="i39" class="rowColor">
<td class="colFirst"><code><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#through-org.apache.kafka.streams.processor.StreamPartitioner-java.lang.String-">through</a></span>(<a href="../../../../../org/apache/kafka/streams/processor/StreamPartitioner.html" title="interface in org.apache.kafka.streams.processor">StreamPartitioner</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,? super <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>&gt;&nbsp;partitioner,
       java.lang.String&nbsp;topic)</code>
<div class="block"><span class="deprecatedLabel">Deprecated.</span>&nbsp;
<div class="block"><span class="deprecationComment">use <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#toStream--"><code>toStream()</code></a> followed by
 <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#to-java.lang.String-org.apache.kafka.streams.kstream.Produced-"><code>to(topic, Produced.streamPartitioner(partitioner))</code></a> and
 <a href="../../../../../org/apache/kafka/streams/StreamsBuilder.html#table-java.lang.String-"><code>StreamsBuilder#table(topic)</code></a> to read back as a <code>KTable</code></span></div>
</div>
</td>
</tr>
<tr id="i40" class="altColor">
<td class="colFirst"><code><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#through-org.apache.kafka.streams.processor.StreamPartitioner-java.lang.String-org.apache.kafka.streams.processor.StateStoreSupplier-">through</a></span>(<a href="../../../../../org/apache/kafka/streams/processor/StreamPartitioner.html" title="interface in org.apache.kafka.streams.processor">StreamPartitioner</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,? super <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>&gt;&nbsp;partitioner,
       java.lang.String&nbsp;topic,
       <a href="../../../../../org/apache/kafka/streams/processor/StateStoreSupplier.html" title="interface in org.apache.kafka.streams.processor">StateStoreSupplier</a>&lt;<a href="../../../../../org/apache/kafka/streams/state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state">KeyValueStore</a>&gt;&nbsp;storeSupplier)</code>
<div class="block"><span class="deprecatedLabel">Deprecated.</span>&nbsp;
<div class="block"><span class="deprecationComment">use <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#toStream--"><code>toStream()</code></a> followed by
 <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#to-java.lang.String-org.apache.kafka.streams.kstream.Produced-"><code>to(topic, Produced.streamPartitioner(partitioner))</code></a> and
 <a href="../../../../../org/apache/kafka/streams/StreamsBuilder.html#table-java.lang.String-org.apache.kafka.streams.kstream.Materialized-"><code>StreamsBuilder#table(topic, Materialized.as(KeyValueBytesStoreSupplier)</code></a>
 to read back as a <code>KTable</code></span></div>
</div>
</td>
</tr>
<tr id="i41" class="rowColor">
<td class="colFirst"><code><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#through-org.apache.kafka.streams.processor.StreamPartitioner-java.lang.String-java.lang.String-">through</a></span>(<a href="../../../../../org/apache/kafka/streams/processor/StreamPartitioner.html" title="interface in org.apache.kafka.streams.processor">StreamPartitioner</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,? super <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>&gt;&nbsp;partitioner,
       java.lang.String&nbsp;topic,
       java.lang.String&nbsp;queryableStoreName)</code>
<div class="block"><span class="deprecatedLabel">Deprecated.</span>&nbsp;
<div class="block"><span class="deprecationComment">use <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#toStream--"><code>toStream()</code></a> followed by
 <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#to-java.lang.String-org.apache.kafka.streams.kstream.Produced-"><code>to(topic, Produced.streamPartitioner(partitioner))</code></a> and
 <a href="../../../../../org/apache/kafka/streams/StreamsBuilder.html#table-java.lang.String-org.apache.kafka.streams.kstream.Materialized-"><code>StreamsBuilder#table(topic, Materialized.as(queryableStoreName))</code></a>
 to read back as a <code>KTable</code></span></div>
</div>
</td>
</tr>
<tr id="i42" class="altColor">
<td class="colFirst"><code><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#through-java.lang.String-">through</a></span>(java.lang.String&nbsp;topic)</code>
<div class="block"><span class="deprecatedLabel">Deprecated.</span>&nbsp;
<div class="block"><span class="deprecationComment">use <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#toStream--"><code>toStream()</code></a> followed by <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#to-java.lang.String-"><code>to(topic)</code></a> and
 and <a href="../../../../../org/apache/kafka/streams/StreamsBuilder.html#table-java.lang.String-"><code>StreamsBuilder#table(topic)</code></a> to read back as a <code>KTable</code></span></div>
</div>
</td>
</tr>
<tr id="i43" class="rowColor">
<td class="colFirst"><code><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#through-java.lang.String-org.apache.kafka.streams.processor.StateStoreSupplier-">through</a></span>(java.lang.String&nbsp;topic,
       <a href="../../../../../org/apache/kafka/streams/processor/StateStoreSupplier.html" title="interface in org.apache.kafka.streams.processor">StateStoreSupplier</a>&lt;<a href="../../../../../org/apache/kafka/streams/state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state">KeyValueStore</a>&gt;&nbsp;storeSupplier)</code>
<div class="block"><span class="deprecatedLabel">Deprecated.</span>&nbsp;
<div class="block"><span class="deprecationComment">use <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#toStream--"><code>toStream()</code></a> followed by <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#to-java.lang.String-"><code>to(topic)</code></a> and
 and <a href="../../../../../org/apache/kafka/streams/StreamsBuilder.html#table-java.lang.String-org.apache.kafka.streams.kstream.Materialized-"><code>StreamsBuilder#table(topic, Materialized.as(KeyValueBytesStoreSupplier))</code></a>
 to read back as a <code>KTable</code></span></div>
</div>
</td>
</tr>
<tr id="i44" class="altColor">
<td class="colFirst"><code><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#through-java.lang.String-java.lang.String-">through</a></span>(java.lang.String&nbsp;topic,
       java.lang.String&nbsp;queryableStoreName)</code>
<div class="block"><span class="deprecatedLabel">Deprecated.</span>&nbsp;
<div class="block"><span class="deprecationComment">use <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#toStream--"><code>toStream()</code></a> followed by <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#to-java.lang.String-"><code>to(topic)</code></a> and
 <a href="../../../../../org/apache/kafka/streams/StreamsBuilder.html#table-java.lang.String-org.apache.kafka.streams.kstream.Materialized-"><code>StreamsBuilder#table(topic, Materialized.as(queryableStoreName))</code></a>
 to read back as a <code>KTable</code></span></div>
</div>
</td>
</tr>
<tr id="i45" class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#to-org.apache.kafka.common.serialization.Serde-org.apache.kafka.common.serialization.Serde-org.apache.kafka.streams.processor.StreamPartitioner-java.lang.String-">to</a></span>(<a href="../../../../../org/apache/kafka/common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization">Serde</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>&gt;&nbsp;keySerde,
  <a href="../../../../../org/apache/kafka/common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization">Serde</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>&gt;&nbsp;valSerde,
  <a href="../../../../../org/apache/kafka/streams/processor/StreamPartitioner.html" title="interface in org.apache.kafka.streams.processor">StreamPartitioner</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,? super <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>&gt;&nbsp;partitioner,
  java.lang.String&nbsp;topic)</code>
<div class="block"><span class="deprecatedLabel">Deprecated.</span>&nbsp;
<div class="block"><span class="deprecationComment">use <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#toStream--"><code>toStream()</code></a> followed by
 <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#to-java.lang.String-org.apache.kafka.streams.kstream.Produced-"><code>to(topic, Produced.with(keySerde, valSerde, partioner)</code></a></span></div>
</div>
</td>
</tr>
<tr id="i46" class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#to-org.apache.kafka.common.serialization.Serde-org.apache.kafka.common.serialization.Serde-java.lang.String-">to</a></span>(<a href="../../../../../org/apache/kafka/common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization">Serde</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>&gt;&nbsp;keySerde,
  <a href="../../../../../org/apache/kafka/common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization">Serde</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>&gt;&nbsp;valSerde,
  java.lang.String&nbsp;topic)</code>
<div class="block"><span class="deprecatedLabel">Deprecated.</span>&nbsp;
<div class="block"><span class="deprecationComment">use <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#toStream--"><code>toStream()</code></a> followed by
 <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#to-java.lang.String-org.apache.kafka.streams.kstream.Produced-"><code>to(topic, Produced.with(keySerde, valSerde)</code></a></span></div>
</div>
</td>
</tr>
<tr id="i47" class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#to-org.apache.kafka.streams.processor.StreamPartitioner-java.lang.String-">to</a></span>(<a href="../../../../../org/apache/kafka/streams/processor/StreamPartitioner.html" title="interface in org.apache.kafka.streams.processor">StreamPartitioner</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,? super <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>&gt;&nbsp;partitioner,
  java.lang.String&nbsp;topic)</code>
<div class="block"><span class="deprecatedLabel">Deprecated.</span>&nbsp;
<div class="block"><span class="deprecationComment">use <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#toStream--"><code>toStream()</code></a> followed by
 <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#to-java.lang.String-org.apache.kafka.streams.kstream.Produced-"><code>to(topic, Produced.withStreamPartitioner(partitioner)</code></a></span></div>
</div>
</td>
</tr>
<tr id="i48" class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#to-java.lang.String-">to</a></span>(java.lang.String&nbsp;topic)</code>
<div class="block"><span class="deprecatedLabel">Deprecated.</span>&nbsp;
<div class="block"><span class="deprecationComment">use <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#toStream--"><code>toStream()</code></a> followed by <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#to-java.lang.String-"><code>to(topic)</code></a></span></div>
</div>
</td>
</tr>
<tr id="i49" class="rowColor">
<td class="colFirst"><code><a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="interface in org.apache.kafka.streams.kstream">KStream</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#toStream--">toStream</a></span>()</code>
<div class="block">Convert this changelog stream to a <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="interface in org.apache.kafka.streams.kstream"><code>KStream</code></a>.</div>
</td>
</tr>
<tr id="i50" class="altColor">
<td class="colFirst"><code>&lt;KR&gt;&nbsp;<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="interface in org.apache.kafka.streams.kstream">KStream</a>&lt;KR,<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#toStream-org.apache.kafka.streams.kstream.KeyValueMapper-">toStream</a></span>(<a href="../../../../../org/apache/kafka/streams/kstream/KeyValueMapper.html" title="interface in org.apache.kafka.streams.kstream">KeyValueMapper</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,? super <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>,? extends KR&gt;&nbsp;mapper)</code>
<div class="block">Convert this changelog stream to a <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="interface in org.apache.kafka.streams.kstream"><code>KStream</code></a> using the given <a href="../../../../../org/apache/kafka/streams/kstream/KeyValueMapper.html" title="interface in org.apache.kafka.streams.kstream"><code>KeyValueMapper</code></a> to select the new key.</div>
</td>
</tr>
<tr id="i51" class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#writeAsText-java.lang.String-">writeAsText</a></span>(java.lang.String&nbsp;filePath)</code>
<div class="block"><span class="deprecatedLabel">Deprecated.</span>&nbsp;
<div class="block"><span class="deprecationComment">Use the Interactive Queries APIs (e.g., <a href="../../../../../org/apache/kafka/streams/KafkaStreams.html#store-java.lang.String-org.apache.kafka.streams.state.QueryableStoreType-"><code>KafkaStreams.store(String, QueryableStoreType)</code></a>
 followed by <a href="../../../../../org/apache/kafka/streams/state/ReadOnlyKeyValueStore.html#all--"><code>ReadOnlyKeyValueStore.all()</code></a>) to iterate over the keys of a KTable. Alternatively
 convert to a <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="interface in org.apache.kafka.streams.kstream"><code>KStream</code></a> using <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#toStream--"><code>toStream()</code></a> and then use
 <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#print-org.apache.kafka.streams.kstream.Printed-"><code>print(Printed.toFile(filePath)</code></a> on the result.</span></div>
</div>
</td>
</tr>
<tr id="i52" class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#writeAsText-java.lang.String-org.apache.kafka.common.serialization.Serde-org.apache.kafka.common.serialization.Serde-">writeAsText</a></span>(java.lang.String&nbsp;filePath,
           <a href="../../../../../org/apache/kafka/common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization">Serde</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>&gt;&nbsp;keySerde,
           <a href="../../../../../org/apache/kafka/common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization">Serde</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>&gt;&nbsp;valSerde)</code>
<div class="block"><span class="deprecatedLabel">Deprecated.</span>&nbsp;
<div class="block"><span class="deprecationComment">Use the Interactive Queries APIs (e.g., <a href="../../../../../org/apache/kafka/streams/KafkaStreams.html#store-java.lang.String-org.apache.kafka.streams.state.QueryableStoreType-"><code>KafkaStreams.store(String, QueryableStoreType)</code></a>
 followed by <a href="../../../../../org/apache/kafka/streams/state/ReadOnlyKeyValueStore.html#all--"><code>ReadOnlyKeyValueStore.all()</code></a>) to iterate over the keys of a KTable. Alternatively
 convert to a <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="interface in org.apache.kafka.streams.kstream"><code>KStream</code></a> using <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#toStream--"><code>toStream()</code></a> and then use
 <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#print-org.apache.kafka.streams.kstream.Printed-"><code>print(Printed.toFile(filePath).withKeyValueMapper(...)</code></a> on the result.</span></div>
</div>
</td>
</tr>
<tr id="i53" class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#writeAsText-java.lang.String-java.lang.String-">writeAsText</a></span>(java.lang.String&nbsp;filePath,
           java.lang.String&nbsp;label)</code>
<div class="block"><span class="deprecatedLabel">Deprecated.</span>&nbsp;
<div class="block"><span class="deprecationComment">Use the Interactive Queries APIs (e.g., <a href="../../../../../org/apache/kafka/streams/KafkaStreams.html#store-java.lang.String-org.apache.kafka.streams.state.QueryableStoreType-"><code>KafkaStreams.store(String, QueryableStoreType)</code></a>
 followed by <a href="../../../../../org/apache/kafka/streams/state/ReadOnlyKeyValueStore.html#all--"><code>ReadOnlyKeyValueStore.all()</code></a>) to iterate over the keys of a KTable. Alternatively
 convert to a <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="interface in org.apache.kafka.streams.kstream"><code>KStream</code></a> using <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#toStream--"><code>toStream()</code></a> and then use
 <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#print-org.apache.kafka.streams.kstream.Printed-"><code>print(Printed.toFile(filePath).withLabel(label)</code></a> on the result.</span></div>
</div>
</td>
</tr>
<tr id="i54" class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#writeAsText-java.lang.String-java.lang.String-org.apache.kafka.common.serialization.Serde-org.apache.kafka.common.serialization.Serde-">writeAsText</a></span>(java.lang.String&nbsp;filePath,
           java.lang.String&nbsp;label,
           <a href="../../../../../org/apache/kafka/common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization">Serde</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>&gt;&nbsp;keySerde,
           <a href="../../../../../org/apache/kafka/common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization">Serde</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>&gt;&nbsp;valSerde)</code>
<div class="block"><span class="deprecatedLabel">Deprecated.</span>&nbsp;
<div class="block"><span class="deprecationComment">Use the Interactive Queries APIs (e.g., <a href="../../../../../org/apache/kafka/streams/KafkaStreams.html#store-java.lang.String-org.apache.kafka.streams.state.QueryableStoreType-"><code>KafkaStreams.store(String, QueryableStoreType)</code></a>
 followed by <a href="../../../../../org/apache/kafka/streams/state/ReadOnlyKeyValueStore.html#all--"><code>ReadOnlyKeyValueStore.all()</code></a>) to iterate over the keys of a KTable. Alternatively
 convert to a <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="interface in org.apache.kafka.streams.kstream"><code>KStream</code></a> using <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#toStream--"><code>toStream()</code></a> and then use
 <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#print-org.apache.kafka.streams.kstream.Printed-"><code>print(Printed.toFile(filePath).withLabel(label).withKeyValueMapper(...)</code></a> on the result.</span></div>
</div>
</td>
</tr>
</table>
</li>
</ul>
</li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ============ METHOD DETAIL ========== -->
<ul class="blockList">
<li class="blockList"><a name="method.detail">
<!--   -->
</a>
<h3>Method Detail</h3>
<a name="filter-org.apache.kafka.streams.kstream.Predicate-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>filter</h4>
<pre><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>&gt;&nbsp;filter(<a href="../../../../../org/apache/kafka/streams/kstream/Predicate.html" title="interface in org.apache.kafka.streams.kstream">Predicate</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,? super <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>&gt;&nbsp;predicate)</pre>
<div class="block">Create a new <code>KTable</code> that consists of all records of this <code>KTable</code> which satisfy the given
 predicate.
 All records that do not satisfy the predicate are dropped.
 For each <code>KTable</code> update the filter is evaluated on the update record to produce an update record for the
 result <code>KTable</code>.
 This is a stateless record-by-record operation.
 <p>
 Note that <code>filter</code> for a <i>changelog stream</i> works different to <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#filter-org.apache.kafka.streams.kstream.Predicate-"><code>record stream filters</code></a>, because <a href="../../../../../org/apache/kafka/streams/KeyValue.html" title="class in org.apache.kafka.streams"><code>records</code></a> with <code>null</code> values (so-called tombstone records)
 have delete semantics.
 Thus, for tombstones the provided filter predicate is not evaluated but the tombstone record is forwarded
 directly if required (i.e., if there is anything to be deleted).
 Furthermore, for each record that gets dropped (i.e., dot not satisfy the given predicate) a tombstone record
 is forwarded.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>predicate</code> - a filter <a href="../../../../../org/apache/kafka/streams/kstream/Predicate.html" title="interface in org.apache.kafka.streams.kstream"><code>Predicate</code></a> that is applied to each record</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a <code>KTable</code> that contains only those records that satisfy the given predicate</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#filterNot-org.apache.kafka.streams.kstream.Predicate-"><code>filterNot(Predicate)</code></a></dd>
</dl>
</li>
</ul>
<a name="filter-org.apache.kafka.streams.kstream.Predicate-org.apache.kafka.streams.kstream.Materialized-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>filter</h4>
<pre><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>&gt;&nbsp;filter(<a href="../../../../../org/apache/kafka/streams/kstream/Predicate.html" title="interface in org.apache.kafka.streams.kstream">Predicate</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,? super <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>&gt;&nbsp;predicate,
                   <a href="../../../../../org/apache/kafka/streams/kstream/Materialized.html" title="class in org.apache.kafka.streams.kstream">Materialized</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>,<a href="../../../../../org/apache/kafka/streams/state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state">KeyValueStore</a>&lt;org.apache.kafka.common.utils.Bytes,byte[]&gt;&gt;&nbsp;materialized)</pre>
<div class="block">Create a new <code>KTable</code> that consists of all records of this <code>KTable</code> which satisfy the given
 predicate.
 All records that do not satisfy the predicate are dropped.
 For each <code>KTable</code> update the filter is evaluated on the update record to produce an update record for the
 result <code>KTable</code>.
 This is a stateless record-by-record operation.
 <p>
 Note that <code>filter</code> for a <i>changelog stream</i> works different to <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#filter-org.apache.kafka.streams.kstream.Predicate-"><code>record stream filters</code></a>, because <a href="../../../../../org/apache/kafka/streams/KeyValue.html" title="class in org.apache.kafka.streams"><code>records</code></a> with <code>null</code> values (so-called tombstone records)
 have delete semantics.
 Thus, for tombstones the provided filter predicate is not evaluated but the tombstone record is forwarded
 directly if required (i.e., if there is anything to be deleted).
 Furthermore, for each record that gets dropped (i.e., dot not satisfy the given predicate) a tombstone record
 is forwarded.
 <p>
 To query the local <a href="../../../../../org/apache/kafka/streams/state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state"><code>KeyValueStore</code></a> it must be obtained via
 <a href="../../../../../org/apache/kafka/streams/KafkaStreams.html#store-java.lang.String-org.apache.kafka.streams.state.QueryableStoreType-"><code>KafkaStreams#store(...)</code></a>:
 <pre><code>
 KafkaStreams streams = ... // filtering words
 ReadOnlyKeyValueStore&lt;K,V&gt; localStore = streams.store(queryableStoreName, QueryableStoreTypes.&lt;K, V&gt;keyValueStore());
 K key = "some-word";
 V valueForKey = localStore.get(key); // key must be local (application state is shared over all running Kafka Streams instances)
 </code></pre>
 For non-local keys, a custom RPC mechanism must be implemented using <a href="../../../../../org/apache/kafka/streams/KafkaStreams.html#allMetadata--"><code>KafkaStreams.allMetadata()</code></a> to
 query the value of the key on a parallel running instance of your Kafka Streams application.
 The store name to query with is specified by <a href="../../../../../org/apache/kafka/streams/kstream/Materialized.html#as-java.lang.String-"><code>Materialized.as(String)</code></a> or <a href="../../../../../org/apache/kafka/streams/kstream/Materialized.html#as-org.apache.kafka.streams.state.KeyValueBytesStoreSupplier-"><code>Materialized.as(KeyValueBytesStoreSupplier)</code></a>.
 <p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>predicate</code> - a filter <a href="../../../../../org/apache/kafka/streams/kstream/Predicate.html" title="interface in org.apache.kafka.streams.kstream"><code>Predicate</code></a> that is applied to each record</dd>
<dd><code>materialized</code> - a <a href="../../../../../org/apache/kafka/streams/kstream/Materialized.html" title="class in org.apache.kafka.streams.kstream"><code>Materialized</code></a> that describes how the <a href="../../../../../org/apache/kafka/streams/processor/StateStore.html" title="interface in org.apache.kafka.streams.processor"><code>StateStore</code></a> for the resulting <code>KTable</code>
                      should be materialized. Cannot be <code>null</code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a <code>KTable</code> that contains only those records that satisfy the given predicate</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#filterNot-org.apache.kafka.streams.kstream.Predicate-org.apache.kafka.streams.kstream.Materialized-"><code>filterNot(Predicate, Materialized)</code></a></dd>
</dl>
</li>
</ul>
<a name="filter-org.apache.kafka.streams.kstream.Predicate-java.lang.String-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>filter</h4>
<pre>@Deprecated
<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>&gt;&nbsp;filter(<a href="../../../../../org/apache/kafka/streams/kstream/Predicate.html" title="interface in org.apache.kafka.streams.kstream">Predicate</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,? super <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>&gt;&nbsp;predicate,
                               java.lang.String&nbsp;queryableStoreName)</pre>
<div class="block"><span class="deprecatedLabel">Deprecated.</span>&nbsp;<span class="deprecationComment">use <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#filter-org.apache.kafka.streams.kstream.Predicate-org.apache.kafka.streams.kstream.Materialized-"><code>filter(predicate, Materialized.as(queryableStoreName))</code></a></span></div>
<div class="block">Create a new <code>KTable</code> that consists of all records of this <code>KTable</code> which satisfy the given
 predicate.
 All records that do not satisfy the predicate are dropped.
 For each <code>KTable</code> update the filter is evaluated on the update record to produce an update record for the
 result <code>KTable</code>.
 This is a stateless record-by-record operation.
 <p>
 Note that <code>filter</code> for a <i>changelog stream</i> works different to <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#filter-org.apache.kafka.streams.kstream.Predicate-"><code>record stream filters</code></a>, because <a href="../../../../../org/apache/kafka/streams/KeyValue.html" title="class in org.apache.kafka.streams"><code>records</code></a> with <code>null</code> values (so-called tombstone records)
 have delete semantics.
 Thus, for tombstones the provided filter predicate is not evaluated but the tombstone record is forwarded
 directly if required (i.e., if there is anything to be deleted).
 Furthermore, for each record that gets dropped (i.e., dot not satisfy the given predicate) a tombstone record
 is forwarded.
 <p>
 To query the local <a href="../../../../../org/apache/kafka/streams/state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state"><code>KeyValueStore</code></a> it must be obtained via
 <a href="../../../../../org/apache/kafka/streams/KafkaStreams.html#store-java.lang.String-org.apache.kafka.streams.state.QueryableStoreType-"><code>KafkaStreams#store(...)</code></a>:
 <pre><code>
 KafkaStreams streams = ... // filtering words
 ReadOnlyKeyValueStore&lt;K,V&gt; localStore = streams.store(queryableStoreName, QueryableStoreTypes.&lt;K, V&gt;keyValueStore());
 K key = "some-word";
 V valueForKey = localStore.get(key); // key must be local (application state is shared over all running Kafka Streams instances)
 </code></pre>
 For non-local keys, a custom RPC mechanism must be implemented using <a href="../../../../../org/apache/kafka/streams/KafkaStreams.html#allMetadata--"><code>KafkaStreams.allMetadata()</code></a> to
 query the value of the key on a parallel running instance of your Kafka Streams application.
 <p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>predicate</code> - a filter <a href="../../../../../org/apache/kafka/streams/kstream/Predicate.html" title="interface in org.apache.kafka.streams.kstream"><code>Predicate</code></a> that is applied to each record</dd>
<dd><code>queryableStoreName</code> - a user-provided name of the underlying <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> that can be
                          used to subsequently query the operation results; valid characters are ASCII
                          alphanumerics, '.', '_' and '-'. If <code>null</code> then the results cannot be queried
                          (i.e., that would be equivalent to calling <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#filter-org.apache.kafka.streams.kstream.Predicate-"><code>filter(Predicate)</code></a>.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a <code>KTable</code> that contains only those records that satisfy the given predicate</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#filterNot-org.apache.kafka.streams.kstream.Predicate-org.apache.kafka.streams.kstream.Materialized-"><code>filterNot(Predicate, Materialized)</code></a></dd>
</dl>
</li>
</ul>
<a name="filter-org.apache.kafka.streams.kstream.Predicate-org.apache.kafka.streams.processor.StateStoreSupplier-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>filter</h4>
<pre>@Deprecated
<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>&gt;&nbsp;filter(<a href="../../../../../org/apache/kafka/streams/kstream/Predicate.html" title="interface in org.apache.kafka.streams.kstream">Predicate</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,? super <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>&gt;&nbsp;predicate,
                               <a href="../../../../../org/apache/kafka/streams/processor/StateStoreSupplier.html" title="interface in org.apache.kafka.streams.processor">StateStoreSupplier</a>&lt;<a href="../../../../../org/apache/kafka/streams/state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state">KeyValueStore</a>&gt;&nbsp;storeSupplier)</pre>
<div class="block"><span class="deprecatedLabel">Deprecated.</span>&nbsp;<span class="deprecationComment">use <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#filter-org.apache.kafka.streams.kstream.Predicate-org.apache.kafka.streams.kstream.Materialized-"><code>filter(predicate, Materialized.as(KeyValueByteStoreSupplier))</code></a></span></div>
<div class="block">Create a new <code>KTable</code> that consists of all records of this <code>KTable</code> which satisfy the given
 predicate.
 All records that do not satisfy the predicate are dropped.
 For each <code>KTable</code> update the filter is evaluated on the update record to produce an update record for the
 result <code>KTable</code>.
 This is a stateless record-by-record operation.
 <p>
 Note that <code>filter</code> for a <i>changelog stream</i> works different to <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#filter-org.apache.kafka.streams.kstream.Predicate-"><code>record stream filters</code></a>, because <a href="../../../../../org/apache/kafka/streams/KeyValue.html" title="class in org.apache.kafka.streams"><code>records</code></a> with <code>null</code> values (so-called tombstone records)
 have delete semantics.
 Thus, for tombstones the provided filter predicate is not evaluated but the tombstone record is forwarded
 directly if required (i.e., if there is anything to be deleted).
 Furthermore, for each record that gets dropped (i.e., dot not satisfy the given predicate) a tombstone record
 is forwarded.
 <p>
 To query the local <a href="../../../../../org/apache/kafka/streams/state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state"><code>KeyValueStore</code></a> it must be obtained via
 <a href="../../../../../org/apache/kafka/streams/KafkaStreams.html#store-java.lang.String-org.apache.kafka.streams.state.QueryableStoreType-"><code>KafkaStreams#store(...)</code></a>:
 <pre><code>
 KafkaStreams streams = ... // filtering words
 ReadOnlyKeyValueStore&lt;K,V&gt; localStore = streams.store(queryableStoreName, QueryableStoreTypes.&lt;K, V&gt;keyValueStore());
 K key = "some-word";
 V valueForKey = localStore.get(key); // key must be local (application state is shared over all running Kafka Streams instances)
 </code></pre>
 For non-local keys, a custom RPC mechanism must be implemented using <a href="../../../../../org/apache/kafka/streams/KafkaStreams.html#allMetadata--"><code>KafkaStreams.allMetadata()</code></a> to
 query the value of the key on a parallel running instance of your Kafka Streams application.
 <p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>predicate</code> - a filter <a href="../../../../../org/apache/kafka/streams/kstream/Predicate.html" title="interface in org.apache.kafka.streams.kstream"><code>Predicate</code></a> that is applied to each record</dd>
<dd><code>storeSupplier</code> - user defined state store supplier. Cannot be <code>null</code>.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a <code>KTable</code> that contains only those records that satisfy the given predicate</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#filterNot-org.apache.kafka.streams.kstream.Predicate-org.apache.kafka.streams.kstream.Materialized-"><code>filterNot(Predicate, Materialized)</code></a></dd>
</dl>
</li>
</ul>
<a name="filterNot-org.apache.kafka.streams.kstream.Predicate-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>filterNot</h4>
<pre><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>&gt;&nbsp;filterNot(<a href="../../../../../org/apache/kafka/streams/kstream/Predicate.html" title="interface in org.apache.kafka.streams.kstream">Predicate</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,? super <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>&gt;&nbsp;predicate)</pre>
<div class="block">Create a new <code>KTable</code> that consists all records of this <code>KTable</code> which do <em>not</em> satisfy the
 given predicate.
 All records that <em>do</em> satisfy the predicate are dropped.
 For each <code>KTable</code> update the filter is evaluated on the update record to produce an update record for the
 result <code>KTable</code>.
 This is a stateless record-by-record operation.
 <p>
 Note that <code>filterNot</code> for a <i>changelog stream</i> works different to <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#filterNot-org.apache.kafka.streams.kstream.Predicate-"><code>record stream filters</code></a>, because <a href="../../../../../org/apache/kafka/streams/KeyValue.html" title="class in org.apache.kafka.streams"><code>records</code></a> with <code>null</code> values (so-called tombstone records)
 have delete semantics.
 Thus, for tombstones the provided filter predicate is not evaluated but the tombstone record is forwarded
 directly if required (i.e., if there is anything to be deleted).
 Furthermore, for each record that gets dropped (i.e., does satisfy the given predicate) a tombstone record is
 forwarded.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>predicate</code> - a filter <a href="../../../../../org/apache/kafka/streams/kstream/Predicate.html" title="interface in org.apache.kafka.streams.kstream"><code>Predicate</code></a> that is applied to each record</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a <code>KTable</code> that contains only those records that do <em>not</em> satisfy the given predicate</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#filter-org.apache.kafka.streams.kstream.Predicate-"><code>filter(Predicate)</code></a></dd>
</dl>
</li>
</ul>
<a name="filterNot-org.apache.kafka.streams.kstream.Predicate-org.apache.kafka.streams.kstream.Materialized-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>filterNot</h4>
<pre><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>&gt;&nbsp;filterNot(<a href="../../../../../org/apache/kafka/streams/kstream/Predicate.html" title="interface in org.apache.kafka.streams.kstream">Predicate</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,? super <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>&gt;&nbsp;predicate,
                      <a href="../../../../../org/apache/kafka/streams/kstream/Materialized.html" title="class in org.apache.kafka.streams.kstream">Materialized</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>,<a href="../../../../../org/apache/kafka/streams/state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state">KeyValueStore</a>&lt;org.apache.kafka.common.utils.Bytes,byte[]&gt;&gt;&nbsp;materialized)</pre>
<div class="block">Create a new <code>KTable</code> that consists all records of this <code>KTable</code> which do <em>not</em> satisfy the
 given predicate.
 All records that <em>do</em> satisfy the predicate are dropped.
 For each <code>KTable</code> update the filter is evaluated on the update record to produce an update record for the
 result <code>KTable</code>.
 This is a stateless record-by-record operation.
 <p>
 Note that <code>filterNot</code> for a <i>changelog stream</i> works different to <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#filterNot-org.apache.kafka.streams.kstream.Predicate-"><code>record stream filters</code></a>, because <a href="../../../../../org/apache/kafka/streams/KeyValue.html" title="class in org.apache.kafka.streams"><code>records</code></a> with <code>null</code> values (so-called tombstone records)
 have delete semantics.
 Thus, for tombstones the provided filter predicate is not evaluated but the tombstone record is forwarded
 directly if required (i.e., if there is anything to be deleted).
 Furthermore, for each record that gets dropped (i.e., does satisfy the given predicate) a tombstone record is
 forwarded.
 <p>
 To query the local <a href="../../../../../org/apache/kafka/streams/state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state"><code>KeyValueStore</code></a> it must be obtained via
 <a href="../../../../../org/apache/kafka/streams/KafkaStreams.html#store-java.lang.String-org.apache.kafka.streams.state.QueryableStoreType-"><code>KafkaStreams#store(...)</code></a>:
 <pre><code>
 KafkaStreams streams = ... // filtering words
 ReadOnlyKeyValueStore&lt;K,V&gt; localStore = streams.store(queryableStoreName, QueryableStoreTypes.&lt;K, V&gt;keyValueStore());
 K key = "some-word";
 V valueForKey = localStore.get(key); // key must be local (application state is shared over all running Kafka Streams instances)
 </code></pre>
 For non-local keys, a custom RPC mechanism must be implemented using <a href="../../../../../org/apache/kafka/streams/KafkaStreams.html#allMetadata--"><code>KafkaStreams.allMetadata()</code></a> to
 query the value of the key on a parallel running instance of your Kafka Streams application.
 The store name to query with is specified by <a href="../../../../../org/apache/kafka/streams/kstream/Materialized.html#as-java.lang.String-"><code>Materialized.as(String)</code></a> or <a href="../../../../../org/apache/kafka/streams/kstream/Materialized.html#as-org.apache.kafka.streams.state.KeyValueBytesStoreSupplier-"><code>Materialized.as(KeyValueBytesStoreSupplier)</code></a>.
 <p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>predicate</code> - a filter <a href="../../../../../org/apache/kafka/streams/kstream/Predicate.html" title="interface in org.apache.kafka.streams.kstream"><code>Predicate</code></a> that is applied to each record</dd>
<dd><code>materialized</code> - a <a href="../../../../../org/apache/kafka/streams/kstream/Materialized.html" title="class in org.apache.kafka.streams.kstream"><code>Materialized</code></a> that describes how the <a href="../../../../../org/apache/kafka/streams/processor/StateStore.html" title="interface in org.apache.kafka.streams.processor"><code>StateStore</code></a> for the resulting <code>KTable</code>
                      should be materialized. Cannot be <code>null</code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a <code>KTable</code> that contains only those records that do <em>not</em> satisfy the given predicate</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#filter-org.apache.kafka.streams.kstream.Predicate-org.apache.kafka.streams.kstream.Materialized-"><code>filter(Predicate, Materialized)</code></a></dd>
</dl>
</li>
</ul>
<a name="filterNot-org.apache.kafka.streams.kstream.Predicate-org.apache.kafka.streams.processor.StateStoreSupplier-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>filterNot</h4>
<pre>@Deprecated
<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>&gt;&nbsp;filterNot(<a href="../../../../../org/apache/kafka/streams/kstream/Predicate.html" title="interface in org.apache.kafka.streams.kstream">Predicate</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,? super <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>&gt;&nbsp;predicate,
                                  <a href="../../../../../org/apache/kafka/streams/processor/StateStoreSupplier.html" title="interface in org.apache.kafka.streams.processor">StateStoreSupplier</a>&lt;<a href="../../../../../org/apache/kafka/streams/state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state">KeyValueStore</a>&gt;&nbsp;storeSupplier)</pre>
<div class="block"><span class="deprecatedLabel">Deprecated.</span>&nbsp;<span class="deprecationComment">use <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#filterNot-org.apache.kafka.streams.kstream.Predicate-org.apache.kafka.streams.kstream.Materialized-"><code>filterNot(predicate, Materialized.as(KeyValueByteStoreSupplier))</code></a></span></div>
<div class="block">Create a new <code>KTable</code> that consists all records of this <code>KTable</code> which do <em>not</em> satisfy the
 given predicate.
 All records that <em>do</em> satisfy the predicate are dropped.
 For each <code>KTable</code> update the filter is evaluated on the update record to produce an update record for the
 result <code>KTable</code>.
 This is a stateless record-by-record operation.
 <p>
 Note that <code>filterNot</code> for a <i>changelog stream</i> works different to <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#filterNot-org.apache.kafka.streams.kstream.Predicate-"><code>record stream filters</code></a>, because <a href="../../../../../org/apache/kafka/streams/KeyValue.html" title="class in org.apache.kafka.streams"><code>records</code></a> with <code>null</code> values (so-called tombstone records)
 have delete semantics.
 Thus, for tombstones the provided filter predicate is not evaluated but the tombstone record is forwarded
 directly if required (i.e., if there is anything to be deleted).
 Furthermore, for each record that gets dropped (i.e., does satisfy the given predicate) a tombstone record is
 forwarded.
 <p>
 To query the local <a href="../../../../../org/apache/kafka/streams/state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state"><code>KeyValueStore</code></a> it must be obtained via
 <a href="../../../../../org/apache/kafka/streams/KafkaStreams.html#store-java.lang.String-org.apache.kafka.streams.state.QueryableStoreType-"><code>KafkaStreams#store(...)</code></a>:
 <pre><code>
 KafkaStreams streams = ... // filtering words
 ReadOnlyKeyValueStore&lt;K,V&gt; localStore = streams.store(queryableStoreName, QueryableStoreTypes.&lt;K, V&gt;keyValueStore());
 K key = "some-word";
 V valueForKey = localStore.get(key); // key must be local (application state is shared over all running Kafka Streams instances)
 </code></pre>
 For non-local keys, a custom RPC mechanism must be implemented using <a href="../../../../../org/apache/kafka/streams/KafkaStreams.html#allMetadata--"><code>KafkaStreams.allMetadata()</code></a> to
 query the value of the key on a parallel running instance of your Kafka Streams application.
 <p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>predicate</code> - a filter <a href="../../../../../org/apache/kafka/streams/kstream/Predicate.html" title="interface in org.apache.kafka.streams.kstream"><code>Predicate</code></a> that is applied to each record</dd>
<dd><code>storeSupplier</code> - user defined state store supplier. Cannot be <code>null</code>.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a <code>KTable</code> that contains only those records that do <em>not</em> satisfy the given predicate</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#filter-org.apache.kafka.streams.kstream.Predicate-org.apache.kafka.streams.kstream.Materialized-"><code>filter(Predicate, Materialized)</code></a></dd>
</dl>
</li>
</ul>
<a name="filterNot-org.apache.kafka.streams.kstream.Predicate-java.lang.String-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>filterNot</h4>
<pre>@Deprecated
<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>&gt;&nbsp;filterNot(<a href="../../../../../org/apache/kafka/streams/kstream/Predicate.html" title="interface in org.apache.kafka.streams.kstream">Predicate</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,? super <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>&gt;&nbsp;predicate,
                                  java.lang.String&nbsp;queryableStoreName)</pre>
<div class="block"><span class="deprecatedLabel">Deprecated.</span>&nbsp;<span class="deprecationComment">use <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#filter-org.apache.kafka.streams.kstream.Predicate-org.apache.kafka.streams.kstream.Materialized-"><code>filterNot(predicate, Materialized.as(queryableStoreName))</code></a></span></div>
<div class="block">Create a new <code>KTable</code> that consists all records of this <code>KTable</code> which do <em>not</em> satisfy the
 given predicate.
 All records that <em>do</em> satisfy the predicate are dropped.
 For each <code>KTable</code> update the filter is evaluated on the update record to produce an update record for the
 result <code>KTable</code>.
 This is a stateless record-by-record operation.
 <p>
 Note that <code>filterNot</code> for a <i>changelog stream</i> works different to <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#filterNot-org.apache.kafka.streams.kstream.Predicate-"><code>record stream filters</code></a>, because <a href="../../../../../org/apache/kafka/streams/KeyValue.html" title="class in org.apache.kafka.streams"><code>records</code></a> with <code>null</code> values (so-called tombstone records)
 have delete semantics.
 Thus, for tombstones the provided filter predicate is not evaluated but the tombstone record is forwarded
 directly if required (i.e., if there is anything to be deleted).
 Furthermore, for each record that gets dropped (i.e., does satisfy the given predicate) a tombstone record is
 forwarded.
 <p>
 To query the local <a href="../../../../../org/apache/kafka/streams/state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state"><code>KeyValueStore</code></a> it must be obtained via
 <a href="../../../../../org/apache/kafka/streams/KafkaStreams.html#store-java.lang.String-org.apache.kafka.streams.state.QueryableStoreType-"><code>KafkaStreams#store(...)</code></a>:
 <pre><code>
 KafkaStreams streams = ... // filtering words
 ReadOnlyKeyValueStore&lt;K,V&gt; localStore = streams.store(queryableStoreName, QueryableStoreTypes.&lt;K, V&gt;keyValueStore());
 K key = "some-word";
 V valueForKey = localStore.get(key); // key must be local (application state is shared over all running Kafka Streams instances)
 </code></pre>
 For non-local keys, a custom RPC mechanism must be implemented using <a href="../../../../../org/apache/kafka/streams/KafkaStreams.html#allMetadata--"><code>KafkaStreams.allMetadata()</code></a> to
 query the value of the key on a parallel running instance of your Kafka Streams application.
 <p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>predicate</code> - a filter <a href="../../../../../org/apache/kafka/streams/kstream/Predicate.html" title="interface in org.apache.kafka.streams.kstream"><code>Predicate</code></a> that is applied to each record</dd>
<dd><code>queryableStoreName</code> - a user-provided name of the underlying <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> that can be
 used to subsequently query the operation results; valid characters are ASCII
 alphanumerics, '.', '_' and '-'. If <code>null</code> then the results cannot be queried
 (i.e., that would be equivalent to calling <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#filterNot-org.apache.kafka.streams.kstream.Predicate-"><code>filterNot(Predicate)</code></a>.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a <code>KTable</code> that contains only those records that do <em>not</em> satisfy the given predicate</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#filter-org.apache.kafka.streams.kstream.Predicate-org.apache.kafka.streams.kstream.Materialized-"><code>filter(Predicate, Materialized)</code></a></dd>
</dl>
</li>
</ul>
<a name="mapValues-org.apache.kafka.streams.kstream.ValueMapper-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>mapValues</h4>
<pre>&lt;VR&gt;&nbsp;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,VR&gt;&nbsp;mapValues(<a href="../../../../../org/apache/kafka/streams/kstream/ValueMapper.html" title="interface in org.apache.kafka.streams.kstream">ValueMapper</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>,? extends VR&gt;&nbsp;mapper)</pre>
<div class="block">Create a new <code>KTable</code> by transforming the value of each record in this <code>KTable</code> into a new value
 (with possible new type)in the new <code>KTable</code>.
 For each <code>KTable</code> update the provided <a href="../../../../../org/apache/kafka/streams/kstream/ValueMapper.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueMapper</code></a> is applied to the value of the update record and
 computes a new value for it, resulting in an update record for the result <code>KTable</code>.
 Thus, an input record <code>&lt;K,V&gt;</code> can be transformed into an output record <code>&lt;K:V'&gt;</code>.
 This is a stateless record-by-record operation.
 <p>
 The example below counts the number of token of the value string.
 <pre><code>
 KTable&lt;String, String&gt; inputTable = builder.table("topic");
 KTable&lt;String, Integer&gt; outputTable = inputTable.mapValue(new ValueMapper&lt;String, Integer&gt; {
     Integer apply(String value) {
         return value.split(" ").length;
     }
 });
 </code></pre>
 <p>
 This operation preserves data co-location with respect to the key.
 Thus, <em>no</em> internal data redistribution is required if a key based operator (like a join) is applied to
 the result <code>KTable</code>.
 <p>
 Note that <code>mapValues</code> for a <i>changelog stream</i> works different to <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#mapValues-org.apache.kafka.streams.kstream.ValueMapper-"><code>record stream filters</code></a>, because <a href="../../../../../org/apache/kafka/streams/KeyValue.html" title="class in org.apache.kafka.streams"><code>records</code></a> with <code>null</code> values (so-called tombstone records)
 have delete semantics.
 Thus, for tombstones the provided value-mapper is not evaluated but the tombstone record is forwarded directly to
 delete the corresponding record in the result <code>KTable</code>.</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>VR</code> - the value type of the result <code>KTable</code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>mapper</code> - a <a href="../../../../../org/apache/kafka/streams/kstream/ValueMapper.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueMapper</code></a> that computes a new output value</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a <code>KTable</code> that contains records with unmodified keys and new values (possibly of different type)</dd>
</dl>
</li>
</ul>
<a name="mapValues-org.apache.kafka.streams.kstream.ValueMapper-org.apache.kafka.streams.kstream.Materialized-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>mapValues</h4>
<pre>&lt;VR&gt;&nbsp;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,VR&gt;&nbsp;mapValues(<a href="../../../../../org/apache/kafka/streams/kstream/ValueMapper.html" title="interface in org.apache.kafka.streams.kstream">ValueMapper</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>,? extends VR&gt;&nbsp;mapper,
                            <a href="../../../../../org/apache/kafka/streams/kstream/Materialized.html" title="class in org.apache.kafka.streams.kstream">Materialized</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,VR,<a href="../../../../../org/apache/kafka/streams/state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state">KeyValueStore</a>&lt;org.apache.kafka.common.utils.Bytes,byte[]&gt;&gt;&nbsp;materialized)</pre>
<div class="block">Create a new <code>KTable</code> by transforming the value of each record in this <code>KTable</code> into a new value
 (with possible new type)in the new <code>KTable</code>.
 For each <code>KTable</code> update the provided <a href="../../../../../org/apache/kafka/streams/kstream/ValueMapper.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueMapper</code></a> is applied to the value of the update record and
 computes a new value for it, resulting in an update record for the result <code>KTable</code>.
 Thus, an input record <code>&lt;K,V&gt;</code> can be transformed into an output record <code>&lt;K:V'&gt;</code>.
 This is a stateless record-by-record operation.
 <p>
 The example below counts the number of token of the value string.
 <pre><code>
 KTable&lt;String, String&gt; inputTable = builder.table("topic");
 KTable&lt;String, Integer&gt; outputTable = inputTable.mapValue(new ValueMapper&lt;String, Integer&gt; {
     Integer apply(String value) {
         return value.split(" ").length;
     }
 });
 </code></pre>
 <p>
 To query the local <a href="../../../../../org/apache/kafka/streams/state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state"><code>KeyValueStore</code></a> representing outputTable above it must be obtained via
 <a href="../../../../../org/apache/kafka/streams/KafkaStreams.html#store-java.lang.String-org.apache.kafka.streams.state.QueryableStoreType-"><code>KafkaStreams#store(...)</code></a>:
 For non-local keys, a custom RPC mechanism must be implemented using <a href="../../../../../org/apache/kafka/streams/KafkaStreams.html#allMetadata--"><code>KafkaStreams.allMetadata()</code></a> to
 query the value of the key on a parallel running instance of your Kafka Streams application.
 The store name to query with is specified by <a href="../../../../../org/apache/kafka/streams/kstream/Materialized.html#as-java.lang.String-"><code>Materialized.as(String)</code></a> or <a href="../../../../../org/apache/kafka/streams/kstream/Materialized.html#as-org.apache.kafka.streams.state.KeyValueBytesStoreSupplier-"><code>Materialized.as(KeyValueBytesStoreSupplier)</code></a>.
 <p>
 This operation preserves data co-location with respect to the key.
 Thus, <em>no</em> internal data redistribution is required if a key based operator (like a join) is applied to
 the result <code>KTable</code>.
 <p>
 Note that <code>mapValues</code> for a <i>changelog stream</i> works different to <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#mapValues-org.apache.kafka.streams.kstream.ValueMapper-"><code>record stream filters</code></a>, because <a href="../../../../../org/apache/kafka/streams/KeyValue.html" title="class in org.apache.kafka.streams"><code>records</code></a> with <code>null</code> values (so-called tombstone records)
 have delete semantics.
 Thus, for tombstones the provided value-mapper is not evaluated but the tombstone record is forwarded directly to
 delete the corresponding record in the result <code>KTable</code>.</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>VR</code> - the value type of the result <code>KTable</code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>mapper</code> - a <a href="../../../../../org/apache/kafka/streams/kstream/ValueMapper.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueMapper</code></a> that computes a new output value</dd>
<dd><code>materialized</code> - a <a href="../../../../../org/apache/kafka/streams/kstream/Materialized.html" title="class in org.apache.kafka.streams.kstream"><code>Materialized</code></a> that describes how the <a href="../../../../../org/apache/kafka/streams/processor/StateStore.html" title="interface in org.apache.kafka.streams.processor"><code>StateStore</code></a> for the resulting <code>KTable</code>
                      should be materialized. Cannot be <code>null</code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a <code>KTable</code> that contains records with unmodified keys and new values (possibly of different type)</dd>
</dl>
</li>
</ul>
<a name="mapValues-org.apache.kafka.streams.kstream.ValueMapper-org.apache.kafka.common.serialization.Serde-java.lang.String-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>mapValues</h4>
<pre>@Deprecated
&lt;VR&gt;&nbsp;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,VR&gt;&nbsp;mapValues(<a href="../../../../../org/apache/kafka/streams/kstream/ValueMapper.html" title="interface in org.apache.kafka.streams.kstream">ValueMapper</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>,? extends VR&gt;&nbsp;mapper,
                                        <a href="../../../../../org/apache/kafka/common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization">Serde</a>&lt;VR&gt;&nbsp;valueSerde,
                                        java.lang.String&nbsp;queryableStoreName)</pre>
<div class="block"><span class="deprecatedLabel">Deprecated.</span>&nbsp;<span class="deprecationComment">use <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#mapValues-org.apache.kafka.streams.kstream.ValueMapper-org.apache.kafka.streams.kstream.Materialized-"><code>mapValues(mapper, Materialized.as(queryableStoreName).withValueSerde(valueSerde))</code></a></span></div>
<div class="block">Create a new <code>KTable</code> by transforming the value of each record in this <code>KTable</code> into a new value
 (with possible new type)in the new <code>KTable</code>.
 For each <code>KTable</code> update the provided <a href="../../../../../org/apache/kafka/streams/kstream/ValueMapper.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueMapper</code></a> is applied to the value of the update record and
 computes a new value for it, resulting in an update record for the result <code>KTable</code>.
 Thus, an input record <code>&lt;K,V&gt;</code> can be transformed into an output record <code>&lt;K:V'&gt;</code>.
 This is a stateless record-by-record operation.
 <p>
 The example below counts the number of token of the value string.
 <pre><code>
 KTable&lt;String, String&gt; inputTable = builder.table("topic");
 KTable&lt;String, Integer&gt; outputTable = inputTable.mapValue(new ValueMapper&lt;String, Integer&gt; {
     Integer apply(String value) {
         return value.split(" ").length;
     }
 });
 </code></pre>
 <p>
 To query the local <a href="../../../../../org/apache/kafka/streams/state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state"><code>KeyValueStore</code></a> representing outputTable above it must be obtained via
 <a href="../../../../../org/apache/kafka/streams/KafkaStreams.html#store-java.lang.String-org.apache.kafka.streams.state.QueryableStoreType-"><code>KafkaStreams#store(...)</code></a>:
 For non-local keys, a custom RPC mechanism must be implemented using <a href="../../../../../org/apache/kafka/streams/KafkaStreams.html#allMetadata--"><code>KafkaStreams.allMetadata()</code></a> to
 query the value of the key on a parallel running instance of your Kafka Streams application.
 <p>
 <p>
 This operation preserves data co-location with respect to the key.
 Thus, <em>no</em> internal data redistribution is required if a key based operator (like a join) is applied to
 the result <code>KTable</code>.
 <p>
 Note that <code>mapValues</code> for a <i>changelog stream</i> works different to <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#mapValues-org.apache.kafka.streams.kstream.ValueMapper-"><code>record stream filters</code></a>, because <a href="../../../../../org/apache/kafka/streams/KeyValue.html" title="class in org.apache.kafka.streams"><code>records</code></a> with <code>null</code> values (so-called tombstone records)
 have delete semantics.
 Thus, for tombstones the provided value-mapper is not evaluated but the tombstone record is forwarded directly to
 delete the corresponding record in the result <code>KTable</code>.</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>VR</code> - the value type of the result <code>KTable</code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>mapper</code> - a <a href="../../../../../org/apache/kafka/streams/kstream/ValueMapper.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueMapper</code></a> that computes a new output value</dd>
<dd><code>queryableStoreName</code> - a user-provided name of the underlying <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> that can be
 used to subsequently query the operation results; valid characters are ASCII
 alphanumerics, '.', '_' and '-'. If <code>null</code> then the results cannot be queried
 (i.e., that would be equivalent to calling <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#mapValues-org.apache.kafka.streams.kstream.ValueMapper-"><code>mapValues(ValueMapper)</code></a>.</dd>
<dd><code>valueSerde</code> - serializer for new value type</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a <code>KTable</code> that contains records with unmodified keys and new values (possibly of different type)</dd>
</dl>
</li>
</ul>
<a name="mapValues-org.apache.kafka.streams.kstream.ValueMapper-org.apache.kafka.common.serialization.Serde-org.apache.kafka.streams.processor.StateStoreSupplier-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>mapValues</h4>
<pre>@Deprecated
&lt;VR&gt;&nbsp;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,VR&gt;&nbsp;mapValues(<a href="../../../../../org/apache/kafka/streams/kstream/ValueMapper.html" title="interface in org.apache.kafka.streams.kstream">ValueMapper</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>,? extends VR&gt;&nbsp;mapper,
                                        <a href="../../../../../org/apache/kafka/common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization">Serde</a>&lt;VR&gt;&nbsp;valueSerde,
                                        <a href="../../../../../org/apache/kafka/streams/processor/StateStoreSupplier.html" title="interface in org.apache.kafka.streams.processor">StateStoreSupplier</a>&lt;<a href="../../../../../org/apache/kafka/streams/state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state">KeyValueStore</a>&gt;&nbsp;storeSupplier)</pre>
<div class="block"><span class="deprecatedLabel">Deprecated.</span>&nbsp;<span class="deprecationComment">use <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#mapValues-org.apache.kafka.streams.kstream.ValueMapper-org.apache.kafka.streams.kstream.Materialized-"><code>mapValues(mapper, Materialized.as(KeyValueByteStoreSupplier).withValueSerde(valueSerde))</code></a></span></div>
<div class="block">Create a new <code>KTable</code> by transforming the value of each record in this <code>KTable</code> into a new value
 (with possible new type)in the new <code>KTable</code>.
 For each <code>KTable</code> update the provided <a href="../../../../../org/apache/kafka/streams/kstream/ValueMapper.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueMapper</code></a> is applied to the value of the update record and
 computes a new value for it, resulting in an update record for the result <code>KTable</code>.
 Thus, an input record <code>&lt;K,V&gt;</code> can be transformed into an output record <code>&lt;K:V'&gt;</code>.
 This is a stateless record-by-record operation.
 <p>
 The example below counts the number of token of the value string.
 <pre><code>
 KTable&lt;String, String&gt; inputTable = builder.table("topic");
 KTable&lt;String, Integer&gt; outputTable = inputTable.mapValue(new ValueMapper&lt;String, Integer&gt; {
     Integer apply(String value) {
         return value.split(" ").length;
     }
 });
 </code></pre>
 <p>
 To query the local <a href="../../../../../org/apache/kafka/streams/state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state"><code>KeyValueStore</code></a> representing outputTable above it must be obtained via
 <a href="../../../../../org/apache/kafka/streams/KafkaStreams.html#store-java.lang.String-org.apache.kafka.streams.state.QueryableStoreType-"><code>KafkaStreams#store(...)</code></a>:
 For non-local keys, a custom RPC mechanism must be implemented using <a href="../../../../../org/apache/kafka/streams/KafkaStreams.html#allMetadata--"><code>KafkaStreams.allMetadata()</code></a> to
 query the value of the key on a parallel running instance of your Kafka Streams application.
 <p>
 <p>
 This operation preserves data co-location with respect to the key.
 Thus, <em>no</em> internal data redistribution is required if a key based operator (like a join) is applied to
 the result <code>KTable</code>.
 <p>
 Note that <code>mapValues</code> for a <i>changelog stream</i> works different to <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#mapValues-org.apache.kafka.streams.kstream.ValueMapper-"><code>record stream filters</code></a>, because <a href="../../../../../org/apache/kafka/streams/KeyValue.html" title="class in org.apache.kafka.streams"><code>records</code></a> with <code>null</code> values (so-called tombstone records)
 have delete semantics.
 Thus, for tombstones the provided value-mapper is not evaluated but the tombstone record is forwarded directly to
 delete the corresponding record in the result <code>KTable</code>.</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>VR</code> - the value type of the result <code>KTable</code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>mapper</code> - a <a href="../../../../../org/apache/kafka/streams/kstream/ValueMapper.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueMapper</code></a> that computes a new output value</dd>
<dd><code>valueSerde</code> - serializer for new value type</dd>
<dd><code>storeSupplier</code> - user defined state store supplier. Cannot be <code>null</code>.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a <code>KTable</code> that contains records with unmodified keys and new values (possibly of different type)</dd>
</dl>
</li>
</ul>
<a name="print--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>print</h4>
<pre>@Deprecated
void&nbsp;print()</pre>
<div class="block"><span class="deprecatedLabel">Deprecated.</span>&nbsp;<span class="deprecationComment">Use the Interactive Queries APIs (e.g., <a href="../../../../../org/apache/kafka/streams/KafkaStreams.html#store-java.lang.String-org.apache.kafka.streams.state.QueryableStoreType-"><code>KafkaStreams.store(String, QueryableStoreType)</code></a>
 followed by <a href="../../../../../org/apache/kafka/streams/state/ReadOnlyKeyValueStore.html#all--"><code>ReadOnlyKeyValueStore.all()</code></a>) to iterate over the keys of a KTable. Alternatively
 convert to a <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="interface in org.apache.kafka.streams.kstream"><code>KStream</code></a> using <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#toStream--"><code>toStream()</code></a> and then use
 <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#print-org.apache.kafka.streams.kstream.Printed-"><code>print(Printed.toSysOut())</code></a> on the result.</span></div>
<div class="block">Print the update records of this <code>KTable</code> to <code>System.out</code>.
 This function will use the generated name of the parent processor node to label the key/value pairs printed to
 the console.
 <p>
 The provided serde will be used to deserialize the key or value in case the type is <code>byte[]</code> before calling
 <code>toString()</code> on the deserialized object.
 <p>
 Implementors will need to override <code>toString()</code> for keys and values that are not of type <code>String</code>,
 <code>Integer</code> etc. to get meaningful information.
 <p>
 Note that <code>print()</code> is not applied to the internal state store and only called for each new <code>KTable</code>
 update record.</div>
</li>
</ul>
<a name="print-java.lang.String-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>print</h4>
<pre>@Deprecated
void&nbsp;print(java.lang.String&nbsp;label)</pre>
<div class="block"><span class="deprecatedLabel">Deprecated.</span>&nbsp;<span class="deprecationComment">Use the Interactive Queries APIs (e.g., <a href="../../../../../org/apache/kafka/streams/KafkaStreams.html#store-java.lang.String-org.apache.kafka.streams.state.QueryableStoreType-"><code>KafkaStreams.store(String, QueryableStoreType)</code></a>
 followed by <a href="../../../../../org/apache/kafka/streams/state/ReadOnlyKeyValueStore.html#all--"><code>ReadOnlyKeyValueStore.all()</code></a>) to iterate over the keys of a KTable. Alternatively
 convert to a <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="interface in org.apache.kafka.streams.kstream"><code>KStream</code></a> using <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#toStream--"><code>toStream()</code></a> and then use
 <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#print-org.apache.kafka.streams.kstream.Printed-"><code>print(Printed.toSysOut().withLabel(lable))</code></a> on the result.</span></div>
<div class="block">Print the update records of this <code>KTable</code> to <code>System.out</code>.
 This function will use the given name to label the key/value pairs printed to the console.
 <p>
 The provided serde will be used to deserialize the key or value in case the type is <code>byte[]</code> before calling
 <code>toString()</code> on the deserialized object.
 <p>
 Implementors will need to override <code>toString()</code> for keys and values that are not of type <code>String</code>,
 <code>Integer</code> etc. to get meaningful information.
 <p>
 Note that <code>print()</code> is not applied to the internal state store and only called for each new <code>KTable</code>
 update record.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>label</code> - the name used to label the key/value pairs printed to the console</dd>
</dl>
</li>
</ul>
<a name="print-org.apache.kafka.common.serialization.Serde-org.apache.kafka.common.serialization.Serde-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>print</h4>
<pre>@Deprecated
void&nbsp;print(<a href="../../../../../org/apache/kafka/common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization">Serde</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>&gt;&nbsp;keySerde,
                       <a href="../../../../../org/apache/kafka/common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization">Serde</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>&gt;&nbsp;valSerde)</pre>
<div class="block"><span class="deprecatedLabel">Deprecated.</span>&nbsp;<span class="deprecationComment">Use the Interactive Queries APIs (e.g., <a href="../../../../../org/apache/kafka/streams/KafkaStreams.html#store-java.lang.String-org.apache.kafka.streams.state.QueryableStoreType-"><code>KafkaStreams.store(String, QueryableStoreType)</code></a>
 followed by <a href="../../../../../org/apache/kafka/streams/state/ReadOnlyKeyValueStore.html#all--"><code>ReadOnlyKeyValueStore.all()</code></a>) to iterate over the keys of a KTable. Alternatively
 convert to a <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="interface in org.apache.kafka.streams.kstream"><code>KStream</code></a> using <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#toStream--"><code>toStream()</code></a> and then use
 <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#print-org.apache.kafka.streams.kstream.Printed-"><code>print(Printed.toSysOut().withKeyValueMapper(...)</code></a> on the result.</span></div>
<div class="block">Print the update records of this <code>KTable</code> to <code>System.out</code>.
 This function will use the generated name of the parent processor node to label the key/value pairs printed to
 the console.
 <p>
 The provided serde will be used to deserialize the key or value in case the type is <code>byte[]</code> before calling
 <code>toString()</code> on the deserialized object.
 <p>
 Implementors will need to override <code>toString()</code> for keys and values that are not of type <code>String</code>,
 <code>Integer</code> etc. to get meaningful information.
 <p>
 Note that <code>print()</code> is not applied to the internal state store and only called for each new <code>KTable</code>
 update record.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>keySerde</code> - key serde used to deserialize key if type is <code>byte[]</code>,</dd>
<dd><code>valSerde</code> - value serde used to deserialize value if type is <code>byte[]</code></dd>
</dl>
</li>
</ul>
<a name="print-org.apache.kafka.common.serialization.Serde-org.apache.kafka.common.serialization.Serde-java.lang.String-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>print</h4>
<pre>@Deprecated
void&nbsp;print(<a href="../../../../../org/apache/kafka/common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization">Serde</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>&gt;&nbsp;keySerde,
                       <a href="../../../../../org/apache/kafka/common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization">Serde</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>&gt;&nbsp;valSerde,
                       java.lang.String&nbsp;label)</pre>
<div class="block"><span class="deprecatedLabel">Deprecated.</span>&nbsp;<span class="deprecationComment">Use the Interactive Queries APIs (e.g., <a href="../../../../../org/apache/kafka/streams/KafkaStreams.html#store-java.lang.String-org.apache.kafka.streams.state.QueryableStoreType-"><code>KafkaStreams.store(String, QueryableStoreType)</code></a>
 followed by <a href="../../../../../org/apache/kafka/streams/state/ReadOnlyKeyValueStore.html#all--"><code>ReadOnlyKeyValueStore.all()</code></a>) to iterate over the keys of a KTable. Alternatively
 convert to a <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="interface in org.apache.kafka.streams.kstream"><code>KStream</code></a> using <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#toStream--"><code>toStream()</code></a> and then use
 <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#print-org.apache.kafka.streams.kstream.Printed-"><code>print(Printed.toSysOut().withLabel(label).withKeyValueMapper(...)</code></a> on the result.</span></div>
<div class="block">Print the update records of this <code>KTable</code> to <code>System.out</code>.
 This function will use the given name to label the key/value pairs printed to the console.
 <p>
 The provided serde will be used to deserialize the key or value in case the type is <code>byte[]</code> before calling
 <code>toString()</code> on the deserialized object.
 <p>
 Implementors will need to override <code>toString()</code> for keys and values that are not of type <code>String</code>,
 <code>Integer</code> etc. to get meaningful information.
 <p>
 Note that <code>print()</code> is not applied to the internal state store and only called for each new <code>KTable</code>
 update record.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>keySerde</code> - key serde used to deserialize key if type is <code>byte[]</code>,</dd>
<dd><code>valSerde</code> - value serde used to deserialize value if type is <code>byte[]</code>,</dd>
<dd><code>label</code> - the name used to label the key/value pairs printed to the console</dd>
</dl>
</li>
</ul>
<a name="writeAsText-java.lang.String-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>writeAsText</h4>
<pre>@Deprecated
void&nbsp;writeAsText(java.lang.String&nbsp;filePath)</pre>
<div class="block"><span class="deprecatedLabel">Deprecated.</span>&nbsp;<span class="deprecationComment">Use the Interactive Queries APIs (e.g., <a href="../../../../../org/apache/kafka/streams/KafkaStreams.html#store-java.lang.String-org.apache.kafka.streams.state.QueryableStoreType-"><code>KafkaStreams.store(String, QueryableStoreType)</code></a>
 followed by <a href="../../../../../org/apache/kafka/streams/state/ReadOnlyKeyValueStore.html#all--"><code>ReadOnlyKeyValueStore.all()</code></a>) to iterate over the keys of a KTable. Alternatively
 convert to a <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="interface in org.apache.kafka.streams.kstream"><code>KStream</code></a> using <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#toStream--"><code>toStream()</code></a> and then use
 <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#print-org.apache.kafka.streams.kstream.Printed-"><code>print(Printed.toFile(filePath)</code></a> on the result.</span></div>
<div class="block">Write the update records of this <code>KTable</code> to a file at the given path.
 This function will use the generated name of the parent processor node to label the key/value pairs printed to
 the file.
 <p>
 The default serde will be used to deserialize the key or value in case the type is <code>byte[]</code> before calling
 <code>toString()</code> on the deserialized object.
 <p>
 Implementors will need to override <code>toString()</code> for keys and values that are not of type <code>String</code>,
 <code>Integer</code> etc. to get meaningful information.
 <p>
 Note that <code>writeAsText()</code> is not applied to the internal state store and only called for each new
 <code>KTable</code> update record.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>filePath</code> - name of file to write to</dd>
</dl>
</li>
</ul>
<a name="writeAsText-java.lang.String-java.lang.String-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>writeAsText</h4>
<pre>@Deprecated
void&nbsp;writeAsText(java.lang.String&nbsp;filePath,
                             java.lang.String&nbsp;label)</pre>
<div class="block"><span class="deprecatedLabel">Deprecated.</span>&nbsp;<span class="deprecationComment">Use the Interactive Queries APIs (e.g., <a href="../../../../../org/apache/kafka/streams/KafkaStreams.html#store-java.lang.String-org.apache.kafka.streams.state.QueryableStoreType-"><code>KafkaStreams.store(String, QueryableStoreType)</code></a>
 followed by <a href="../../../../../org/apache/kafka/streams/state/ReadOnlyKeyValueStore.html#all--"><code>ReadOnlyKeyValueStore.all()</code></a>) to iterate over the keys of a KTable. Alternatively
 convert to a <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="interface in org.apache.kafka.streams.kstream"><code>KStream</code></a> using <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#toStream--"><code>toStream()</code></a> and then use
 <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#print-org.apache.kafka.streams.kstream.Printed-"><code>print(Printed.toFile(filePath).withLabel(label)</code></a> on the result.</span></div>
<div class="block">Write the update records of this <code>KTable</code> to a file at the given path.
 This function will use the given name to label the key/value printed to the file.
 <p>
 The default serde will be used to deserialize the key or value in case the type is <code>byte[]</code> before calling
 <code>toString()</code> on the deserialized object.
 <p>
 Implementors will need to override <code>toString()</code> for keys and values that are not of type <code>String</code>,
 <code>Integer</code> etc. to get meaningful information.
 <p>
 Note that <code>writeAsText()</code> is not applied to the internal state store and only called for each new
 <code>KTable</code> update record.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>filePath</code> - name of file to write to</dd>
<dd><code>label</code> - the name used to label the key/value pairs printed out to the console</dd>
</dl>
</li>
</ul>
<a name="writeAsText-java.lang.String-org.apache.kafka.common.serialization.Serde-org.apache.kafka.common.serialization.Serde-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>writeAsText</h4>
<pre>@Deprecated
void&nbsp;writeAsText(java.lang.String&nbsp;filePath,
                             <a href="../../../../../org/apache/kafka/common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization">Serde</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>&gt;&nbsp;keySerde,
                             <a href="../../../../../org/apache/kafka/common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization">Serde</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>&gt;&nbsp;valSerde)</pre>
<div class="block"><span class="deprecatedLabel">Deprecated.</span>&nbsp;<span class="deprecationComment">Use the Interactive Queries APIs (e.g., <a href="../../../../../org/apache/kafka/streams/KafkaStreams.html#store-java.lang.String-org.apache.kafka.streams.state.QueryableStoreType-"><code>KafkaStreams.store(String, QueryableStoreType)</code></a>
 followed by <a href="../../../../../org/apache/kafka/streams/state/ReadOnlyKeyValueStore.html#all--"><code>ReadOnlyKeyValueStore.all()</code></a>) to iterate over the keys of a KTable. Alternatively
 convert to a <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="interface in org.apache.kafka.streams.kstream"><code>KStream</code></a> using <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#toStream--"><code>toStream()</code></a> and then use
 <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#print-org.apache.kafka.streams.kstream.Printed-"><code>print(Printed.toFile(filePath).withKeyValueMapper(...)</code></a> on the result.</span></div>
<div class="block">Write the update records of this <code>KTable</code> to a file at the given path.
 This function will use the generated name of the parent processor node to label the key/value pairs printed to
 the file.
 <p>
 The provided serde will be used to deserialize the key or value in case the type is <code>byte[]</code> before calling
 <code>toString()</code> on the deserialized object.
 <p>
 Implementors will need to override <code>toString()</code> for keys and values that are not of type <code>String</code>,
 <code>Integer</code> etc. to get meaningful information.
 <p>
 Note that <code>writeAsText()</code> is not applied to the internal state store and only called for each new
 <code>KTable</code> update record.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>filePath</code> - name of file to write to</dd>
<dd><code>keySerde</code> - key serde used to deserialize key if type is <code>byte[]</code>,</dd>
<dd><code>valSerde</code> - value serde used to deserialize value if type is <code>byte[]</code></dd>
</dl>
</li>
</ul>
<a name="writeAsText-java.lang.String-java.lang.String-org.apache.kafka.common.serialization.Serde-org.apache.kafka.common.serialization.Serde-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>writeAsText</h4>
<pre>@Deprecated
void&nbsp;writeAsText(java.lang.String&nbsp;filePath,
                             java.lang.String&nbsp;label,
                             <a href="../../../../../org/apache/kafka/common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization">Serde</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>&gt;&nbsp;keySerde,
                             <a href="../../../../../org/apache/kafka/common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization">Serde</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>&gt;&nbsp;valSerde)</pre>
<div class="block"><span class="deprecatedLabel">Deprecated.</span>&nbsp;<span class="deprecationComment">Use the Interactive Queries APIs (e.g., <a href="../../../../../org/apache/kafka/streams/KafkaStreams.html#store-java.lang.String-org.apache.kafka.streams.state.QueryableStoreType-"><code>KafkaStreams.store(String, QueryableStoreType)</code></a>
 followed by <a href="../../../../../org/apache/kafka/streams/state/ReadOnlyKeyValueStore.html#all--"><code>ReadOnlyKeyValueStore.all()</code></a>) to iterate over the keys of a KTable. Alternatively
 convert to a <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="interface in org.apache.kafka.streams.kstream"><code>KStream</code></a> using <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#toStream--"><code>toStream()</code></a> and then use
 <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#print-org.apache.kafka.streams.kstream.Printed-"><code>print(Printed.toFile(filePath).withLabel(label).withKeyValueMapper(...)</code></a> on the result.</span></div>
<div class="block">Write the update records of this <code>KTable</code> to a file at the given path.
 This function will use the given name to label the key/value printed to the file.
 <p>
 The default serde will be used to deserialize the key or value in case the type is <code>byte[]</code> before calling
 <code>toString()</code> on the deserialized object.
 <p>
 Implementors will need to override <code>toString()</code> for keys and values that are not of type <code>String</code>,
 <code>Integer</code> etc. to get meaningful information.
 <p>
 Note that <code>writeAsText()</code> is not applied to the internal state store and only called for each new
 <code>KTable</code> update record.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>filePath</code> - name of file to write to</dd>
<dd><code>label</code> - the name used to label the key/value pairs printed to the console</dd>
<dd><code>keySerde</code> - key serde used to deserialize key if type is <code>byte[]</code>,</dd>
<dd><code>valSerde</code> - value serde used to deserialize value if type is <code>byte[]</code></dd>
</dl>
</li>
</ul>
<a name="foreach-org.apache.kafka.streams.kstream.ForeachAction-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>foreach</h4>
<pre>@Deprecated
void&nbsp;foreach(<a href="../../../../../org/apache/kafka/streams/kstream/ForeachAction.html" title="interface in org.apache.kafka.streams.kstream">ForeachAction</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,? super <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>&gt;&nbsp;action)</pre>
<div class="block"><span class="deprecatedLabel">Deprecated.</span>&nbsp;<span class="deprecationComment">Use the Interactive Queries APIs (e.g., <a href="../../../../../org/apache/kafka/streams/KafkaStreams.html#store-java.lang.String-org.apache.kafka.streams.state.QueryableStoreType-"><code>KafkaStreams.store(String, QueryableStoreType)</code></a>
 followed by <a href="../../../../../org/apache/kafka/streams/state/ReadOnlyKeyValueStore.html#all--"><code>ReadOnlyKeyValueStore.all()</code></a>) to iterate over the keys of a KTable. Alternatively
 convert to a <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="interface in org.apache.kafka.streams.kstream"><code>KStream</code></a> using <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#toStream--"><code>toStream()</code></a> and then use
 <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#foreach-org.apache.kafka.streams.kstream.ForeachAction-"><code>foreach(action)</code></a> on the result.</span></div>
<div class="block">Perform an action on each update record of this <code>KTable</code>.
 Note that this is a terminal operation that returns void.
 <p>
 Note that <code>foreach()</code> is not applied to the internal state store and only called for each new
 <code>KTable</code> update record.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>action</code> - an action to perform on each record</dd>
</dl>
</li>
</ul>
<a name="toStream--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>toStream</h4>
<pre><a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="interface in org.apache.kafka.streams.kstream">KStream</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>&gt;&nbsp;toStream()</pre>
<div class="block">Convert this changelog stream to a <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="interface in org.apache.kafka.streams.kstream"><code>KStream</code></a>.
 <p>
 Note that this is a logical operation and only changes the "interpretation" of the stream, i.e., each record of
 this changelog stream is no longer treated as an update record (cf. <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="interface in org.apache.kafka.streams.kstream"><code>KStream</code></a> vs <code>KTable</code>).</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="interface in org.apache.kafka.streams.kstream"><code>KStream</code></a> that contains the same records as this <code>KTable</code></dd>
</dl>
</li>
</ul>
<a name="toStream-org.apache.kafka.streams.kstream.KeyValueMapper-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>toStream</h4>
<pre>&lt;KR&gt;&nbsp;<a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="interface in org.apache.kafka.streams.kstream">KStream</a>&lt;KR,<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>&gt;&nbsp;toStream(<a href="../../../../../org/apache/kafka/streams/kstream/KeyValueMapper.html" title="interface in org.apache.kafka.streams.kstream">KeyValueMapper</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,? super <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>,? extends KR&gt;&nbsp;mapper)</pre>
<div class="block">Convert this changelog stream to a <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="interface in org.apache.kafka.streams.kstream"><code>KStream</code></a> using the given <a href="../../../../../org/apache/kafka/streams/kstream/KeyValueMapper.html" title="interface in org.apache.kafka.streams.kstream"><code>KeyValueMapper</code></a> to select the new key.
 <p>
 For example, you can compute the new key as the length of the value string.
 <pre><code>
 KTable&lt;String, String&gt; table = builder.table("topic");
 KTable&lt;Integer, String&gt; keyedStream = table.toStream(new KeyValueMapper&lt;String, String, Integer&gt; {
     Integer apply(String key, String value) {
         return value.length();
     }
 });
 </code></pre>
 Setting a new key might result in an internal data redistribution if a key based operator (like an aggregation or
 join) is applied to the result <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="interface in org.apache.kafka.streams.kstream"><code>KStream</code></a>.
 <p>
 This operation is equivalent to calling
 <code>table.</code><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#toStream--"><code>toStream</code></a><code>().</code><a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#selectKey-org.apache.kafka.streams.kstream.KeyValueMapper-"><code>selectKey(KeyValueMapper)</code></a>.
 <p>
 Note that <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#toStream--"><code>toStream()</code></a> is a logical operation and only changes the "interpretation" of the stream, i.e.,
 each record of this changelog stream is no longer treated as an update record (cf. <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="interface in org.apache.kafka.streams.kstream"><code>KStream</code></a> vs <code>KTable</code>).</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>KR</code> - the new key type of the result stream</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>mapper</code> - a <a href="../../../../../org/apache/kafka/streams/kstream/KeyValueMapper.html" title="interface in org.apache.kafka.streams.kstream"><code>KeyValueMapper</code></a> that computes a new key for each record</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html" title="interface in org.apache.kafka.streams.kstream"><code>KStream</code></a> that contains the same records as this <code>KTable</code></dd>
</dl>
</li>
</ul>
<a name="through-java.lang.String-java.lang.String-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>through</h4>
<pre>@Deprecated
<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>&gt;&nbsp;through(java.lang.String&nbsp;topic,
                                java.lang.String&nbsp;queryableStoreName)</pre>
<div class="block"><span class="deprecatedLabel">Deprecated.</span>&nbsp;<span class="deprecationComment">use <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#toStream--"><code>toStream()</code></a> followed by <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#to-java.lang.String-"><code>to(topic)</code></a> and
 <a href="../../../../../org/apache/kafka/streams/StreamsBuilder.html#table-java.lang.String-org.apache.kafka.streams.kstream.Materialized-"><code>StreamsBuilder#table(topic, Materialized.as(queryableStoreName))</code></a>
 to read back as a <code>KTable</code></span></div>
<div class="block">Materialize this changelog stream to a topic and creates a new <code>KTable</code> from the topic using default
 serializers and deserializers and producer's <code>DefaultPartitioner</code>.
 The specified topic should be manually created before it is used (i.e., before the Kafka Streams application is
 started).
 <p>
 This is equivalent to calling <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#to-java.lang.String-"><code>#to(someTopicName)</code></a> and
 <a href="../../../../../org/apache/kafka/streams/kstream/KStreamBuilder.html#table-java.lang.String-java.lang.String-"><code>KStreamBuilder#table(someTopicName, queryableStoreName)</code></a>.
 <p>
 The resulting <code>KTable</code> will be materialized in a local state store with the given store name (cf.
 <a href="../../../../../org/apache/kafka/streams/kstream/KStreamBuilder.html#table-java.lang.String-java.lang.String-"><code>KStreamBuilder.table(String, String)</code></a>)
 The store name must be a valid Kafka topic name and cannot contain characters other than ASCII alphanumerics, '.', '_' and '-'.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>topic</code> - the topic name</dd>
<dd><code>queryableStoreName</code> - the state store name used for the result <code>KTable</code>; valid characters are ASCII
                  alphanumerics, '.', '_' and '-'. If <code>null</code> this is the equivalent of <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#through-java.lang.String-"><code>through(String)</code></a></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a <code>KTable</code> that contains the exact same (and potentially repartitioned) records as this <code>KTable</code></dd>
</dl>
</li>
</ul>
<a name="through-java.lang.String-org.apache.kafka.streams.processor.StateStoreSupplier-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>through</h4>
<pre>@Deprecated
<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>&gt;&nbsp;through(java.lang.String&nbsp;topic,
                                <a href="../../../../../org/apache/kafka/streams/processor/StateStoreSupplier.html" title="interface in org.apache.kafka.streams.processor">StateStoreSupplier</a>&lt;<a href="../../../../../org/apache/kafka/streams/state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state">KeyValueStore</a>&gt;&nbsp;storeSupplier)</pre>
<div class="block"><span class="deprecatedLabel">Deprecated.</span>&nbsp;<span class="deprecationComment">use <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#toStream--"><code>toStream()</code></a> followed by <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#to-java.lang.String-"><code>to(topic)</code></a> and
 and <a href="../../../../../org/apache/kafka/streams/StreamsBuilder.html#table-java.lang.String-org.apache.kafka.streams.kstream.Materialized-"><code>StreamsBuilder#table(topic, Materialized.as(KeyValueBytesStoreSupplier))</code></a>
 to read back as a <code>KTable</code></span></div>
<div class="block">Materialize this changelog stream to a topic and creates a new <code>KTable</code> from the topic using default
 serializers and deserializers and producer's <code>DefaultPartitioner</code>.
 The specified topic should be manually created before it is used (i.e., before the Kafka Streams application is
 started).
 <p>
 This is equivalent to calling <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#to-java.lang.String-"><code>#to(someTopicName)</code></a> and
 <a href="../../../../../org/apache/kafka/streams/kstream/KStreamBuilder.html#table-java.lang.String-java.lang.String-"><code>KStreamBuilder#table(someTopicName, queryableStoreName)</code></a>.
 <p>
 The resulting <code>KTable</code> will be materialized in a local state store with the given store name (cf.
 <a href="../../../../../org/apache/kafka/streams/kstream/KStreamBuilder.html#table-java.lang.String-java.lang.String-"><code>KStreamBuilder.table(String, String)</code></a>)
 The store name must be a valid Kafka topic name and cannot contain characters other than ASCII alphanumerics, '.', '_' and '-'.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>topic</code> - the topic name</dd>
<dd><code>storeSupplier</code> - user defined state store supplier. Cannot be <code>null</code>.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a <code>KTable</code> that contains the exact same (and potentially repartitioned) records as this <code>KTable</code></dd>
</dl>
</li>
</ul>
<a name="through-java.lang.String-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>through</h4>
<pre>@Deprecated
<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>&gt;&nbsp;through(java.lang.String&nbsp;topic)</pre>
<div class="block"><span class="deprecatedLabel">Deprecated.</span>&nbsp;<span class="deprecationComment">use <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#toStream--"><code>toStream()</code></a> followed by <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#to-java.lang.String-"><code>to(topic)</code></a> and
 and <a href="../../../../../org/apache/kafka/streams/StreamsBuilder.html#table-java.lang.String-"><code>StreamsBuilder#table(topic)</code></a> to read back as a <code>KTable</code></span></div>
<div class="block">Materialize this changelog stream to a topic and creates a new <code>KTable</code> from the topic using default
 serializers and deserializers and producer's <code>DefaultPartitioner</code>.
 The specified topic should be manually created before it is used (i.e., before the Kafka Streams application is
 started).
 <p>
 This is equivalent to calling <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#to-java.lang.String-"><code>#to(someTopicName)</code></a> and
 <a href="../../../../../org/apache/kafka/streams/kstream/KStreamBuilder.html#table-java.lang.String-"><code>KStreamBuilder#table(someTopicName)</code></a>.
 <p>
 The resulting <code>KTable</code> will be materialized in a local state store with an internal store name (cf.
 <a href="../../../../../org/apache/kafka/streams/kstream/KStreamBuilder.html#table-java.lang.String-"><code>KStreamBuilder.table(String)</code></a>)</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>topic</code> - the topic name</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a <code>KTable</code> that contains the exact same (and potentially repartitioned) records as this <code>KTable</code></dd>
</dl>
</li>
</ul>
<a name="through-org.apache.kafka.streams.processor.StreamPartitioner-java.lang.String-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>through</h4>
<pre>@Deprecated
<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>&gt;&nbsp;through(<a href="../../../../../org/apache/kafka/streams/processor/StreamPartitioner.html" title="interface in org.apache.kafka.streams.processor">StreamPartitioner</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,? super <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>&gt;&nbsp;partitioner,
                                java.lang.String&nbsp;topic)</pre>
<div class="block"><span class="deprecatedLabel">Deprecated.</span>&nbsp;<span class="deprecationComment">use <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#toStream--"><code>toStream()</code></a> followed by
 <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#to-java.lang.String-org.apache.kafka.streams.kstream.Produced-"><code>to(topic, Produced.streamPartitioner(partitioner))</code></a> and
 <a href="../../../../../org/apache/kafka/streams/StreamsBuilder.html#table-java.lang.String-"><code>StreamsBuilder#table(topic)</code></a> to read back as a <code>KTable</code></span></div>
<div class="block">Materialize this changelog stream to a topic and creates a new <code>KTable</code> from the topic using default
 serializers and deserializers and a customizable <a href="../../../../../org/apache/kafka/streams/processor/StreamPartitioner.html" title="interface in org.apache.kafka.streams.processor"><code>StreamPartitioner</code></a> to determine the distribution of
 records to partitions.
 The specified topic should be manually created before it is used (i.e., before the Kafka Streams application is
 started).
 <p>
 This is equivalent to calling <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#to-org.apache.kafka.streams.processor.StreamPartitioner-java.lang.String-"><code>#to(partitioner, someTopicName)</code></a> and
 <a href="../../../../../org/apache/kafka/streams/kstream/KStreamBuilder.html#table-java.lang.String-"><code>KStreamBuilder#table(someTopicName)</code></a>.
 <p>
 The resulting <code>KTable</code> will be materialized in a local state store with an internal store name (cf.
 <a href="../../../../../org/apache/kafka/streams/kstream/KStreamBuilder.html#table-java.lang.String-"><code>KStreamBuilder.table(String)</code></a>)</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>partitioner</code> - the function used to determine how records are distributed among partitions of the topic,
                    if not specified producer's <code>DefaultPartitioner</code> will be used</dd>
<dd><code>topic</code> - the topic name</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a <code>KTable</code> that contains the exact same (and potentially repartitioned) records as this <code>KTable</code></dd>
</dl>
</li>
</ul>
<a name="through-org.apache.kafka.streams.processor.StreamPartitioner-java.lang.String-java.lang.String-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>through</h4>
<pre>@Deprecated
<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>&gt;&nbsp;through(<a href="../../../../../org/apache/kafka/streams/processor/StreamPartitioner.html" title="interface in org.apache.kafka.streams.processor">StreamPartitioner</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,? super <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>&gt;&nbsp;partitioner,
                                java.lang.String&nbsp;topic,
                                java.lang.String&nbsp;queryableStoreName)</pre>
<div class="block"><span class="deprecatedLabel">Deprecated.</span>&nbsp;<span class="deprecationComment">use <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#toStream--"><code>toStream()</code></a> followed by
 <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#to-java.lang.String-org.apache.kafka.streams.kstream.Produced-"><code>to(topic, Produced.streamPartitioner(partitioner))</code></a> and
 <a href="../../../../../org/apache/kafka/streams/StreamsBuilder.html#table-java.lang.String-org.apache.kafka.streams.kstream.Materialized-"><code>StreamsBuilder#table(topic, Materialized.as(queryableStoreName))</code></a>
 to read back as a <code>KTable</code></span></div>
<div class="block">Materialize this changelog stream to a topic and creates a new <code>KTable</code> from the topic using default
 serializers and deserializers and a customizable <a href="../../../../../org/apache/kafka/streams/processor/StreamPartitioner.html" title="interface in org.apache.kafka.streams.processor"><code>StreamPartitioner</code></a> to determine the distribution of
 records to partitions.
 The specified topic should be manually created before it is used (i.e., before the Kafka Streams application is
 started).
 <p>
 This is equivalent to calling <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#to-org.apache.kafka.streams.processor.StreamPartitioner-java.lang.String-"><code>#to(partitioner, someTopicName)</code></a> and
 <a href="../../../../../org/apache/kafka/streams/kstream/KStreamBuilder.html#table-java.lang.String-java.lang.String-"><code>KStreamBuilder#table(someTopicName, queryableStoreName)</code></a>.
 <p>
 The resulting <code>KTable</code> will be materialized in a local state store with the given store name (cf.
 <a href="../../../../../org/apache/kafka/streams/kstream/KStreamBuilder.html#table-java.lang.String-java.lang.String-"><code>KStreamBuilder.table(String, String)</code></a>)</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>partitioner</code> - the function used to determine how records are distributed among partitions of the topic,
                    if not specified producer's <code>DefaultPartitioner</code> will be used</dd>
<dd><code>topic</code> - the topic name</dd>
<dd><code>queryableStoreName</code> - the state store name used for the result <code>KTable</code>.
                             If <code>null</code> this is the equivalent of <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#through-org.apache.kafka.streams.processor.StreamPartitioner-java.lang.String-"><code>through(StreamPartitioner, String)</code></a></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a <code>KTable</code> that contains the exact same (and potentially repartitioned) records as this <code>KTable</code></dd>
</dl>
</li>
</ul>
<a name="through-org.apache.kafka.streams.processor.StreamPartitioner-java.lang.String-org.apache.kafka.streams.processor.StateStoreSupplier-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>through</h4>
<pre>@Deprecated
<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>&gt;&nbsp;through(<a href="../../../../../org/apache/kafka/streams/processor/StreamPartitioner.html" title="interface in org.apache.kafka.streams.processor">StreamPartitioner</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,? super <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>&gt;&nbsp;partitioner,
                                java.lang.String&nbsp;topic,
                                <a href="../../../../../org/apache/kafka/streams/processor/StateStoreSupplier.html" title="interface in org.apache.kafka.streams.processor">StateStoreSupplier</a>&lt;<a href="../../../../../org/apache/kafka/streams/state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state">KeyValueStore</a>&gt;&nbsp;storeSupplier)</pre>
<div class="block"><span class="deprecatedLabel">Deprecated.</span>&nbsp;<span class="deprecationComment">use <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#toStream--"><code>toStream()</code></a> followed by
 <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#to-java.lang.String-org.apache.kafka.streams.kstream.Produced-"><code>to(topic, Produced.streamPartitioner(partitioner))</code></a> and
 <a href="../../../../../org/apache/kafka/streams/StreamsBuilder.html#table-java.lang.String-org.apache.kafka.streams.kstream.Materialized-"><code>StreamsBuilder#table(topic, Materialized.as(KeyValueBytesStoreSupplier)</code></a>
 to read back as a <code>KTable</code></span></div>
<div class="block">Materialize this changelog stream to a topic and creates a new <code>KTable</code> from the topic using default
 serializers and deserializers and a customizable <a href="../../../../../org/apache/kafka/streams/processor/StreamPartitioner.html" title="interface in org.apache.kafka.streams.processor"><code>StreamPartitioner</code></a> to determine the distribution of
 records to partitions.
 The specified topic should be manually created before it is used (i.e., before the Kafka Streams application is
 started).
 <p>
 This is equivalent to calling <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#to-org.apache.kafka.streams.processor.StreamPartitioner-java.lang.String-"><code>#to(partitioner, someTopicName)</code></a> and
 <a href="../../../../../org/apache/kafka/streams/kstream/KStreamBuilder.html#table-java.lang.String-java.lang.String-"><code>KStreamBuilder#table(someTopicName, queryableStoreName)</code></a>.
 <p>
 The resulting <code>KTable</code> will be materialized in a local state store with the given store name (cf.
 <a href="../../../../../org/apache/kafka/streams/kstream/KStreamBuilder.html#table-java.lang.String-java.lang.String-"><code>KStreamBuilder.table(String, String)</code></a>)</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>partitioner</code> - the function used to determine how records are distributed among partitions of the topic,
                    if not specified producer's <code>DefaultPartitioner</code> will be used</dd>
<dd><code>topic</code> - the topic name</dd>
<dd><code>storeSupplier</code> - user defined state store supplier. Cannot be <code>null</code>.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a <code>KTable</code> that contains the exact same (and potentially repartitioned) records as this <code>KTable</code></dd>
</dl>
</li>
</ul>
<a name="through-org.apache.kafka.common.serialization.Serde-org.apache.kafka.common.serialization.Serde-java.lang.String-java.lang.String-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>through</h4>
<pre>@Deprecated
<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>&gt;&nbsp;through(<a href="../../../../../org/apache/kafka/common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization">Serde</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>&gt;&nbsp;keySerde,
                                <a href="../../../../../org/apache/kafka/common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization">Serde</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>&gt;&nbsp;valSerde,
                                java.lang.String&nbsp;topic,
                                java.lang.String&nbsp;queryableStoreName)</pre>
<div class="block"><span class="deprecatedLabel">Deprecated.</span>&nbsp;<span class="deprecationComment">use <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#toStream--"><code>toStream()</code></a> followed by
 <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#to-java.lang.String-org.apache.kafka.streams.kstream.Produced-"><code>to(topic, Produced.with(keySerde, valSerde))</code></a> and
 <a href="../../../../../org/apache/kafka/streams/StreamsBuilder.html#table-java.lang.String-org.apache.kafka.streams.kstream.Materialized-"><code>StreamsBuilder#table(topic, Materialized.as(queryableStoreName))</code></a>
 to read back as a <code>KTable</code></span></div>
<div class="block">Materialize this changelog stream to a topic and creates a new <code>KTable</code> from the topic.
 The specified topic should be manually created before it is used (i.e., before the Kafka Streams application is
 started).
 <p>
 If <code>keySerde</code> provides a <code>WindowedSerializer</code> for the key <code>WindowedStreamPartitioner</code> is
 used&mdash;otherwise producer's <code>DefaultPartitioner</code> is used.
 <p>
 This is equivalent to calling <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#to-org.apache.kafka.common.serialization.Serde-org.apache.kafka.common.serialization.Serde-java.lang.String-"><code>#to(keySerde, valueSerde, someTopicName)</code></a> and
 <a href="../../../../../org/apache/kafka/streams/kstream/KStreamBuilder.html#table-java.lang.String-java.lang.String-"><code>StreamsBuilder#table(someTopicName, queryableStoreName)</code></a>.
 <p>
 The resulting <code>KTable</code> will be materialized in a local state store with the given store name (cf.
 <a href="../../../../../org/apache/kafka/streams/kstream/KStreamBuilder.html#table-java.lang.String-java.lang.String-"><code>KStreamBuilder.table(String, String)</code></a>)</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>keySerde</code> - key serde used to send key-value pairs,
                  if not specified the default key serde defined in the configuration will be used</dd>
<dd><code>valSerde</code> - value serde used to send key-value pairs,
                  if not specified the default value serde defined in the configuration will be used</dd>
<dd><code>topic</code> - the topic name</dd>
<dd><code>queryableStoreName</code> - the state store name used for the result <code>KTable</code>.
                           If <code>null</code> this is the equivalent of <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#through-org.apache.kafka.common.serialization.Serde-org.apache.kafka.common.serialization.Serde-java.lang.String-"><code>through(Serde, Serde, String)</code></a></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a <code>KTable</code> that contains the exact same (and potentially repartitioned) records as this <code>KTable</code></dd>
</dl>
</li>
</ul>
<a name="through-org.apache.kafka.common.serialization.Serde-org.apache.kafka.common.serialization.Serde-java.lang.String-org.apache.kafka.streams.processor.StateStoreSupplier-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>through</h4>
<pre>@Deprecated
<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>&gt;&nbsp;through(<a href="../../../../../org/apache/kafka/common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization">Serde</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>&gt;&nbsp;keySerde,
                                <a href="../../../../../org/apache/kafka/common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization">Serde</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>&gt;&nbsp;valSerde,
                                java.lang.String&nbsp;topic,
                                <a href="../../../../../org/apache/kafka/streams/processor/StateStoreSupplier.html" title="interface in org.apache.kafka.streams.processor">StateStoreSupplier</a>&lt;<a href="../../../../../org/apache/kafka/streams/state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state">KeyValueStore</a>&gt;&nbsp;storeSupplier)</pre>
<div class="block"><span class="deprecatedLabel">Deprecated.</span>&nbsp;<span class="deprecationComment">use <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#toStream--"><code>toStream()</code></a> followed by
 <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#to-java.lang.String-org.apache.kafka.streams.kstream.Produced-"><code>to(topic, Produced.with(keySerde, valSerde))</code></a> and
 <a href="../../../../../org/apache/kafka/streams/StreamsBuilder.html#table-java.lang.String-org.apache.kafka.streams.kstream.Materialized-"><code>StreamsBuilder#table(topic, Materialized.as(KeyValueBytesStoreSupplier)</code></a>
 to read back as a <code>KTable</code></span></div>
<div class="block">Materialize this changelog stream to a topic and creates a new <code>KTable</code> from the topic.
 The specified topic should be manually created before it is used (i.e., before the Kafka Streams application is
 started).
 <p>
 If <code>keySerde</code> provides a <code>WindowedSerializer</code> for the key <code>WindowedStreamPartitioner</code> is
 used&mdash;otherwise producer's <code>DefaultPartitioner</code> is used.
 <p>
 This is equivalent to calling <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#to-org.apache.kafka.common.serialization.Serde-org.apache.kafka.common.serialization.Serde-java.lang.String-"><code>#to(keySerde, valueSerde, someTopicName)</code></a> and
 <a href="../../../../../org/apache/kafka/streams/kstream/KStreamBuilder.html#table-java.lang.String-java.lang.String-"><code>KStreamBuilder#table(someTopicName, queryableStoreName)</code></a>.
 <p>
 The resulting <code>KTable</code> will be materialized in a local state store with the given store name (cf.
 <a href="../../../../../org/apache/kafka/streams/StreamsBuilder.html#table-java.lang.String-org.apache.kafka.streams.kstream.Materialized-"><code>StreamsBuilder.table(String, Materialized)</code></a>)</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>keySerde</code> - key serde used to send key-value pairs,
                  if not specified the default key serde defined in the configuration will be used</dd>
<dd><code>valSerde</code> - value serde used to send key-value pairs,
                  if not specified the default value serde defined in the configuration will be used</dd>
<dd><code>topic</code> - the topic name</dd>
<dd><code>storeSupplier</code> - user defined state store supplier. Cannot be <code>null</code>.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a <code>KTable</code> that contains the exact same (and potentially repartitioned) records as this <code>KTable</code></dd>
</dl>
</li>
</ul>
<a name="through-org.apache.kafka.common.serialization.Serde-org.apache.kafka.common.serialization.Serde-java.lang.String-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>through</h4>
<pre>@Deprecated
<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>&gt;&nbsp;through(<a href="../../../../../org/apache/kafka/common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization">Serde</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>&gt;&nbsp;keySerde,
                                <a href="../../../../../org/apache/kafka/common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization">Serde</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>&gt;&nbsp;valSerde,
                                java.lang.String&nbsp;topic)</pre>
<div class="block"><span class="deprecatedLabel">Deprecated.</span>&nbsp;<span class="deprecationComment">use <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#toStream--"><code>toStream()</code></a> followed by
 <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#to-java.lang.String-org.apache.kafka.streams.kstream.Produced-"><code>to(topic, Produced.with(keySerde, valSerde))</code></a>
 and <a href="../../../../../org/apache/kafka/streams/StreamsBuilder.html#table-java.lang.String-"><code>StreamsBuilder#table(topic)</code></a> to read back as a <code>KTable</code></span></div>
<div class="block">Materialize this changelog stream to a topic and creates a new <code>KTable</code> from the topic.
 The specified topic should be manually created before it is used (i.e., before the Kafka Streams application is
 started).
 <p>
 If <code>keySerde</code> provides a <code>WindowedSerializer</code> for the key <code>WindowedStreamPartitioner</code> is
 used&mdash;otherwise producer's <code>DefaultPartitioner</code> is used.
 <p>
 This is equivalent to calling <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#to-org.apache.kafka.common.serialization.Serde-org.apache.kafka.common.serialization.Serde-java.lang.String-"><code>#to(keySerde, valueSerde, someTopicName)</code></a> and
 <a href="../../../../../org/apache/kafka/streams/kstream/KStreamBuilder.html#table-java.lang.String-"><code>KStreamBuilder#table(someTopicName)</code></a>.
 <p>
 The resulting <code>KTable</code> will be materialized in a local state store with an interna; store name (cf.
 <a href="../../../../../org/apache/kafka/streams/kstream/KStreamBuilder.html#table-java.lang.String-"><code>KStreamBuilder.table(String)</code></a>)</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>keySerde</code> - key serde used to send key-value pairs,
                  if not specified the default key serde defined in the configuration will be used</dd>
<dd><code>valSerde</code> - value serde used to send key-value pairs,
                  if not specified the default value serde defined in the configuration will be used</dd>
<dd><code>topic</code> - the topic name</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a <code>KTable</code> that contains the exact same (and potentially repartitioned) records as this <code>KTable</code></dd>
</dl>
</li>
</ul>
<a name="through-org.apache.kafka.common.serialization.Serde-org.apache.kafka.common.serialization.Serde-org.apache.kafka.streams.processor.StreamPartitioner-java.lang.String-java.lang.String-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>through</h4>
<pre>@Deprecated
<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>&gt;&nbsp;through(<a href="../../../../../org/apache/kafka/common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization">Serde</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>&gt;&nbsp;keySerde,
                                <a href="../../../../../org/apache/kafka/common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization">Serde</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>&gt;&nbsp;valSerde,
                                <a href="../../../../../org/apache/kafka/streams/processor/StreamPartitioner.html" title="interface in org.apache.kafka.streams.processor">StreamPartitioner</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,? super <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>&gt;&nbsp;partitioner,
                                java.lang.String&nbsp;topic,
                                java.lang.String&nbsp;queryableStoreName)</pre>
<div class="block"><span class="deprecatedLabel">Deprecated.</span>&nbsp;<span class="deprecationComment">use <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#toStream--"><code>toStream()</code></a> followed by
 <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#to-java.lang.String-org.apache.kafka.streams.kstream.Produced-"><code>to(topic, Produced.with(keySerde, valSerde, partitioner))</code></a> and
 <a href="../../../../../org/apache/kafka/streams/StreamsBuilder.html#table-java.lang.String-org.apache.kafka.streams.kstream.Materialized-"><code>StreamsBuilder#table(topic, Materialized.as(queryableStoreName))</code></a>
 to read back as a <code>KTable</code></span></div>
<div class="block">Materialize this changelog stream to a topic and creates a new <code>KTable</code> from the topic using a customizable
 <a href="../../../../../org/apache/kafka/streams/processor/StreamPartitioner.html" title="interface in org.apache.kafka.streams.processor"><code>StreamPartitioner</code></a> to determine the distribution of records to partitions.
 The specified topic should be manually created before it is used (i.e., before the Kafka Streams application is
 started).
 <p>
 This is equivalent to calling <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#to-org.apache.kafka.common.serialization.Serde-org.apache.kafka.common.serialization.Serde-org.apache.kafka.streams.processor.StreamPartitioner-java.lang.String-"><code>#to(keySerde, valueSerde, partitioner, someTopicName)</code></a> and
 <a href="../../../../../org/apache/kafka/streams/kstream/KStreamBuilder.html#table-java.lang.String-java.lang.String-"><code>KStreamBuilder#table(someTopicName, queryableStoreName)</code></a>.
 <p>
 The resulting <code>KTable</code> will be materialized in a local state store with the given store name (cf.
 <a href="../../../../../org/apache/kafka/streams/kstream/KStreamBuilder.html#table-java.lang.String-java.lang.String-"><code>KStreamBuilder.table(String, String)</code></a>)</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>keySerde</code> - key serde used to send key-value pairs,
                    if not specified the default key serde defined in the configuration will be used</dd>
<dd><code>valSerde</code> - value serde used to send key-value pairs,
                    if not specified the default value serde defined in the configuration will be used</dd>
<dd><code>partitioner</code> - the function used to determine how records are distributed among partitions of the topic,
                    if not specified and <code>keySerde</code> provides a <code>WindowedSerializer</code> for the key
                    <code>WindowedStreamPartitioner</code> will be used&mdash;otherwise <code>DefaultPartitioner</code> will
                    be used</dd>
<dd><code>topic</code> - the topic name</dd>
<dd><code>queryableStoreName</code> - the state store name used for the result <code>KTable</code>.
                            If <code>null</code> this is the equivalent of <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#through-org.apache.kafka.common.serialization.Serde-org.apache.kafka.common.serialization.Serde-org.apache.kafka.streams.processor.StreamPartitioner-java.lang.String-"><code>through(Serde, Serde, StreamPartitioner, String)()</code></a></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a <code>KTable</code> that contains the exact same (and potentially repartitioned) records as this <code>KTable</code></dd>
</dl>
</li>
</ul>
<a name="through-org.apache.kafka.common.serialization.Serde-org.apache.kafka.common.serialization.Serde-org.apache.kafka.streams.processor.StreamPartitioner-java.lang.String-org.apache.kafka.streams.processor.StateStoreSupplier-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>through</h4>
<pre>@Deprecated
<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>&gt;&nbsp;through(<a href="../../../../../org/apache/kafka/common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization">Serde</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>&gt;&nbsp;keySerde,
                                <a href="../../../../../org/apache/kafka/common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization">Serde</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>&gt;&nbsp;valSerde,
                                <a href="../../../../../org/apache/kafka/streams/processor/StreamPartitioner.html" title="interface in org.apache.kafka.streams.processor">StreamPartitioner</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,? super <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>&gt;&nbsp;partitioner,
                                java.lang.String&nbsp;topic,
                                <a href="../../../../../org/apache/kafka/streams/processor/StateStoreSupplier.html" title="interface in org.apache.kafka.streams.processor">StateStoreSupplier</a>&lt;<a href="../../../../../org/apache/kafka/streams/state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state">KeyValueStore</a>&gt;&nbsp;storeSupplier)</pre>
<div class="block"><span class="deprecatedLabel">Deprecated.</span>&nbsp;<span class="deprecationComment">use <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#toStream--"><code>toStream()</code></a> followed by
 <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#to-java.lang.String-org.apache.kafka.streams.kstream.Produced-"><code>to(topic, Produced.with(keySerde, valSerde, partitioner))</code></a> and
 <a href="../../../../../org/apache/kafka/streams/StreamsBuilder.html#table-java.lang.String-org.apache.kafka.streams.kstream.Materialized-"><code>StreamsBuilder#table(topic, Materialized.as(KeyValueBytesStoreSupplier))</code></a>
 to read back as a <code>KTable</code></span></div>
<div class="block">Materialize this changelog stream to a topic and creates a new <code>KTable</code> from the topic using a customizable
 <a href="../../../../../org/apache/kafka/streams/processor/StreamPartitioner.html" title="interface in org.apache.kafka.streams.processor"><code>StreamPartitioner</code></a> to determine the distribution of records to partitions.
 The specified topic should be manually created before it is used (i.e., before the Kafka Streams application is
 started).
 <p>
 This is equivalent to calling <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#to-org.apache.kafka.common.serialization.Serde-org.apache.kafka.common.serialization.Serde-org.apache.kafka.streams.processor.StreamPartitioner-java.lang.String-"><code>#to(keySerde, valueSerde, partitioner, someTopicName)</code></a> and
 <a href="../../../../../org/apache/kafka/streams/kstream/KStreamBuilder.html#table-java.lang.String-java.lang.String-"><code>KStreamBuilder#table(someTopicName, queryableStoreName)</code></a>.
 <p>
 The resulting <code>KTable</code> will be materialized in a local state store with the given store name (cf.
 <a href="../../../../../org/apache/kafka/streams/kstream/KStreamBuilder.html#table-java.lang.String-java.lang.String-"><code>KStreamBuilder.table(String, String)</code></a>)</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>keySerde</code> - key serde used to send key-value pairs,
                    if not specified the default key serde defined in the configuration will be used</dd>
<dd><code>valSerde</code> - value serde used to send key-value pairs,
                    if not specified the default value serde defined in the configuration will be used</dd>
<dd><code>partitioner</code> - the function used to determine how records are distributed among partitions of the topic,
                    if not specified and <code>keySerde</code> provides a <code>WindowedSerializer</code> for the key
                    <code>WindowedStreamPartitioner</code> will be used&mdash;otherwise <code>DefaultPartitioner</code> will
                    be used</dd>
<dd><code>topic</code> - the topic name</dd>
<dd><code>storeSupplier</code> - user defined state store supplier. Cannot be <code>null</code>.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a <code>KTable</code> that contains the exact same (and potentially repartitioned) records as this <code>KTable</code></dd>
</dl>
</li>
</ul>
<a name="through-org.apache.kafka.common.serialization.Serde-org.apache.kafka.common.serialization.Serde-org.apache.kafka.streams.processor.StreamPartitioner-java.lang.String-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>through</h4>
<pre>@Deprecated
<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>&gt;&nbsp;through(<a href="../../../../../org/apache/kafka/common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization">Serde</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>&gt;&nbsp;keySerde,
                                <a href="../../../../../org/apache/kafka/common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization">Serde</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>&gt;&nbsp;valSerde,
                                <a href="../../../../../org/apache/kafka/streams/processor/StreamPartitioner.html" title="interface in org.apache.kafka.streams.processor">StreamPartitioner</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,? super <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>&gt;&nbsp;partitioner,
                                java.lang.String&nbsp;topic)</pre>
<div class="block"><span class="deprecatedLabel">Deprecated.</span>&nbsp;<span class="deprecationComment">use <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#toStream--"><code>toStream()</code></a> followed by
 <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#to-java.lang.String-org.apache.kafka.streams.kstream.Produced-"><code>to(topic, Produced.with(keySerde, valSerde, partitioner))</code></a> and
 <a href="../../../../../org/apache/kafka/streams/StreamsBuilder.html#table-java.lang.String-"><code>StreamsBuilder#table(topic)</code></a> to read back as a <code>KTable</code></span></div>
<div class="block">Materialize this changelog stream to a topic and creates a new <code>KTable</code> from the topic using a customizable
 <a href="../../../../../org/apache/kafka/streams/processor/StreamPartitioner.html" title="interface in org.apache.kafka.streams.processor"><code>StreamPartitioner</code></a> to determine the distribution of records to partitions.
 The specified topic should be manually created before it is used (i.e., before the Kafka Streams application is
 started).
 <p>
 This is equivalent to calling <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#to-org.apache.kafka.common.serialization.Serde-org.apache.kafka.common.serialization.Serde-org.apache.kafka.streams.processor.StreamPartitioner-java.lang.String-"><code>#to(keySerde, valueSerde, partitioner, someTopicName)</code></a> and
 <a href="../../../../../org/apache/kafka/streams/kstream/KStreamBuilder.html#table-java.lang.String-"><code>KStreamBuilder#table(someTopicName)</code></a>.
 <p>
 The resulting <code>KTable</code> will be materialized in a local state store with an internal store name (cf.
 <a href="../../../../../org/apache/kafka/streams/kstream/KStreamBuilder.html#table-java.lang.String-"><code>KStreamBuilder.table(String)</code></a>)</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>keySerde</code> - key serde used to send key-value pairs,
                    if not specified the default key serde defined in the configuration will be used</dd>
<dd><code>valSerde</code> - value serde used to send key-value pairs,
                    if not specified the default value serde defined in the configuration will be used</dd>
<dd><code>partitioner</code> - the function used to determine how records are distributed among partitions of the topic,
                    if not specified and <code>keySerde</code> provides a <code>WindowedSerializer</code> for the key
                    <code>WindowedStreamPartitioner</code> will be used&mdash;otherwise <code>DefaultPartitioner</code> will
                    be used</dd>
<dd><code>topic</code> - the topic name</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a <code>KTable</code> that contains the exact same (and potentially repartitioned) records as this <code>KTable</code></dd>
</dl>
</li>
</ul>
<a name="to-java.lang.String-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>to</h4>
<pre>@Deprecated
void&nbsp;to(java.lang.String&nbsp;topic)</pre>
<div class="block"><span class="deprecatedLabel">Deprecated.</span>&nbsp;<span class="deprecationComment">use <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#toStream--"><code>toStream()</code></a> followed by <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#to-java.lang.String-"><code>to(topic)</code></a></span></div>
<div class="block">Materialize this changelog stream to a topic using default serializers and deserializers and producer's
 <code>DefaultPartitioner</code>.
 The specified topic should be manually created before it is used (i.e., before the Kafka Streams application is
 started).</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>topic</code> - the topic name</dd>
</dl>
</li>
</ul>
<a name="to-org.apache.kafka.streams.processor.StreamPartitioner-java.lang.String-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>to</h4>
<pre>@Deprecated
void&nbsp;to(<a href="../../../../../org/apache/kafka/streams/processor/StreamPartitioner.html" title="interface in org.apache.kafka.streams.processor">StreamPartitioner</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,? super <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>&gt;&nbsp;partitioner,
                    java.lang.String&nbsp;topic)</pre>
<div class="block"><span class="deprecatedLabel">Deprecated.</span>&nbsp;<span class="deprecationComment">use <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#toStream--"><code>toStream()</code></a> followed by
 <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#to-java.lang.String-org.apache.kafka.streams.kstream.Produced-"><code>to(topic, Produced.withStreamPartitioner(partitioner)</code></a></span></div>
<div class="block">Materialize this changelog stream to a topic using default serializers and deserializers and a customizable
 <a href="../../../../../org/apache/kafka/streams/processor/StreamPartitioner.html" title="interface in org.apache.kafka.streams.processor"><code>StreamPartitioner</code></a> to determine the distribution of records to partitions.
 The specified topic should be manually created before it is used (i.e., before the Kafka Streams application is
 started).</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>partitioner</code> - the function used to determine how records are distributed among partitions of the topic,
                    if not specified producer's <code>DefaultPartitioner</code> will be used</dd>
<dd><code>topic</code> - the topic name</dd>
</dl>
</li>
</ul>
<a name="to-org.apache.kafka.common.serialization.Serde-org.apache.kafka.common.serialization.Serde-java.lang.String-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>to</h4>
<pre>@Deprecated
void&nbsp;to(<a href="../../../../../org/apache/kafka/common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization">Serde</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>&gt;&nbsp;keySerde,
                    <a href="../../../../../org/apache/kafka/common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization">Serde</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>&gt;&nbsp;valSerde,
                    java.lang.String&nbsp;topic)</pre>
<div class="block"><span class="deprecatedLabel">Deprecated.</span>&nbsp;<span class="deprecationComment">use <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#toStream--"><code>toStream()</code></a> followed by
 <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#to-java.lang.String-org.apache.kafka.streams.kstream.Produced-"><code>to(topic, Produced.with(keySerde, valSerde)</code></a></span></div>
<div class="block">Materialize this changelog stream to a topic.
 The specified topic should be manually created before it is used (i.e., before the Kafka Streams application is
 started).
 <p>
 If <code>keySerde</code> provides a <code>WindowedSerializer</code> for the key <code>WindowedStreamPartitioner</code> is
 used&mdash;otherwise producer's <code>DefaultPartitioner</code> is used.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>keySerde</code> - key serde used to send key-value pairs,
                 if not specified the default key serde defined in the configuration will be used</dd>
<dd><code>valSerde</code> - value serde used to send key-value pairs,
                 if not specified the default value serde defined in the configuration will be used</dd>
<dd><code>topic</code> - the topic name</dd>
</dl>
</li>
</ul>
<a name="to-org.apache.kafka.common.serialization.Serde-org.apache.kafka.common.serialization.Serde-org.apache.kafka.streams.processor.StreamPartitioner-java.lang.String-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>to</h4>
<pre>@Deprecated
void&nbsp;to(<a href="../../../../../org/apache/kafka/common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization">Serde</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>&gt;&nbsp;keySerde,
                    <a href="../../../../../org/apache/kafka/common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization">Serde</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>&gt;&nbsp;valSerde,
                    <a href="../../../../../org/apache/kafka/streams/processor/StreamPartitioner.html" title="interface in org.apache.kafka.streams.processor">StreamPartitioner</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,? super <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>&gt;&nbsp;partitioner,
                    java.lang.String&nbsp;topic)</pre>
<div class="block"><span class="deprecatedLabel">Deprecated.</span>&nbsp;<span class="deprecationComment">use <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#toStream--"><code>toStream()</code></a> followed by
 <a href="../../../../../org/apache/kafka/streams/kstream/KStream.html#to-java.lang.String-org.apache.kafka.streams.kstream.Produced-"><code>to(topic, Produced.with(keySerde, valSerde, partioner)</code></a></span></div>
<div class="block">Materialize this changelog stream to a topic using a customizable <a href="../../../../../org/apache/kafka/streams/processor/StreamPartitioner.html" title="interface in org.apache.kafka.streams.processor"><code>StreamPartitioner</code></a> to determine the
 distribution of records to partitions.
 The specified topic should be manually created before it is used (i.e., before the Kafka Streams application is
 started).</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>keySerde</code> - key serde used to send key-value pairs,
                    if not specified the default key serde defined in the configuration will be used</dd>
<dd><code>valSerde</code> - value serde used to send key-value pairs,
                    if not specified the default value serde defined in the configuration will be used</dd>
<dd><code>partitioner</code> - the function used to determine how records are distributed among partitions of the topic,
                    if not specified and <code>keySerde</code> provides a <code>WindowedSerializer</code> for the key
                    <code>WindowedStreamPartitioner</code> will be used&mdash;otherwise <code>DefaultPartitioner</code> will
                    be used</dd>
<dd><code>topic</code> - the topic name</dd>
</dl>
</li>
</ul>
<a name="groupBy-org.apache.kafka.streams.kstream.KeyValueMapper-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>groupBy</h4>
<pre>&lt;KR,VR&gt;&nbsp;<a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html" title="interface in org.apache.kafka.streams.kstream">KGroupedTable</a>&lt;KR,VR&gt;&nbsp;groupBy(<a href="../../../../../org/apache/kafka/streams/kstream/KeyValueMapper.html" title="interface in org.apache.kafka.streams.kstream">KeyValueMapper</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,? super <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>,<a href="../../../../../org/apache/kafka/streams/KeyValue.html" title="class in org.apache.kafka.streams">KeyValue</a>&lt;KR,VR&gt;&gt;&nbsp;selector)</pre>
<div class="block">Re-groups the records of this <code>KTable</code> using the provided <a href="../../../../../org/apache/kafka/streams/kstream/KeyValueMapper.html" title="interface in org.apache.kafka.streams.kstream"><code>KeyValueMapper</code></a> and default serializers
 and deserializers.
 Each <a href="../../../../../org/apache/kafka/streams/KeyValue.html" title="class in org.apache.kafka.streams"><code>KeyValue</code></a> pair of this <code>KTable</code> is mapped to a new <a href="../../../../../org/apache/kafka/streams/KeyValue.html" title="class in org.apache.kafka.streams"><code>KeyValue</code></a> pair by applying the
 provided <a href="../../../../../org/apache/kafka/streams/kstream/KeyValueMapper.html" title="interface in org.apache.kafka.streams.kstream"><code>KeyValueMapper</code></a>.
 Re-grouping a <code>KTable</code> is required before an aggregation operator can be applied to the data
 (cf. <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KGroupedTable</code></a>).
 The <a href="../../../../../org/apache/kafka/streams/kstream/KeyValueMapper.html" title="interface in org.apache.kafka.streams.kstream"><code>KeyValueMapper</code></a> selects a new key and value (with should both have unmodified type).
 If the new record key is <code>null</code> the record will not be included in the resulting <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KGroupedTable</code></a>
 <p>
 Because a new key is selected, an internal repartitioning topic will be created in Kafka.
 This topic will be named "${applicationId}-XXX-repartition", where "applicationId" is user-specified in
 <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html" title="class in org.apache.kafka.streams"><code>StreamsConfig</code></a> via parameter <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html#APPLICATION_ID_CONFIG"><code>APPLICATION_ID_CONFIG</code></a>, "XXX" is
 an internally generated name, and "-repartition" is a fixed suffix.
 You can retrieve all generated internal topic names via <a href="../../../../../org/apache/kafka/streams/KafkaStreams.html#toString--"><code>KafkaStreams.toString()</code></a>.
 <p>
 All data of this <code>KTable</code> will be redistributed through the repartitioning topic by writing all update
 records to and rereading all update records from it, such that the resulting <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KGroupedTable</code></a> is partitioned
 on the new key.
 <p>
 If the key or value type is changed, it is recommended to use <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#groupBy-org.apache.kafka.streams.kstream.KeyValueMapper-org.apache.kafka.streams.kstream.Serialized-"><code>groupBy(KeyValueMapper, Serialized)</code></a>
 instead.</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>KR</code> - the key type of the result <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KGroupedTable</code></a></dd>
<dd><code>VR</code> - the value type of the result <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KGroupedTable</code></a></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>selector</code> - a <a href="../../../../../org/apache/kafka/streams/kstream/KeyValueMapper.html" title="interface in org.apache.kafka.streams.kstream"><code>KeyValueMapper</code></a> that computes a new grouping key and value to be aggregated</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KGroupedTable</code></a> that contains the re-grouped records of the original <code>KTable</code></dd>
</dl>
</li>
</ul>
<a name="groupBy-org.apache.kafka.streams.kstream.KeyValueMapper-org.apache.kafka.streams.kstream.Serialized-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>groupBy</h4>
<pre>&lt;KR,VR&gt;&nbsp;<a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html" title="interface in org.apache.kafka.streams.kstream">KGroupedTable</a>&lt;KR,VR&gt;&nbsp;groupBy(<a href="../../../../../org/apache/kafka/streams/kstream/KeyValueMapper.html" title="interface in org.apache.kafka.streams.kstream">KeyValueMapper</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,? super <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>,<a href="../../../../../org/apache/kafka/streams/KeyValue.html" title="class in org.apache.kafka.streams">KeyValue</a>&lt;KR,VR&gt;&gt;&nbsp;selector,
                                     <a href="../../../../../org/apache/kafka/streams/kstream/Serialized.html" title="class in org.apache.kafka.streams.kstream">Serialized</a>&lt;KR,VR&gt;&nbsp;serialized)</pre>
<div class="block">Re-groups the records of this <code>KTable</code> using the provided <a href="../../../../../org/apache/kafka/streams/kstream/KeyValueMapper.html" title="interface in org.apache.kafka.streams.kstream"><code>KeyValueMapper</code></a>
 and <a href="../../../../../org/apache/kafka/common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization"><code>Serde</code></a>s as specified by <a href="../../../../../org/apache/kafka/streams/kstream/Serialized.html" title="class in org.apache.kafka.streams.kstream"><code>Serialized</code></a>.
 Each <a href="../../../../../org/apache/kafka/streams/KeyValue.html" title="class in org.apache.kafka.streams"><code>KeyValue</code></a> pair of this <code>KTable</code> is mapped to a new <a href="../../../../../org/apache/kafka/streams/KeyValue.html" title="class in org.apache.kafka.streams"><code>KeyValue</code></a> pair by applying the
 provided <a href="../../../../../org/apache/kafka/streams/kstream/KeyValueMapper.html" title="interface in org.apache.kafka.streams.kstream"><code>KeyValueMapper</code></a>.
 Re-grouping a <code>KTable</code> is required before an aggregation operator can be applied to the data
 (cf. <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KGroupedTable</code></a>).
 The <a href="../../../../../org/apache/kafka/streams/kstream/KeyValueMapper.html" title="interface in org.apache.kafka.streams.kstream"><code>KeyValueMapper</code></a> selects a new key and value (with should both have unmodified type).
 If the new record key is <code>null</code> the record will not be included in the resulting <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KGroupedTable</code></a>
 <p>
 Because a new key is selected, an internal repartitioning topic will be created in Kafka.
 This topic will be named "${applicationId}-XXX-repartition", where "applicationId" is user-specified in
 <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html" title="class in org.apache.kafka.streams"><code>StreamsConfig</code></a> via parameter <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html#APPLICATION_ID_CONFIG"><code>APPLICATION_ID_CONFIG</code></a>, "XXX" is
 an internally generated name, and "-repartition" is a fixed suffix.
 You can retrieve all generated internal topic names via <a href="../../../../../org/apache/kafka/streams/KafkaStreams.html#toString--"><code>KafkaStreams.toString()</code></a>.
 <p>
 All data of this <code>KTable</code> will be redistributed through the repartitioning topic by writing all update
 records to and rereading all update records from it, such that the resulting <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KGroupedTable</code></a> is partitioned
 on the new key.</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>KR</code> - the key type of the result <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KGroupedTable</code></a></dd>
<dd><code>VR</code> - the value type of the result <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KGroupedTable</code></a></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>selector</code> - a <a href="../../../../../org/apache/kafka/streams/kstream/KeyValueMapper.html" title="interface in org.apache.kafka.streams.kstream"><code>KeyValueMapper</code></a> that computes a new grouping key and value to be aggregated</dd>
<dd><code>serialized</code> - the <a href="../../../../../org/apache/kafka/streams/kstream/Serialized.html" title="class in org.apache.kafka.streams.kstream"><code>Serialized</code></a> instance used to specify <a href="../../../../../org/apache/kafka/common/serialization/Serdes.html" title="class in org.apache.kafka.common.serialization"><code>Serdes</code></a></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KGroupedTable</code></a> that contains the re-grouped records of the original <code>KTable</code></dd>
</dl>
</li>
</ul>
<a name="groupBy-org.apache.kafka.streams.kstream.KeyValueMapper-org.apache.kafka.common.serialization.Serde-org.apache.kafka.common.serialization.Serde-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>groupBy</h4>
<pre>@Deprecated
&lt;KR,VR&gt;&nbsp;<a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html" title="interface in org.apache.kafka.streams.kstream">KGroupedTable</a>&lt;KR,VR&gt;&nbsp;groupBy(<a href="../../../../../org/apache/kafka/streams/kstream/KeyValueMapper.html" title="interface in org.apache.kafka.streams.kstream">KeyValueMapper</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,? super <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>,<a href="../../../../../org/apache/kafka/streams/KeyValue.html" title="class in org.apache.kafka.streams">KeyValue</a>&lt;KR,VR&gt;&gt;&nbsp;selector,
                                                 <a href="../../../../../org/apache/kafka/common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization">Serde</a>&lt;KR&gt;&nbsp;keySerde,
                                                 <a href="../../../../../org/apache/kafka/common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization">Serde</a>&lt;VR&gt;&nbsp;valueSerde)</pre>
<div class="block"><span class="deprecatedLabel">Deprecated.</span>&nbsp;<span class="deprecationComment">use <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#groupBy-org.apache.kafka.streams.kstream.KeyValueMapper-org.apache.kafka.streams.kstream.Serialized-"><code>groupBy(selector, Serialized.with(keySerde, valueSerde)</code></a></span></div>
<div class="block">Re-groups the records of this <code>KTable</code> using the provided <a href="../../../../../org/apache/kafka/streams/kstream/KeyValueMapper.html" title="interface in org.apache.kafka.streams.kstream"><code>KeyValueMapper</code></a>.
 Each <a href="../../../../../org/apache/kafka/streams/KeyValue.html" title="class in org.apache.kafka.streams"><code>KeyValue</code></a> pair of this <code>KTable</code> is mapped to a new <a href="../../../../../org/apache/kafka/streams/KeyValue.html" title="class in org.apache.kafka.streams"><code>KeyValue</code></a> pair by applying the
 provided <a href="../../../../../org/apache/kafka/streams/kstream/KeyValueMapper.html" title="interface in org.apache.kafka.streams.kstream"><code>KeyValueMapper</code></a>.
 Re-grouping a <code>KTable</code> is required before an aggregation operator can be applied to the data
 (cf. <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KGroupedTable</code></a>).
 The <a href="../../../../../org/apache/kafka/streams/kstream/KeyValueMapper.html" title="interface in org.apache.kafka.streams.kstream"><code>KeyValueMapper</code></a> selects a new key and value (both with potentially different type).
 If the new record key is <code>null</code> the record will not be included in the resulting <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KGroupedTable</code></a>
 <p>
 Because a new key is selected, an internal repartitioning topic will be created in Kafka.
 This topic will be named "${applicationId}-XXX-repartition", where "applicationId" is user-specified in
 <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html" title="class in org.apache.kafka.streams"><code>StreamsConfig</code></a> via parameter <a href="../../../../../org/apache/kafka/streams/StreamsConfig.html#APPLICATION_ID_CONFIG"><code>APPLICATION_ID_CONFIG</code></a>, "XXX" is
 an internally generated name, and "-repartition" is a fixed suffix.
 You can retrieve all generated internal topic names via <a href="../../../../../org/apache/kafka/streams/KafkaStreams.html#toString--"><code>KafkaStreams.toString()</code></a>.
 <p>
 All data of this <code>KTable</code> will be redistributed through the repartitioning topic by writing all update
 records to and rereading all update records from it, such that the resulting <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KGroupedTable</code></a> is partitioned
 on the new key.</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>KR</code> - the key type of the result <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KGroupedTable</code></a></dd>
<dd><code>VR</code> - the value type of the result <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KGroupedTable</code></a></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>selector</code> - a <a href="../../../../../org/apache/kafka/streams/kstream/KeyValueMapper.html" title="interface in org.apache.kafka.streams.kstream"><code>KeyValueMapper</code></a> that computes a new grouping key and value to be aggregated</dd>
<dd><code>keySerde</code> - key serdes for materializing this stream,
                   if not specified the default serdes defined in the configs will be used</dd>
<dd><code>valueSerde</code> - value serdes for materializing this stream,
                   if not specified the default serdes defined in the configs will be used</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a <a href="../../../../../org/apache/kafka/streams/kstream/KGroupedTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KGroupedTable</code></a> that contains the re-grouped records of the original <code>KTable</code></dd>
</dl>
</li>
</ul>
<a name="join-org.apache.kafka.streams.kstream.KTable-org.apache.kafka.streams.kstream.ValueJoiner-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>join</h4>
<pre>&lt;VO,VR&gt;&nbsp;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,VR&gt;&nbsp;join(<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,VO&gt;&nbsp;other,
                          <a href="../../../../../org/apache/kafka/streams/kstream/ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream">ValueJoiner</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>,? super VO,? extends VR&gt;&nbsp;joiner)</pre>
<div class="block">Join records of this <code>KTable</code> with another <code>KTable</code>'s records using non-windowed inner equi join.
 The join is a primary key join with join attribute <code>thisKTable.key == otherKTable.key</code>.
 The result is an ever updating <code>KTable</code> that represents the <em>current</em> (i.e., processing time) result
 of the join.
 <p>
 The join is computed by (1) updating the internal state of one <code>KTable</code> and (2) performing a lookup for a
 matching record in the <em>current</em> (i.e., processing time) internal state of the other <code>KTable</code>.
 This happens in a symmetric way, i.e., for each update of either <code>this</code> or the <code>other</code> input
 <code>KTable</code> the result gets updated.
 <p>
 For each <code>KTable</code> record that finds a corresponding record in the other <code>KTable</code> the provided
 <a href="../../../../../org/apache/kafka/streams/kstream/ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueJoiner</code></a> will be called to compute a value (with arbitrary type) for the result record.
 The key of the result record is the same as for both joining input records.
 <p>
 Note that <a href="../../../../../org/apache/kafka/streams/KeyValue.html" title="class in org.apache.kafka.streams"><code>records</code></a> with <code>null</code> values (so-called tombstone records) have delete semantics.
 Thus, for input tombstones the provided value-joiner is not called but a tombstone record is forwarded
 directly to delete a record in the result <code>KTable</code> if required (i.e., if there is anything to be deleted).
 <p>
 Input records with <code>null</code> key will be dropped and no join computation is performed.
 <p>
 Example:
 <table border='1'>
 <tr>
 <th>thisKTable</th>
 <th>thisState</th>
 <th>otherKTable</th>
 <th>otherState</th>
 <th>result update record</th>
 </tr>
 <tr>
 <td>&lt;K1:A&gt;</td>
 <td>&lt;K1:A&gt;</td>
 <td></td>
 <td></td>
 <td></td>
 </tr>
 <tr>
 <td></td>
 <td>&lt;K1:A&gt;</td>
 <td>&lt;K1:b&gt;</td>
 <td>&lt;K1:b&gt;</td>
 <td>&lt;K1:ValueJoiner(A,b)&gt;</td>
 </tr>
 <tr>
 <td>&lt;K1:C&gt;</td>
 <td>&lt;K1:C&gt;</td>
 <td></td>
 <td>&lt;K1:b&gt;</td>
 <td>&lt;K1:ValueJoiner(C,b)&gt;</td>
 </tr>
 <tr>
 <td></td>
 <td>&lt;K1:C&gt;</td>
 <td>&lt;K1:null&gt;</td>
 <td></td>
 <td>&lt;K1:null&gt;</td>
 </tr>
 </table>
 Both input streams (or to be more precise, their underlying source topics) need to have the same number of
 partitions.</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>VO</code> - the value type of the other <code>KTable</code></dd>
<dd><code>VR</code> - the value type of the result <code>KTable</code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>other</code> - the other <code>KTable</code> to be joined with this <code>KTable</code></dd>
<dd><code>joiner</code> - a <a href="../../../../../org/apache/kafka/streams/kstream/ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueJoiner</code></a> that computes the join result for a pair of matching records</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a <code>KTable</code> that contains join-records for each key and values computed by the given
 <a href="../../../../../org/apache/kafka/streams/kstream/ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueJoiner</code></a>, one for each matched record-pair with the same key</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#leftJoin-org.apache.kafka.streams.kstream.KTable-org.apache.kafka.streams.kstream.ValueJoiner-"><code>leftJoin(KTable, ValueJoiner)</code></a>, 
<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#outerJoin-org.apache.kafka.streams.kstream.KTable-org.apache.kafka.streams.kstream.ValueJoiner-"><code>outerJoin(KTable, ValueJoiner)</code></a></dd>
</dl>
</li>
</ul>
<a name="join-org.apache.kafka.streams.kstream.KTable-org.apache.kafka.streams.kstream.ValueJoiner-org.apache.kafka.streams.kstream.Materialized-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>join</h4>
<pre>&lt;VO,VR&gt;&nbsp;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,VR&gt;&nbsp;join(<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,VO&gt;&nbsp;other,
                          <a href="../../../../../org/apache/kafka/streams/kstream/ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream">ValueJoiner</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>,? super VO,? extends VR&gt;&nbsp;joiner,
                          <a href="../../../../../org/apache/kafka/streams/kstream/Materialized.html" title="class in org.apache.kafka.streams.kstream">Materialized</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,VR,<a href="../../../../../org/apache/kafka/streams/state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state">KeyValueStore</a>&lt;org.apache.kafka.common.utils.Bytes,byte[]&gt;&gt;&nbsp;materialized)</pre>
<div class="block">Join records of this <code>KTable</code> with another <code>KTable</code>'s records using non-windowed inner equi join.
 The join is a primary key join with join attribute <code>thisKTable.key == otherKTable.key</code>.
 The result is an ever updating <code>KTable</code> that represents the <em>current</em> (i.e., processing time) result
 of the join.
 <p>
 The join is computed by (1) updating the internal state of one <code>KTable</code> and (2) performing a lookup for a
 matching record in the <em>current</em> (i.e., processing time) internal state of the other <code>KTable</code>.
 This happens in a symmetric way, i.e., for each update of either <code>this</code> or the <code>other</code> input
 <code>KTable</code> the result gets updated.
 <p>
 For each <code>KTable</code> record that finds a corresponding record in the other <code>KTable</code> the provided
 <a href="../../../../../org/apache/kafka/streams/kstream/ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueJoiner</code></a> will be called to compute a value (with arbitrary type) for the result record.
 The key of the result record is the same as for both joining input records.
 <p>
 Note that <a href="../../../../../org/apache/kafka/streams/KeyValue.html" title="class in org.apache.kafka.streams"><code>records</code></a> with <code>null</code> values (so-called tombstone records) have delete semantics.
 Thus, for input tombstones the provided value-joiner is not called but a tombstone record is forwarded
 directly to delete a record in the result <code>KTable</code> if required (i.e., if there is anything to be deleted).
 <p>
 Input records with <code>null</code> key will be dropped and no join computation is performed.
 <p>
 Example:
 <table border='1'>
 <tr>
 <th>thisKTable</th>
 <th>thisState</th>
 <th>otherKTable</th>
 <th>otherState</th>
 <th>result update record</th>
 </tr>
 <tr>
 <td>&lt;K1:A&gt;</td>
 <td>&lt;K1:A&gt;</td>
 <td></td>
 <td></td>
 <td></td>
 </tr>
 <tr>
 <td></td>
 <td>&lt;K1:A&gt;</td>
 <td>&lt;K1:b&gt;</td>
 <td>&lt;K1:b&gt;</td>
 <td>&lt;K1:ValueJoiner(A,b)&gt;</td>
 </tr>
 <tr>
 <td>&lt;K1:C&gt;</td>
 <td>&lt;K1:C&gt;</td>
 <td></td>
 <td>&lt;K1:b&gt;</td>
 <td>&lt;K1:ValueJoiner(C,b)&gt;</td>
 </tr>
 <tr>
 <td></td>
 <td>&lt;K1:C&gt;</td>
 <td>&lt;K1:null&gt;</td>
 <td></td>
 <td>&lt;K1:null&gt;</td>
 </tr>
 </table>
 Both input streams (or to be more precise, their underlying source topics) need to have the same number of
 partitions.</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>VO</code> - the value type of the other <code>KTable</code></dd>
<dd><code>VR</code> - the value type of the result <code>KTable</code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>other</code> - the other <code>KTable</code> to be joined with this <code>KTable</code></dd>
<dd><code>joiner</code> - a <a href="../../../../../org/apache/kafka/streams/kstream/ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueJoiner</code></a> that computes the join result for a pair of matching records</dd>
<dd><code>materialized</code> - an instance of <a href="../../../../../org/apache/kafka/streams/kstream/Materialized.html" title="class in org.apache.kafka.streams.kstream"><code>Materialized</code></a> used to describe how the state store should be materialized.
                      Cannot be <code>null</code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a <code>KTable</code> that contains join-records for each key and values computed by the given
 <a href="../../../../../org/apache/kafka/streams/kstream/ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueJoiner</code></a>, one for each matched record-pair with the same key</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#leftJoin-org.apache.kafka.streams.kstream.KTable-org.apache.kafka.streams.kstream.ValueJoiner-org.apache.kafka.streams.kstream.Materialized-"><code>leftJoin(KTable, ValueJoiner, Materialized)</code></a>, 
<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#outerJoin-org.apache.kafka.streams.kstream.KTable-org.apache.kafka.streams.kstream.ValueJoiner-org.apache.kafka.streams.kstream.Materialized-"><code>outerJoin(KTable, ValueJoiner, Materialized)</code></a></dd>
</dl>
</li>
</ul>
<a name="join-org.apache.kafka.streams.kstream.KTable-org.apache.kafka.streams.kstream.ValueJoiner-org.apache.kafka.common.serialization.Serde-java.lang.String-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>join</h4>
<pre>@Deprecated
&lt;VO,VR&gt;&nbsp;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,VR&gt;&nbsp;join(<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,VO&gt;&nbsp;other,
                                      <a href="../../../../../org/apache/kafka/streams/kstream/ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream">ValueJoiner</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>,? super VO,? extends VR&gt;&nbsp;joiner,
                                      <a href="../../../../../org/apache/kafka/common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization">Serde</a>&lt;VR&gt;&nbsp;joinSerde,
                                      java.lang.String&nbsp;queryableStoreName)</pre>
<div class="block"><span class="deprecatedLabel">Deprecated.</span>&nbsp;<span class="deprecationComment">use <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#join-org.apache.kafka.streams.kstream.KTable-org.apache.kafka.streams.kstream.ValueJoiner-org.apache.kafka.streams.kstream.Materialized-"><code>join(other, joiner, Materialized.as(queryableStoreName).withValueSerde(joinSerde)</code></a></span></div>
<div class="block">Join records of this <code>KTable</code> with another <code>KTable</code>'s records using non-windowed inner equi join.
 The join is a primary key join with join attribute <code>thisKTable.key == otherKTable.key</code>.
 The result is an ever updating <code>KTable</code> that represents the <em>current</em> (i.e., processing time) result
 of the join.
 <p>
 The join is computed by (1) updating the internal state of one <code>KTable</code> and (2) performing a lookup for a
 matching record in the <em>current</em> (i.e., processing time) internal state of the other <code>KTable</code>.
 This happens in a symmetric way, i.e., for each update of either <code>this</code> or the <code>other</code> input
 <code>KTable</code> the result gets updated.
 <p>
 For each <code>KTable</code> record that finds a corresponding record in the other <code>KTable</code> the provided
 <a href="../../../../../org/apache/kafka/streams/kstream/ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueJoiner</code></a> will be called to compute a value (with arbitrary type) for the result record.
 The key of the result record is the same as for both joining input records.
 <p>
 Note that <a href="../../../../../org/apache/kafka/streams/KeyValue.html" title="class in org.apache.kafka.streams"><code>records</code></a> with <code>null</code> values (so-called tombstone records) have delete semantics.
 Thus, for input tombstones the provided value-joiner is not called but a tombstone record is forwarded
 directly to delete a record in the result <code>KTable</code> if required (i.e., if there is anything to be deleted).
 <p>
 Input records with <code>null</code> key will be dropped and no join computation is performed.
 <p>
 Example:
 <table border='1'>
 <tr>
 <th>thisKTable</th>
 <th>thisState</th>
 <th>otherKTable</th>
 <th>otherState</th>
 <th>result update record</th>
 </tr>
 <tr>
 <td>&lt;K1:A&gt;</td>
 <td>&lt;K1:A&gt;</td>
 <td></td>
 <td></td>
 <td></td>
 </tr>
 <tr>
 <td></td>
 <td>&lt;K1:A&gt;</td>
 <td>&lt;K1:b&gt;</td>
 <td>&lt;K1:b&gt;</td>
 <td>&lt;K1:ValueJoiner(A,b)&gt;</td>
 </tr>
 <tr>
 <td>&lt;K1:C&gt;</td>
 <td>&lt;K1:C&gt;</td>
 <td></td>
 <td>&lt;K1:b&gt;</td>
 <td>&lt;K1:ValueJoiner(C,b)&gt;</td>
 </tr>
 <tr>
 <td></td>
 <td>&lt;K1:C&gt;</td>
 <td>&lt;K1:null&gt;</td>
 <td></td>
 <td>&lt;K1:null&gt;</td>
 </tr>
 </table>
 Both input streams (or to be more precise, their underlying source topics) need to have the same number of
 partitions.</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>VO</code> - the value type of the other <code>KTable</code></dd>
<dd><code>VR</code> - the value type of the result <code>KTable</code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>other</code> - the other <code>KTable</code> to be joined with this <code>KTable</code></dd>
<dd><code>joiner</code> - a <a href="../../../../../org/apache/kafka/streams/kstream/ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueJoiner</code></a> that computes the join result for a pair of matching records</dd>
<dd><code>joinSerde</code> - serializer for join result value type</dd>
<dd><code>queryableStoreName</code> - a user-provided name of the underlying <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> that can be
 used to subsequently query the operation results; valid characters are ASCII
 alphanumerics, '.', '_' and '-'. If <code>null</code> then the results cannot be queried
 (i.e., that would be equivalent to calling <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#join-org.apache.kafka.streams.kstream.KTable-org.apache.kafka.streams.kstream.ValueJoiner-"><code>join(KTable, ValueJoiner)</code></a>.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a <code>KTable</code> that contains join-records for each key and values computed by the given
 <a href="../../../../../org/apache/kafka/streams/kstream/ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueJoiner</code></a>, one for each matched record-pair with the same key</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#leftJoin-org.apache.kafka.streams.kstream.KTable-org.apache.kafka.streams.kstream.ValueJoiner-org.apache.kafka.streams.kstream.Materialized-"><code>leftJoin(KTable, ValueJoiner, Materialized)</code></a>, 
<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#outerJoin-org.apache.kafka.streams.kstream.KTable-org.apache.kafka.streams.kstream.ValueJoiner-org.apache.kafka.streams.kstream.Materialized-"><code>outerJoin(KTable, ValueJoiner, Materialized)</code></a></dd>
</dl>
</li>
</ul>
<a name="join-org.apache.kafka.streams.kstream.KTable-org.apache.kafka.streams.kstream.ValueJoiner-org.apache.kafka.streams.processor.StateStoreSupplier-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>join</h4>
<pre>@Deprecated
&lt;VO,VR&gt;&nbsp;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,VR&gt;&nbsp;join(<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,VO&gt;&nbsp;other,
                                      <a href="../../../../../org/apache/kafka/streams/kstream/ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream">ValueJoiner</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>,? super VO,? extends VR&gt;&nbsp;joiner,
                                      <a href="../../../../../org/apache/kafka/streams/processor/StateStoreSupplier.html" title="interface in org.apache.kafka.streams.processor">StateStoreSupplier</a>&lt;<a href="../../../../../org/apache/kafka/streams/state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state">KeyValueStore</a>&gt;&nbsp;storeSupplier)</pre>
<div class="block"><span class="deprecatedLabel">Deprecated.</span>&nbsp;<span class="deprecationComment">use <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#join-org.apache.kafka.streams.kstream.KTable-org.apache.kafka.streams.kstream.ValueJoiner-org.apache.kafka.streams.kstream.Materialized-"><code>join(other, joiner, Materialized.as(KeyValueByteStoreSupplier)</code></a></span></div>
<div class="block">Join records of this <code>KTable</code> with another <code>KTable</code>'s records using non-windowed inner equi join.
 The join is a primary key join with join attribute <code>thisKTable.key == otherKTable.key</code>.
 The result is an ever updating <code>KTable</code> that represents the <em>current</em> (i.e., processing time) result
 of the join.
 <p>
 The join is computed by (1) updating the internal state of one <code>KTable</code> and (2) performing a lookup for a
 matching record in the <em>current</em> (i.e., processing time) internal state of the other <code>KTable</code>.
 This happens in a symmetric way, i.e., for each update of either <code>this</code> or the <code>other</code> input
 <code>KTable</code> the result gets updated.
 <p>
 For each <code>KTable</code> record that finds a corresponding record in the other <code>KTable</code> the provided
 <a href="../../../../../org/apache/kafka/streams/kstream/ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueJoiner</code></a> will be called to compute a value (with arbitrary type) for the result record.
 The key of the result record is the same as for both joining input records.
 <p>
 Note that <a href="../../../../../org/apache/kafka/streams/KeyValue.html" title="class in org.apache.kafka.streams"><code>records</code></a> with <code>null</code> values (so-called tombstone records) have delete semantics.
 Thus, for input tombstones the provided value-joiner is not called but a tombstone record is forwarded
 directly to delete a record in the result <code>KTable</code> if required (i.e., if there is anything to be deleted).
 <p>
 Input records with <code>null</code> key will be dropped and no join computation is performed.
 <p>
 Example:
 <table border='1'>
 <tr>
 <th>thisKTable</th>
 <th>thisState</th>
 <th>otherKTable</th>
 <th>otherState</th>
 <th>result update record</th>
 </tr>
 <tr>
 <td>&lt;K1:A&gt;</td>
 <td>&lt;K1:A&gt;</td>
 <td></td>
 <td></td>
 <td></td>
 </tr>
 <tr>
 <td></td>
 <td>&lt;K1:A&gt;</td>
 <td>&lt;K1:b&gt;</td>
 <td>&lt;K1:b&gt;</td>
 <td>&lt;K1:ValueJoiner(A,b)&gt;</td>
 </tr>
 <tr>
 <td>&lt;K1:C&gt;</td>
 <td>&lt;K1:C&gt;</td>
 <td></td>
 <td>&lt;K1:b&gt;</td>
 <td>&lt;K1:ValueJoiner(C,b)&gt;</td>
 </tr>
 <tr>
 <td></td>
 <td>&lt;K1:C&gt;</td>
 <td>&lt;K1:null&gt;</td>
 <td></td>
 <td>&lt;K1:null&gt;</td>
 </tr>
 </table>
 Both input streams (or to be more precise, their underlying source topics) need to have the same number of
 partitions.</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>VO</code> - the value type of the other <code>KTable</code></dd>
<dd><code>VR</code> - the value type of the result <code>KTable</code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>other</code> - the other <code>KTable</code> to be joined with this <code>KTable</code></dd>
<dd><code>joiner</code> - a <a href="../../../../../org/apache/kafka/streams/kstream/ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueJoiner</code></a> that computes the join result for a pair of matching records</dd>
<dd><code>storeSupplier</code> - user defined state store supplier. Cannot be <code>null</code>.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a <code>KTable</code> that contains join-records for each key and values computed by the given
 <a href="../../../../../org/apache/kafka/streams/kstream/ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueJoiner</code></a>, one for each matched record-pair with the same key</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#leftJoin-org.apache.kafka.streams.kstream.KTable-org.apache.kafka.streams.kstream.ValueJoiner-org.apache.kafka.streams.kstream.Materialized-"><code>leftJoin(KTable, ValueJoiner, Materialized)</code></a>, 
<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#outerJoin-org.apache.kafka.streams.kstream.KTable-org.apache.kafka.streams.kstream.ValueJoiner-org.apache.kafka.streams.kstream.Materialized-"><code>outerJoin(KTable, ValueJoiner, Materialized)</code></a></dd>
</dl>
</li>
</ul>
<a name="leftJoin-org.apache.kafka.streams.kstream.KTable-org.apache.kafka.streams.kstream.ValueJoiner-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>leftJoin</h4>
<pre>&lt;VO,VR&gt;&nbsp;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,VR&gt;&nbsp;leftJoin(<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,VO&gt;&nbsp;other,
                              <a href="../../../../../org/apache/kafka/streams/kstream/ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream">ValueJoiner</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>,? super VO,? extends VR&gt;&nbsp;joiner)</pre>
<div class="block">Join records of this <code>KTable</code> (left input) with another <code>KTable</code>'s (right input) records using
 non-windowed left equi join.
 The join is a primary key join with join attribute <code>thisKTable.key == otherKTable.key</code>.
 In contrast to <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#join-org.apache.kafka.streams.kstream.KTable-org.apache.kafka.streams.kstream.ValueJoiner-"><code>inner-join</code></a>, all records from left <code>KTable</code> will produce
 an output record (cf. below).
 The result is an ever updating <code>KTable</code> that represents the <em>current</em> (i.e., processing time) result
 of the join.
 <p>
 The join is computed by (1) updating the internal state of one <code>KTable</code> and (2) performing a lookup for a
 matching record in the <em>current</em> (i.e., processing time) internal state of the other <code>KTable</code>.
 This happens in a symmetric way, i.e., for each update of either <code>this</code> or the <code>other</code> input
 <code>KTable</code> the result gets updated.
 <p>
 For each <code>KTable</code> record that finds a corresponding record in the other <code>KTable</code>'s state the
 provided <a href="../../../../../org/apache/kafka/streams/kstream/ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueJoiner</code></a> will be called to compute a value (with arbitrary type) for the result record.
 Additionally, for each record of left <code>KTable</code> that does not find a corresponding record in the
 right <code>KTable</code>'s state the provided <a href="../../../../../org/apache/kafka/streams/kstream/ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueJoiner</code></a> will be called with <code>rightValue =
 null</code> to compute a value (with arbitrary type) for the result record.
 The key of the result record is the same as for both joining input records.
 <p>
 Note that <a href="../../../../../org/apache/kafka/streams/KeyValue.html" title="class in org.apache.kafka.streams"><code>records</code></a> with <code>null</code> values (so-called tombstone records) have delete semantics.
 For example, for left input tombstones the provided value-joiner is not called but a tombstone record is
 forwarded directly to delete a record in the result <code>KTable</code> if required (i.e., if there is anything to be
 deleted).
 <p>
 Input records with <code>null</code> key will be dropped and no join computation is performed.
 <p>
 Example:
 <table border='1'>
 <tr>
 <th>thisKTable</th>
 <th>thisState</th>
 <th>otherKTable</th>
 <th>otherState</th>
 <th>result update record</th>
 </tr>
 <tr>
 <td>&lt;K1:A&gt;</td>
 <td>&lt;K1:A&gt;</td>
 <td></td>
 <td></td>
 <td>&lt;K1:ValueJoiner(A,null)&gt;</td>
 </tr>
 <tr>
 <td></td>
 <td>&lt;K1:A&gt;</td>
 <td>&lt;K1:b&gt;</td>
 <td>&lt;K1:b&gt;</td>
 <td>&lt;K1:ValueJoiner(A,b)&gt;</td>
 </tr>
 <tr>
 <td>&lt;K1:null&gt;</td>
 <td></td>
 <td></td>
 <td>&lt;K1:b&gt;</td>
 <td>&lt;K1:null&gt;</td>
 </tr>
 <tr>
 <td></td>
 <td></td>
 <td>&lt;K1:null&gt;</td>
 <td></td>
 <td></td>
 </tr>
 </table>
 Both input streams (or to be more precise, their underlying source topics) need to have the same number of
 partitions.</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>VO</code> - the value type of the other <code>KTable</code></dd>
<dd><code>VR</code> - the value type of the result <code>KTable</code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>other</code> - the other <code>KTable</code> to be joined with this <code>KTable</code></dd>
<dd><code>joiner</code> - a <a href="../../../../../org/apache/kafka/streams/kstream/ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueJoiner</code></a> that computes the join result for a pair of matching records</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a <code>KTable</code> that contains join-records for each key and values computed by the given
 <a href="../../../../../org/apache/kafka/streams/kstream/ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueJoiner</code></a>, one for each matched record-pair with the same key plus one for each non-matching record of
 left <code>KTable</code></dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#join-org.apache.kafka.streams.kstream.KTable-org.apache.kafka.streams.kstream.ValueJoiner-"><code>join(KTable, ValueJoiner)</code></a>, 
<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#outerJoin-org.apache.kafka.streams.kstream.KTable-org.apache.kafka.streams.kstream.ValueJoiner-"><code>outerJoin(KTable, ValueJoiner)</code></a></dd>
</dl>
</li>
</ul>
<a name="leftJoin-org.apache.kafka.streams.kstream.KTable-org.apache.kafka.streams.kstream.ValueJoiner-org.apache.kafka.streams.kstream.Materialized-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>leftJoin</h4>
<pre>&lt;VO,VR&gt;&nbsp;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,VR&gt;&nbsp;leftJoin(<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,VO&gt;&nbsp;other,
                              <a href="../../../../../org/apache/kafka/streams/kstream/ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream">ValueJoiner</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>,? super VO,? extends VR&gt;&nbsp;joiner,
                              <a href="../../../../../org/apache/kafka/streams/kstream/Materialized.html" title="class in org.apache.kafka.streams.kstream">Materialized</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,VR,<a href="../../../../../org/apache/kafka/streams/state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state">KeyValueStore</a>&lt;org.apache.kafka.common.utils.Bytes,byte[]&gt;&gt;&nbsp;materialized)</pre>
<div class="block">Join records of this <code>KTable</code> (left input) with another <code>KTable</code>'s (right input) records using
 non-windowed left equi join.
 The join is a primary key join with join attribute <code>thisKTable.key == otherKTable.key</code>.
 In contrast to <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#join-org.apache.kafka.streams.kstream.KTable-org.apache.kafka.streams.kstream.ValueJoiner-"><code>inner-join</code></a>, all records from left <code>KTable</code> will produce
 an output record (cf. below).
 The result is an ever updating <code>KTable</code> that represents the <em>current</em> (i.e., processing time) result
 of the join.
 <p>
 The join is computed by (1) updating the internal state of one <code>KTable</code> and (2) performing a lookup for a
 matching record in the <em>current</em> (i.e., processing time) internal state of the other <code>KTable</code>.
 This happens in a symmetric way, i.e., for each update of either <code>this</code> or the <code>other</code> input
 <code>KTable</code> the result gets updated.
 <p>
 For each <code>KTable</code> record that finds a corresponding record in the other <code>KTable</code>'s state the
 provided <a href="../../../../../org/apache/kafka/streams/kstream/ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueJoiner</code></a> will be called to compute a value (with arbitrary type) for the result record.
 Additionally, for each record of left <code>KTable</code> that does not find a corresponding record in the
 right <code>KTable</code>'s state the provided <a href="../../../../../org/apache/kafka/streams/kstream/ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueJoiner</code></a> will be called with <code>rightValue =
 null</code> to compute a value (with arbitrary type) for the result record.
 The key of the result record is the same as for both joining input records.
 <p>
 Note that <a href="../../../../../org/apache/kafka/streams/KeyValue.html" title="class in org.apache.kafka.streams"><code>records</code></a> with <code>null</code> values (so-called tombstone records) have delete semantics.
 For example, for left input tombstones the provided value-joiner is not called but a tombstone record is
 forwarded directly to delete a record in the result <code>KTable</code> if required (i.e., if there is anything to be
 deleted).
 <p>
 Input records with <code>null</code> key will be dropped and no join computation is performed.
 <p>
 Example:
 <table border='1'>
 <tr>
 <th>thisKTable</th>
 <th>thisState</th>
 <th>otherKTable</th>
 <th>otherState</th>
 <th>result update record</th>
 </tr>
 <tr>
 <td>&lt;K1:A&gt;</td>
 <td>&lt;K1:A&gt;</td>
 <td></td>
 <td></td>
 <td>&lt;K1:ValueJoiner(A,null)&gt;</td>
 </tr>
 <tr>
 <td></td>
 <td>&lt;K1:A&gt;</td>
 <td>&lt;K1:b&gt;</td>
 <td>&lt;K1:b&gt;</td>
 <td>&lt;K1:ValueJoiner(A,b)&gt;</td>
 </tr>
 <tr>
 <td>&lt;K1:null&gt;</td>
 <td></td>
 <td></td>
 <td>&lt;K1:b&gt;</td>
 <td>&lt;K1:null&gt;</td>
 </tr>
 <tr>
 <td></td>
 <td></td>
 <td>&lt;K1:null&gt;</td>
 <td></td>
 <td></td>
 </tr>
 </table>
 Both input streams (or to be more precise, their underlying source topics) need to have the same number of
 partitions.</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>VO</code> - the value type of the other <code>KTable</code></dd>
<dd><code>VR</code> - the value type of the result <code>KTable</code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>other</code> - the other <code>KTable</code> to be joined with this <code>KTable</code></dd>
<dd><code>joiner</code> - a <a href="../../../../../org/apache/kafka/streams/kstream/ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueJoiner</code></a> that computes the join result for a pair of matching records</dd>
<dd><code>materialized</code> - an instance of <a href="../../../../../org/apache/kafka/streams/kstream/Materialized.html" title="class in org.apache.kafka.streams.kstream"><code>Materialized</code></a> used to describe how the state store should be materialized.
                      Cannot be <code>null</code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a <code>KTable</code> that contains join-records for each key and values computed by the given
 <a href="../../../../../org/apache/kafka/streams/kstream/ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueJoiner</code></a>, one for each matched record-pair with the same key plus one for each non-matching record of
 left <code>KTable</code></dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#join-org.apache.kafka.streams.kstream.KTable-org.apache.kafka.streams.kstream.ValueJoiner-org.apache.kafka.streams.kstream.Materialized-"><code>join(KTable, ValueJoiner, Materialized)</code></a>, 
<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#outerJoin-org.apache.kafka.streams.kstream.KTable-org.apache.kafka.streams.kstream.ValueJoiner-org.apache.kafka.streams.kstream.Materialized-"><code>outerJoin(KTable, ValueJoiner, Materialized)</code></a></dd>
</dl>
</li>
</ul>
<a name="leftJoin-org.apache.kafka.streams.kstream.KTable-org.apache.kafka.streams.kstream.ValueJoiner-org.apache.kafka.common.serialization.Serde-java.lang.String-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>leftJoin</h4>
<pre>@Deprecated
&lt;VO,VR&gt;&nbsp;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,VR&gt;&nbsp;leftJoin(<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,VO&gt;&nbsp;other,
                                          <a href="../../../../../org/apache/kafka/streams/kstream/ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream">ValueJoiner</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>,? super VO,? extends VR&gt;&nbsp;joiner,
                                          <a href="../../../../../org/apache/kafka/common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization">Serde</a>&lt;VR&gt;&nbsp;joinSerde,
                                          java.lang.String&nbsp;queryableStoreName)</pre>
<div class="block"><span class="deprecatedLabel">Deprecated.</span>&nbsp;<span class="deprecationComment">use <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#leftJoin-org.apache.kafka.streams.kstream.KTable-org.apache.kafka.streams.kstream.ValueJoiner-org.apache.kafka.streams.kstream.Materialized-"><code>leftJoin(other, joiner, Materialized.as(queryableStoreName).withValueSerde(joinSerde)</code></a></span></div>
<div class="block">Join records of this <code>KTable</code> (left input) with another <code>KTable</code>'s (right input) records using
 non-windowed left equi join.
 The join is a primary key join with join attribute <code>thisKTable.key == otherKTable.key</code>.
 In contrast to <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#join-org.apache.kafka.streams.kstream.KTable-org.apache.kafka.streams.kstream.ValueJoiner-"><code>inner-join</code></a>, all records from left <code>KTable</code> will produce
 an output record (cf. below).
 The result is an ever updating <code>KTable</code> that represents the <em>current</em> (i.e., processing time) result
 of the join.
 <p>
 The join is computed by (1) updating the internal state of one <code>KTable</code> and (2) performing a lookup for a
 matching record in the <em>current</em> (i.e., processing time) internal state of the other <code>KTable</code>.
 This happens in a symmetric way, i.e., for each update of either <code>this</code> or the <code>other</code> input
 <code>KTable</code> the result gets updated.
 <p>
 For each <code>KTable</code> record that finds a corresponding record in the other <code>KTable</code>'s state the
 provided <a href="../../../../../org/apache/kafka/streams/kstream/ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueJoiner</code></a> will be called to compute a value (with arbitrary type) for the result record.
 Additionally, for each record of left <code>KTable</code> that does not find a corresponding record in the
 right <code>KTable</code>'s state the provided <a href="../../../../../org/apache/kafka/streams/kstream/ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueJoiner</code></a> will be called with <code>rightValue =
 null</code> to compute a value (with arbitrary type) for the result record.
 The key of the result record is the same as for both joining input records.
 <p>
 Note that <a href="../../../../../org/apache/kafka/streams/KeyValue.html" title="class in org.apache.kafka.streams"><code>records</code></a> with <code>null</code> values (so-called tombstone records) have delete semantics.
 For example, for left input tombstones the provided value-joiner is not called but a tombstone record is
 forwarded directly to delete a record in the result <code>KTable</code> if required (i.e., if there is anything to be
 deleted).
 <p>
 Input records with <code>null</code> key will be dropped and no join computation is performed.
 <p>
 Example:
 <table border='1'>
 <tr>
 <th>thisKTable</th>
 <th>thisState</th>
 <th>otherKTable</th>
 <th>otherState</th>
 <th>result update record</th>
 </tr>
 <tr>
 <td>&lt;K1:A&gt;</td>
 <td>&lt;K1:A&gt;</td>
 <td></td>
 <td></td>
 <td>&lt;K1:ValueJoiner(A,null)&gt;</td>
 </tr>
 <tr>
 <td></td>
 <td>&lt;K1:A&gt;</td>
 <td>&lt;K1:b&gt;</td>
 <td>&lt;K1:b&gt;</td>
 <td>&lt;K1:ValueJoiner(A,b)&gt;</td>
 </tr>
 <tr>
 <td>&lt;K1:null&gt;</td>
 <td></td>
 <td></td>
 <td>&lt;K1:b&gt;</td>
 <td>&lt;K1:null&gt;</td>
 </tr>
 <tr>
 <td></td>
 <td></td>
 <td>&lt;K1:null&gt;</td>
 <td></td>
 <td></td>
 </tr>
 </table>
 Both input streams (or to be more precise, their underlying source topics) need to have the same number of
 partitions.</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>VO</code> - the value type of the other <code>KTable</code></dd>
<dd><code>VR</code> - the value type of the result <code>KTable</code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>other</code> - the other <code>KTable</code> to be joined with this <code>KTable</code></dd>
<dd><code>joiner</code> - a <a href="../../../../../org/apache/kafka/streams/kstream/ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueJoiner</code></a> that computes the join result for a pair of matching records</dd>
<dd><code>joinSerde</code> - serializer for join result value type</dd>
<dd><code>queryableStoreName</code> - a user-provided name of the underlying <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> that can be
 used to subsequently query the operation results; valid characters are ASCII
 alphanumerics, '.', '_' and '-'. If <code>null</code> then the results cannot be queried
 (i.e., that would be equivalent to calling <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#leftJoin-org.apache.kafka.streams.kstream.KTable-org.apache.kafka.streams.kstream.ValueJoiner-"><code>leftJoin(KTable, ValueJoiner)</code></a>.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a <code>KTable</code> that contains join-records for each key and values computed by the given
 <a href="../../../../../org/apache/kafka/streams/kstream/ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueJoiner</code></a>, one for each matched record-pair with the same key plus one for each non-matching record of
 left <code>KTable</code></dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#join-org.apache.kafka.streams.kstream.KTable-org.apache.kafka.streams.kstream.ValueJoiner-org.apache.kafka.streams.kstream.Materialized-"><code>join(KTable, ValueJoiner, Materialized)</code></a>, 
<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#outerJoin-org.apache.kafka.streams.kstream.KTable-org.apache.kafka.streams.kstream.ValueJoiner-org.apache.kafka.streams.kstream.Materialized-"><code>outerJoin(KTable, ValueJoiner, Materialized)</code></a></dd>
</dl>
</li>
</ul>
<a name="leftJoin-org.apache.kafka.streams.kstream.KTable-org.apache.kafka.streams.kstream.ValueJoiner-org.apache.kafka.streams.processor.StateStoreSupplier-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>leftJoin</h4>
<pre>@Deprecated
&lt;VO,VR&gt;&nbsp;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,VR&gt;&nbsp;leftJoin(<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,VO&gt;&nbsp;other,
                                          <a href="../../../../../org/apache/kafka/streams/kstream/ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream">ValueJoiner</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>,? super VO,? extends VR&gt;&nbsp;joiner,
                                          <a href="../../../../../org/apache/kafka/streams/processor/StateStoreSupplier.html" title="interface in org.apache.kafka.streams.processor">StateStoreSupplier</a>&lt;<a href="../../../../../org/apache/kafka/streams/state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state">KeyValueStore</a>&gt;&nbsp;storeSupplier)</pre>
<div class="block"><span class="deprecatedLabel">Deprecated.</span>&nbsp;<span class="deprecationComment">use <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#leftJoin-org.apache.kafka.streams.kstream.KTable-org.apache.kafka.streams.kstream.ValueJoiner-org.apache.kafka.streams.kstream.Materialized-"><code>leftJoin(other, joiner, Materialized.as(KeyValueByteStoreSupplier)</code></a></span></div>
<div class="block">Join records of this <code>KTable</code> (left input) with another <code>KTable</code>'s (right input) records using
 non-windowed left equi join.
 The join is a primary key join with join attribute <code>thisKTable.key == otherKTable.key</code>.
 In contrast to <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#join-org.apache.kafka.streams.kstream.KTable-org.apache.kafka.streams.kstream.ValueJoiner-"><code>inner-join</code></a>, all records from left <code>KTable</code> will produce
 an output record (cf. below).
 The result is an ever updating <code>KTable</code> that represents the <em>current</em> (i.e., processing time) result
 of the join.
 <p>
 The join is computed by (1) updating the internal state of one <code>KTable</code> and (2) performing a lookup for a
 matching record in the <em>current</em> (i.e., processing time) internal state of the other <code>KTable</code>.
 This happens in a symmetric way, i.e., for each update of either <code>this</code> or the <code>other</code> input
 <code>KTable</code> the result gets updated.
 <p>
 For each <code>KTable</code> record that finds a corresponding record in the other <code>KTable</code>'s state the
 provided <a href="../../../../../org/apache/kafka/streams/kstream/ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueJoiner</code></a> will be called to compute a value (with arbitrary type) for the result record.
 Additionally, for each record of left <code>KTable</code> that does not find a corresponding record in the
 right <code>KTable</code>'s state the provided <a href="../../../../../org/apache/kafka/streams/kstream/ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueJoiner</code></a> will be called with <code>rightValue =
 null</code> to compute a value (with arbitrary type) for the result record.
 The key of the result record is the same as for both joining input records.
 <p>
 Note that <a href="../../../../../org/apache/kafka/streams/KeyValue.html" title="class in org.apache.kafka.streams"><code>records</code></a> with <code>null</code> values (so-called tombstone records) have delete semantics.
 For example, for left input tombstones the provided value-joiner is not called but a tombstone record is
 forwarded directly to delete a record in the result <code>KTable</code> if required (i.e., if there is anything to be
 deleted).
 <p>
 Input records with <code>null</code> key will be dropped and no join computation is performed.
 <p>
 Example:
 <table border='1'>
 <tr>
 <th>thisKTable</th>
 <th>thisState</th>
 <th>otherKTable</th>
 <th>otherState</th>
 <th>result update record</th>
 </tr>
 <tr>
 <td>&lt;K1:A&gt;</td>
 <td>&lt;K1:A&gt;</td>
 <td></td>
 <td></td>
 <td>&lt;K1:ValueJoiner(A,null)&gt;</td>
 </tr>
 <tr>
 <td></td>
 <td>&lt;K1:A&gt;</td>
 <td>&lt;K1:b&gt;</td>
 <td>&lt;K1:b&gt;</td>
 <td>&lt;K1:ValueJoiner(A,b)&gt;</td>
 </tr>
 <tr>
 <td>&lt;K1:null&gt;</td>
 <td></td>
 <td></td>
 <td>&lt;K1:b&gt;</td>
 <td>&lt;K1:null&gt;</td>
 </tr>
 <tr>
 <td></td>
 <td></td>
 <td>&lt;K1:null&gt;</td>
 <td></td>
 <td></td>
 </tr>
 </table>
 Both input streams (or to be more precise, their underlying source topics) need to have the same number of
 partitions.</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>VO</code> - the value type of the other <code>KTable</code></dd>
<dd><code>VR</code> - the value type of the result <code>KTable</code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>other</code> - the other <code>KTable</code> to be joined with this <code>KTable</code></dd>
<dd><code>joiner</code> - a <a href="../../../../../org/apache/kafka/streams/kstream/ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueJoiner</code></a> that computes the join result for a pair of matching records</dd>
<dd><code>storeSupplier</code> - user defined state store supplier. Cannot be <code>null</code>.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a <code>KTable</code> that contains join-records for each key and values computed by the given
 <a href="../../../../../org/apache/kafka/streams/kstream/ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueJoiner</code></a>, one for each matched record-pair with the same key plus one for each non-matching record of
 left <code>KTable</code></dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#join-org.apache.kafka.streams.kstream.KTable-org.apache.kafka.streams.kstream.ValueJoiner-org.apache.kafka.streams.kstream.Materialized-"><code>join(KTable, ValueJoiner, Materialized)</code></a>, 
<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#outerJoin-org.apache.kafka.streams.kstream.KTable-org.apache.kafka.streams.kstream.ValueJoiner-org.apache.kafka.streams.kstream.Materialized-"><code>outerJoin(KTable, ValueJoiner, Materialized)</code></a></dd>
</dl>
</li>
</ul>
<a name="outerJoin-org.apache.kafka.streams.kstream.KTable-org.apache.kafka.streams.kstream.ValueJoiner-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>outerJoin</h4>
<pre>&lt;VO,VR&gt;&nbsp;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,VR&gt;&nbsp;outerJoin(<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,VO&gt;&nbsp;other,
                               <a href="../../../../../org/apache/kafka/streams/kstream/ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream">ValueJoiner</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>,? super VO,? extends VR&gt;&nbsp;joiner)</pre>
<div class="block">Join records of this <code>KTable</code> (left input) with another <code>KTable</code>'s (right input) records using
 non-windowed outer equi join.
 The join is a primary key join with join attribute <code>thisKTable.key == otherKTable.key</code>.
 In contrast to <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#join-org.apache.kafka.streams.kstream.KTable-org.apache.kafka.streams.kstream.ValueJoiner-"><code>inner-join</code></a> or <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#leftJoin-org.apache.kafka.streams.kstream.KTable-org.apache.kafka.streams.kstream.ValueJoiner-"><code>left-join</code></a>,
 all records from both input <code>KTable</code>s will produce an output record (cf. below).
 The result is an ever updating <code>KTable</code> that represents the <em>current</em> (i.e., processing time) result
 of the join.
 <p>
 The join is computed by (1) updating the internal state of one <code>KTable</code> and (2) performing a lookup for a
 matching record in the <em>current</em> (i.e., processing time) internal state of the other <code>KTable</code>.
 This happens in a symmetric way, i.e., for each update of either <code>this</code> or the <code>other</code> input
 <code>KTable</code> the result gets updated.
 <p>
 For each <code>KTable</code> record that finds a corresponding record in the other <code>KTable</code>'s state the
 provided <a href="../../../../../org/apache/kafka/streams/kstream/ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueJoiner</code></a> will be called to compute a value (with arbitrary type) for the result record.
 Additionally, for each record that does not find a corresponding record in the corresponding other
 <code>KTable</code>'s state the provided <a href="../../../../../org/apache/kafka/streams/kstream/ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueJoiner</code></a> will be called with <code>null</code> value for the
 corresponding other value to compute a value (with arbitrary type) for the result record.
 The key of the result record is the same as for both joining input records.
 <p>
 Note that <a href="../../../../../org/apache/kafka/streams/KeyValue.html" title="class in org.apache.kafka.streams"><code>records</code></a> with <code>null</code> values (so-called tombstone records) have delete semantics.
 Thus, for input tombstones the provided value-joiner is not called but a tombstone record is forwarded directly
 to delete a record in the result <code>KTable</code> if required (i.e., if there is anything to be deleted).
 <p>
 Input records with <code>null</code> key will be dropped and no join computation is performed.
 <p>
 Example:
 <table border='1'>
 <tr>
 <th>thisKTable</th>
 <th>thisState</th>
 <th>otherKTable</th>
 <th>otherState</th>
 <th>result update record</th>
 </tr>
 <tr>
 <td>&lt;K1:A&gt;</td>
 <td>&lt;K1:A&gt;</td>
 <td></td>
 <td></td>
 <td>&lt;K1:ValueJoiner(A,null)&gt;</td>
 </tr>
 <tr>
 <td></td>
 <td>&lt;K1:A&gt;</td>
 <td>&lt;K1:b&gt;</td>
 <td>&lt;K1:b&gt;</td>
 <td>&lt;K1:ValueJoiner(A,b)&gt;</td>
 </tr>
 <tr>
 <td>&lt;K1:null&gt;</td>
 <td></td>
 <td></td>
 <td>&lt;K1:b&gt;</td>
 <td>&lt;K1:ValueJoiner(null,b)&gt;</td>
 </tr>
 <tr>
 <td></td>
 <td></td>
 <td>&lt;K1:null&gt;</td>
 <td></td>
 <td>&lt;K1:null&gt;</td>
 </tr>
 </table>
 Both input streams (or to be more precise, their underlying source topics) need to have the same number of
 partitions.</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>VO</code> - the value type of the other <code>KTable</code></dd>
<dd><code>VR</code> - the value type of the result <code>KTable</code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>other</code> - the other <code>KTable</code> to be joined with this <code>KTable</code></dd>
<dd><code>joiner</code> - a <a href="../../../../../org/apache/kafka/streams/kstream/ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueJoiner</code></a> that computes the join result for a pair of matching records</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a <code>KTable</code> that contains join-records for each key and values computed by the given
 <a href="../../../../../org/apache/kafka/streams/kstream/ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueJoiner</code></a>, one for each matched record-pair with the same key plus one for each non-matching record of
 both <code>KTable</code>s</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#join-org.apache.kafka.streams.kstream.KTable-org.apache.kafka.streams.kstream.ValueJoiner-"><code>join(KTable, ValueJoiner)</code></a>, 
<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#leftJoin-org.apache.kafka.streams.kstream.KTable-org.apache.kafka.streams.kstream.ValueJoiner-"><code>leftJoin(KTable, ValueJoiner)</code></a></dd>
</dl>
</li>
</ul>
<a name="outerJoin-org.apache.kafka.streams.kstream.KTable-org.apache.kafka.streams.kstream.ValueJoiner-org.apache.kafka.streams.kstream.Materialized-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>outerJoin</h4>
<pre>&lt;VO,VR&gt;&nbsp;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,VR&gt;&nbsp;outerJoin(<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,VO&gt;&nbsp;other,
                               <a href="../../../../../org/apache/kafka/streams/kstream/ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream">ValueJoiner</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>,? super VO,? extends VR&gt;&nbsp;joiner,
                               <a href="../../../../../org/apache/kafka/streams/kstream/Materialized.html" title="class in org.apache.kafka.streams.kstream">Materialized</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,VR,<a href="../../../../../org/apache/kafka/streams/state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state">KeyValueStore</a>&lt;org.apache.kafka.common.utils.Bytes,byte[]&gt;&gt;&nbsp;materialized)</pre>
<div class="block">Join records of this <code>KTable</code> (left input) with another <code>KTable</code>'s (right input) records using
 non-windowed outer equi join.
 The join is a primary key join with join attribute <code>thisKTable.key == otherKTable.key</code>.
 In contrast to <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#join-org.apache.kafka.streams.kstream.KTable-org.apache.kafka.streams.kstream.ValueJoiner-"><code>inner-join</code></a> or <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#leftJoin-org.apache.kafka.streams.kstream.KTable-org.apache.kafka.streams.kstream.ValueJoiner-"><code>left-join</code></a>,
 all records from both input <code>KTable</code>s will produce an output record (cf. below).
 The result is an ever updating <code>KTable</code> that represents the <em>current</em> (i.e., processing time) result
 of the join.
 <p>
 The join is computed by (1) updating the internal state of one <code>KTable</code> and (2) performing a lookup for a
 matching record in the <em>current</em> (i.e., processing time) internal state of the other <code>KTable</code>.
 This happens in a symmetric way, i.e., for each update of either <code>this</code> or the <code>other</code> input
 <code>KTable</code> the result gets updated.
 <p>
 For each <code>KTable</code> record that finds a corresponding record in the other <code>KTable</code>'s state the
 provided <a href="../../../../../org/apache/kafka/streams/kstream/ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueJoiner</code></a> will be called to compute a value (with arbitrary type) for the result record.
 Additionally, for each record that does not find a corresponding record in the corresponding other
 <code>KTable</code>'s state the provided <a href="../../../../../org/apache/kafka/streams/kstream/ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueJoiner</code></a> will be called with <code>null</code> value for the
 corresponding other value to compute a value (with arbitrary type) for the result record.
 The key of the result record is the same as for both joining input records.
 <p>
 Note that <a href="../../../../../org/apache/kafka/streams/KeyValue.html" title="class in org.apache.kafka.streams"><code>records</code></a> with <code>null</code> values (so-called tombstone records) have delete semantics.
 Thus, for input tombstones the provided value-joiner is not called but a tombstone record is forwarded directly
 to delete a record in the result <code>KTable</code> if required (i.e., if there is anything to be deleted).
 <p>
 Input records with <code>null</code> key will be dropped and no join computation is performed.
 <p>
 Example:
 <table border='1'>
 <tr>
 <th>thisKTable</th>
 <th>thisState</th>
 <th>otherKTable</th>
 <th>otherState</th>
 <th>result update record</th>
 </tr>
 <tr>
 <td>&lt;K1:A&gt;</td>
 <td>&lt;K1:A&gt;</td>
 <td></td>
 <td></td>
 <td>&lt;K1:ValueJoiner(A,null)&gt;</td>
 </tr>
 <tr>
 <td></td>
 <td>&lt;K1:A&gt;</td>
 <td>&lt;K1:b&gt;</td>
 <td>&lt;K1:b&gt;</td>
 <td>&lt;K1:ValueJoiner(A,b)&gt;</td>
 </tr>
 <tr>
 <td>&lt;K1:null&gt;</td>
 <td></td>
 <td></td>
 <td>&lt;K1:b&gt;</td>
 <td>&lt;K1:ValueJoiner(null,b)&gt;</td>
 </tr>
 <tr>
 <td></td>
 <td></td>
 <td>&lt;K1:null&gt;</td>
 <td></td>
 <td>&lt;K1:null&gt;</td>
 </tr>
 </table>
 Both input streams (or to be more precise, their underlying source topics) need to have the same number of
 partitions.</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>VO</code> - the value type of the other <code>KTable</code></dd>
<dd><code>VR</code> - the value type of the result <code>KTable</code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>other</code> - the other <code>KTable</code> to be joined with this <code>KTable</code></dd>
<dd><code>joiner</code> - a <a href="../../../../../org/apache/kafka/streams/kstream/ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueJoiner</code></a> that computes the join result for a pair of matching records</dd>
<dd><code>materialized</code> - an instance of <a href="../../../../../org/apache/kafka/streams/kstream/Materialized.html" title="class in org.apache.kafka.streams.kstream"><code>Materialized</code></a> used to describe how the state store should be materialized.
                      Cannot be <code>null</code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a <code>KTable</code> that contains join-records for each key and values computed by the given
 <a href="../../../../../org/apache/kafka/streams/kstream/ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueJoiner</code></a>, one for each matched record-pair with the same key plus one for each non-matching record of
 both <code>KTable</code>s</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#join-org.apache.kafka.streams.kstream.KTable-org.apache.kafka.streams.kstream.ValueJoiner-"><code>join(KTable, ValueJoiner)</code></a>, 
<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#leftJoin-org.apache.kafka.streams.kstream.KTable-org.apache.kafka.streams.kstream.ValueJoiner-"><code>leftJoin(KTable, ValueJoiner)</code></a></dd>
</dl>
</li>
</ul>
<a name="outerJoin-org.apache.kafka.streams.kstream.KTable-org.apache.kafka.streams.kstream.ValueJoiner-org.apache.kafka.common.serialization.Serde-java.lang.String-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>outerJoin</h4>
<pre>@Deprecated
&lt;VO,VR&gt;&nbsp;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,VR&gt;&nbsp;outerJoin(<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,VO&gt;&nbsp;other,
                                           <a href="../../../../../org/apache/kafka/streams/kstream/ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream">ValueJoiner</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>,? super VO,? extends VR&gt;&nbsp;joiner,
                                           <a href="../../../../../org/apache/kafka/common/serialization/Serde.html" title="interface in org.apache.kafka.common.serialization">Serde</a>&lt;VR&gt;&nbsp;joinSerde,
                                           java.lang.String&nbsp;queryableStoreName)</pre>
<div class="block"><span class="deprecatedLabel">Deprecated.</span>&nbsp;<span class="deprecationComment">use <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#outerJoin-org.apache.kafka.streams.kstream.KTable-org.apache.kafka.streams.kstream.ValueJoiner-org.apache.kafka.streams.kstream.Materialized-"><code>outerJoin(other, joiner, Materialized.as(queryableStoreName).withValueSerde(joinSerde)</code></a></span></div>
<div class="block">Join records of this <code>KTable</code> (left input) with another <code>KTable</code>'s (right input) records using
 non-windowed outer equi join.
 The join is a primary key join with join attribute <code>thisKTable.key == otherKTable.key</code>.
 In contrast to <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#join-org.apache.kafka.streams.kstream.KTable-org.apache.kafka.streams.kstream.ValueJoiner-"><code>inner-join</code></a> or <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#leftJoin-org.apache.kafka.streams.kstream.KTable-org.apache.kafka.streams.kstream.ValueJoiner-"><code>left-join</code></a>,
 all records from both input <code>KTable</code>s will produce an output record (cf. below).
 The result is an ever updating <code>KTable</code> that represents the <em>current</em> (i.e., processing time) result
 of the join.
 <p>
 The join is computed by (1) updating the internal state of one <code>KTable</code> and (2) performing a lookup for a
 matching record in the <em>current</em> (i.e., processing time) internal state of the other <code>KTable</code>.
 This happens in a symmetric way, i.e., for each update of either <code>this</code> or the <code>other</code> input
 <code>KTable</code> the result gets updated.
 <p>
 For each <code>KTable</code> record that finds a corresponding record in the other <code>KTable</code>'s state the
 provided <a href="../../../../../org/apache/kafka/streams/kstream/ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueJoiner</code></a> will be called to compute a value (with arbitrary type) for the result record.
 Additionally, for each record that does not find a corresponding record in the corresponding other
 <code>KTable</code>'s state the provided <a href="../../../../../org/apache/kafka/streams/kstream/ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueJoiner</code></a> will be called with <code>null</code> value for the
 corresponding other value to compute a value (with arbitrary type) for the result record.
 The key of the result record is the same as for both joining input records.
 <p>
 Note that <a href="../../../../../org/apache/kafka/streams/KeyValue.html" title="class in org.apache.kafka.streams"><code>records</code></a> with <code>null</code> values (so-called tombstone records) have delete semantics.
 Thus, for input tombstones the provided value-joiner is not called but a tombstone record is forwarded directly
 to delete a record in the result <code>KTable</code> if required (i.e., if there is anything to be deleted).
 <p>
 Input records with <code>null</code> key will be dropped and no join computation is performed.
 <p>
 Example:
 <table border='1'>
 <tr>
 <th>thisKTable</th>
 <th>thisState</th>
 <th>otherKTable</th>
 <th>otherState</th>
 <th>result update record</th>
 </tr>
 <tr>
 <td>&lt;K1:A&gt;</td>
 <td>&lt;K1:A&gt;</td>
 <td></td>
 <td></td>
 <td>&lt;K1:ValueJoiner(A,null)&gt;</td>
 </tr>
 <tr>
 <td></td>
 <td>&lt;K1:A&gt;</td>
 <td>&lt;K1:b&gt;</td>
 <td>&lt;K1:b&gt;</td>
 <td>&lt;K1:ValueJoiner(A,b)&gt;</td>
 </tr>
 <tr>
 <td>&lt;K1:null&gt;</td>
 <td></td>
 <td></td>
 <td>&lt;K1:b&gt;</td>
 <td>&lt;K1:ValueJoiner(null,b)&gt;</td>
 </tr>
 <tr>
 <td></td>
 <td></td>
 <td>&lt;K1:null&gt;</td>
 <td></td>
 <td>&lt;K1:null&gt;</td>
 </tr>
 </table>
 Both input streams (or to be more precise, their underlying source topics) need to have the same number of
 partitions.</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>VO</code> - the value type of the other <code>KTable</code></dd>
<dd><code>VR</code> - the value type of the result <code>KTable</code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>other</code> - the other <code>KTable</code> to be joined with this <code>KTable</code></dd>
<dd><code>joiner</code> - a <a href="../../../../../org/apache/kafka/streams/kstream/ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueJoiner</code></a> that computes the join result for a pair of matching records</dd>
<dd><code>joinSerde</code> - serializer for join result value type</dd>
<dd><code>queryableStoreName</code> - a user-provided name of the underlying <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> that can be
 used to subsequently query the operation results; valid characters are ASCII
 alphanumerics, '.', '_' and '-'. If <code>null</code> then the results cannot be queried
 (i.e., that would be equivalent to calling <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#outerJoin-org.apache.kafka.streams.kstream.KTable-org.apache.kafka.streams.kstream.ValueJoiner-"><code>outerJoin(KTable, ValueJoiner)</code></a>.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a <code>KTable</code> that contains join-records for each key and values computed by the given
 <a href="../../../../../org/apache/kafka/streams/kstream/ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueJoiner</code></a>, one for each matched record-pair with the same key plus one for each non-matching record of
 both <code>KTable</code>s</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#join-org.apache.kafka.streams.kstream.KTable-org.apache.kafka.streams.kstream.ValueJoiner-org.apache.kafka.streams.kstream.Materialized-"><code>join(KTable, ValueJoiner, Materialized)</code></a>, 
<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#leftJoin-org.apache.kafka.streams.kstream.KTable-org.apache.kafka.streams.kstream.ValueJoiner-org.apache.kafka.streams.kstream.Materialized-"><code>leftJoin(KTable, ValueJoiner, Materialized)</code></a></dd>
</dl>
</li>
</ul>
<a name="outerJoin-org.apache.kafka.streams.kstream.KTable-org.apache.kafka.streams.kstream.ValueJoiner-org.apache.kafka.streams.processor.StateStoreSupplier-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>outerJoin</h4>
<pre>@Deprecated
&lt;VO,VR&gt;&nbsp;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,VR&gt;&nbsp;outerJoin(<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">K</a>,VO&gt;&nbsp;other,
                                           <a href="../../../../../org/apache/kafka/streams/kstream/ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream">ValueJoiner</a>&lt;? super <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html" title="type parameter in KTable">V</a>,? super VO,? extends VR&gt;&nbsp;joiner,
                                           <a href="../../../../../org/apache/kafka/streams/processor/StateStoreSupplier.html" title="interface in org.apache.kafka.streams.processor">StateStoreSupplier</a>&lt;<a href="../../../../../org/apache/kafka/streams/state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state">KeyValueStore</a>&gt;&nbsp;storeSupplier)</pre>
<div class="block"><span class="deprecatedLabel">Deprecated.</span>&nbsp;<span class="deprecationComment">use <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#outerJoin-org.apache.kafka.streams.kstream.KTable-org.apache.kafka.streams.kstream.ValueJoiner-org.apache.kafka.streams.kstream.Materialized-"><code>outerJoin(other, joiner, Materialized.as(KeyValueByteStoreSupplier)</code></a></span></div>
<div class="block">Join records of this <code>KTable</code> (left input) with another <code>KTable</code>'s (right input) records using
 non-windowed outer equi join.
 The join is a primary key join with join attribute <code>thisKTable.key == otherKTable.key</code>.
 In contrast to <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#join-org.apache.kafka.streams.kstream.KTable-org.apache.kafka.streams.kstream.ValueJoiner-"><code>inner-join</code></a> or <a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#leftJoin-org.apache.kafka.streams.kstream.KTable-org.apache.kafka.streams.kstream.ValueJoiner-"><code>left-join</code></a>,
 all records from both input <code>KTable</code>s will produce an output record (cf. below).
 The result is an ever updating <code>KTable</code> that represents the <em>current</em> (i.e., processing time) result
 of the join.
 <p>
 The join is computed by (1) updating the internal state of one <code>KTable</code> and (2) performing a lookup for a
 matching record in the <em>current</em> (i.e., processing time) internal state of the other <code>KTable</code>.
 This happens in a symmetric way, i.e., for each update of either <code>this</code> or the <code>other</code> input
 <code>KTable</code> the result gets updated.
 <p>
 For each <code>KTable</code> record that finds a corresponding record in the other <code>KTable</code>'s state the
 provided <a href="../../../../../org/apache/kafka/streams/kstream/ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueJoiner</code></a> will be called to compute a value (with arbitrary type) for the result record.
 Additionally, for each record that does not find a corresponding record in the corresponding other
 <code>KTable</code>'s state the provided <a href="../../../../../org/apache/kafka/streams/kstream/ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueJoiner</code></a> will be called with <code>null</code> value for the
 corresponding other value to compute a value (with arbitrary type) for the result record.
 The key of the result record is the same as for both joining input records.
 <p>
 Note that <a href="../../../../../org/apache/kafka/streams/KeyValue.html" title="class in org.apache.kafka.streams"><code>records</code></a> with <code>null</code> values (so-called tombstone records) have delete semantics.
 Thus, for input tombstones the provided value-joiner is not called but a tombstone record is forwarded directly
 to delete a record in the result <code>KTable</code> if required (i.e., if there is anything to be deleted).
 <p>
 Input records with <code>null</code> key will be dropped and no join computation is performed.
 <p>
 Example:
 <table border='1'>
 <tr>
 <th>thisKTable</th>
 <th>thisState</th>
 <th>otherKTable</th>
 <th>otherState</th>
 <th>result update record</th>
 </tr>
 <tr>
 <td>&lt;K1:A&gt;</td>
 <td>&lt;K1:A&gt;</td>
 <td></td>
 <td></td>
 <td>&lt;K1:ValueJoiner(A,null)&gt;</td>
 </tr>
 <tr>
 <td></td>
 <td>&lt;K1:A&gt;</td>
 <td>&lt;K1:b&gt;</td>
 <td>&lt;K1:b&gt;</td>
 <td>&lt;K1:ValueJoiner(A,b)&gt;</td>
 </tr>
 <tr>
 <td>&lt;K1:null&gt;</td>
 <td></td>
 <td></td>
 <td>&lt;K1:b&gt;</td>
 <td>&lt;K1:ValueJoiner(null,b)&gt;</td>
 </tr>
 <tr>
 <td></td>
 <td></td>
 <td>&lt;K1:null&gt;</td>
 <td></td>
 <td>&lt;K1:null&gt;</td>
 </tr>
 </table>
 Both input streams (or to be more precise, their underlying source topics) need to have the same number of
 partitions.</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>VO</code> - the value type of the other <code>KTable</code></dd>
<dd><code>VR</code> - the value type of the result <code>KTable</code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>other</code> - the other <code>KTable</code> to be joined with this <code>KTable</code></dd>
<dd><code>joiner</code> - a <a href="../../../../../org/apache/kafka/streams/kstream/ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueJoiner</code></a> that computes the join result for a pair of matching records</dd>
<dd><code>storeSupplier</code> - user defined state store supplier. Cannot be <code>null</code>.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a <code>KTable</code> that contains join-records for each key and values computed by the given
 <a href="../../../../../org/apache/kafka/streams/kstream/ValueJoiner.html" title="interface in org.apache.kafka.streams.kstream"><code>ValueJoiner</code></a>, one for each matched record-pair with the same key plus one for each non-matching record of
 both <code>KTable</code>s</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#join-org.apache.kafka.streams.kstream.KTable-org.apache.kafka.streams.kstream.ValueJoiner-"><code>join(KTable, ValueJoiner)</code></a>, 
<a href="../../../../../org/apache/kafka/streams/kstream/KTable.html#leftJoin-org.apache.kafka.streams.kstream.KTable-org.apache.kafka.streams.kstream.ValueJoiner-"><code>leftJoin(KTable, ValueJoiner)</code></a></dd>
</dl>
</li>
</ul>
<a name="queryableStoreName--">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>queryableStoreName</h4>
<pre>java.lang.String&nbsp;queryableStoreName()</pre>
<div class="block">Get the name of the local state store used that can be used to query this <code>KTable</code>.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the underlying state store name, or <code>null</code> if this <code>KTable</code> cannot be queried.</dd>
</dl>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<!-- ========= END OF CLASS DATA ========= -->
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a name="navbar.bottom">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a></div>
<a name="navbar.bottom.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../../../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../../index-all.html">Index</a></li>
<li><a href="../../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../../../../org/apache/kafka/streams/kstream/KStreamBuilder.html" title="class in org.apache.kafka.streams.kstream"><span class="typeNameLink">Prev&nbsp;Class</span></a></li>
<li><a href="../../../../../org/apache/kafka/streams/kstream/Materialized.html" title="class in org.apache.kafka.streams.kstream"><span class="typeNameLink">Next&nbsp;Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../../../../index.html?org/apache/kafka/streams/kstream/KTable.html" target="_top">Frames</a></li>
<li><a href="KTable.html" target="_top">No&nbsp;Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="../../../../../allclasses-noframe.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a name="skip.navbar.bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
</body>
</html>

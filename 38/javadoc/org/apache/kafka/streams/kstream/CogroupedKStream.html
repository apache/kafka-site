<!DOCTYPE HTML>
<html lang="en">
<head>
<!-- Generated by javadoc (17) -->
<title>CogroupedKStream (kafka 3.8.1 API)</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="description" content="declaration: package: org.apache.kafka.streams.kstream, interface: CogroupedKStream">
<meta name="generator" content="javadoc/ClassWriterImpl">
<link rel="stylesheet" type="text/css" href="../../../../../stylesheet.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../../../../script-dir/jquery-ui.min.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../../../../jquery-ui.overrides.css" title="Style">
<script type="text/javascript" src="../../../../../script.js"></script>
<script type="text/javascript" src="../../../../../script-dir/jquery-3.5.1.min.js"></script>
<script type="text/javascript" src="../../../../../script-dir/jquery-ui.min.js"></script>
</head>
<body class="class-declaration-page">
<script type="text/javascript">var evenRowColor = "even-row-color";
var oddRowColor = "odd-row-color";
var tableTab = "table-tab";
var activeTableTab = "active-table-tab";
var pathtoroot = "../../../../../";
loadScripts(document, 'script');</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<div class="flex-box">
<header role="banner" class="flex-header">
<nav role="navigation">
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="top-nav" id="navbar-top">
<div class="skip-nav"><a href="#skip-navbar-top" title="Skip navigation links">Skip navigation links</a></div>
<ul id="navbar-top-firstrow" class="nav-list" title="Navigation">
<li><a href="../../../../../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="nav-bar-cell1-rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../../index-all.html">Index</a></li>
<li><a href="../../../../../help-doc.html#class">Help</a></li>
</ul>
</div>
<div class="sub-nav">
<div>
<ul class="sub-nav-list">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method-summary">Method</a></li>
</ul>
<ul class="sub-nav-list">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method-detail">Method</a></li>
</ul>
</div>
<div class="nav-list-search"><label for="search-input">SEARCH:</label>
<input type="text" id="search-input" value="search" disabled="disabled">
<input type="reset" id="reset-button" value="reset" disabled="disabled">
</div>
</div>
<!-- ========= END OF TOP NAVBAR ========= -->
<span class="skip-nav" id="skip-navbar-top"></span></nav>
</header>
<div class="flex-content">
<main role="main">
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="sub-title"><span class="package-label-in-type">Package</span>&nbsp;<a href="package-summary.html">org.apache.kafka.streams.kstream</a></div>
<h1 title="Interface CogroupedKStream" class="title">Interface CogroupedKStream&lt;K,<wbr>VAgg&gt;</h1>
</div>
<section class="class-description" id="class-description">
<dl class="notes">
<dt>Type Parameters:</dt>
<dd><code>K</code> - Type of keys</dd>
<dd><code>VAgg</code> - Type of values after agg</dd>
</dl>
<hr>
<div class="type-signature"><span class="modifiers">public interface </span><span class="element-name type-name-label">CogroupedKStream&lt;K,<wbr>VAgg&gt;</span></div>
<div class="block"><code>CogroupedKStream</code> is an abstraction of multiple <i>grouped</i> record streams of <a href="../KeyValue.html" title="class in org.apache.kafka.streams"><code>KeyValue</code></a> pairs.
 <p>
 It is an intermediate representation after a grouping of <a href="KStream.html" title="interface in org.apache.kafka.streams.kstream"><code>KStream</code></a>s, before the
 aggregations are applied to the new partitions resulting in a <a href="KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a>.
 <p>
 A <code>CogroupedKStream</code> must be obtained from a <a href="KGroupedStream.html" title="interface in org.apache.kafka.streams.kstream"><code>KGroupedStream</code></a> via
 <a href="KGroupedStream.html#cogroup(org.apache.kafka.streams.kstream.Aggregator)"><code>cogroup(...)</code></a>.</div>
</section>
<section class="summary">
<ul class="summary-list">
<!-- ========== METHOD SUMMARY =========== -->
<li>
<section class="method-summary" id="method-summary">
<h2>Method Summary</h2>
<div id="method-summary-table">
<div class="table-tabs" role="tablist" aria-orientation="horizontal"><button id="method-summary-table-tab0" role="tab" aria-selected="true" aria-controls="method-summary-table.tabpanel" tabindex="0" onkeydown="switchTab(event)" onclick="show('method-summary-table', 'method-summary-table', 3)" class="active-table-tab">All Methods</button><button id="method-summary-table-tab2" role="tab" aria-selected="false" aria-controls="method-summary-table.tabpanel" tabindex="-1" onkeydown="switchTab(event)" onclick="show('method-summary-table', 'method-summary-table-tab2', 3)" class="table-tab">Instance Methods</button><button id="method-summary-table-tab3" role="tab" aria-selected="false" aria-controls="method-summary-table.tabpanel" tabindex="-1" onkeydown="switchTab(event)" onclick="show('method-summary-table', 'method-summary-table-tab3', 3)" class="table-tab">Abstract Methods</button></div>
<div id="method-summary-table.tabpanel" role="tabpanel">
<div class="summary-table three-column-summary" aria-labelledby="method-summary-table-tab0">
<div class="table-header col-first">Modifier and Type</div>
<div class="table-header col-second">Method</div>
<div class="table-header col-last">Description</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="CogroupedKStream.html" title="type parameter in CogroupedKStream">K</a>,<wbr><a href="CogroupedKStream.html" title="type parameter in CogroupedKStream">VAgg</a>&gt;</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#aggregate(org.apache.kafka.streams.kstream.Initializer)" class="member-name-link">aggregate</a><wbr>(<a href="Initializer.html" title="interface in org.apache.kafka.streams.kstream">Initializer</a>&lt;<a href="CogroupedKStream.html" title="type parameter in CogroupedKStream">VAgg</a>&gt;&nbsp;initializer)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">Aggregate the values of records in these streams by the grouped key.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="CogroupedKStream.html" title="type parameter in CogroupedKStream">K</a>,<wbr><a href="CogroupedKStream.html" title="type parameter in CogroupedKStream">VAgg</a>&gt;</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#aggregate(org.apache.kafka.streams.kstream.Initializer,org.apache.kafka.streams.kstream.Materialized)" class="member-name-link">aggregate</a><wbr>(<a href="Initializer.html" title="interface in org.apache.kafka.streams.kstream">Initializer</a>&lt;<a href="CogroupedKStream.html" title="type parameter in CogroupedKStream">VAgg</a>&gt;&nbsp;initializer,
 <a href="Materialized.html" title="class in org.apache.kafka.streams.kstream">Materialized</a>&lt;<a href="CogroupedKStream.html" title="type parameter in CogroupedKStream">K</a>,<wbr><a href="CogroupedKStream.html" title="type parameter in CogroupedKStream">VAgg</a>,<wbr><a href="../state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state">KeyValueStore</a>&lt;org.apache.kafka.common.utils.Bytes,<wbr>byte[]&gt;&gt;&nbsp;materialized)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">Aggregate the values of records in these streams by the grouped key.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="CogroupedKStream.html" title="type parameter in CogroupedKStream">K</a>,<wbr><a href="CogroupedKStream.html" title="type parameter in CogroupedKStream">VAgg</a>&gt;</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#aggregate(org.apache.kafka.streams.kstream.Initializer,org.apache.kafka.streams.kstream.Named)" class="member-name-link">aggregate</a><wbr>(<a href="Initializer.html" title="interface in org.apache.kafka.streams.kstream">Initializer</a>&lt;<a href="CogroupedKStream.html" title="type parameter in CogroupedKStream">VAgg</a>&gt;&nbsp;initializer,
 <a href="Named.html" title="class in org.apache.kafka.streams.kstream">Named</a>&nbsp;named)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">Aggregate the values of records in these streams by the grouped key.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="CogroupedKStream.html" title="type parameter in CogroupedKStream">K</a>,<wbr><a href="CogroupedKStream.html" title="type parameter in CogroupedKStream">VAgg</a>&gt;</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#aggregate(org.apache.kafka.streams.kstream.Initializer,org.apache.kafka.streams.kstream.Named,org.apache.kafka.streams.kstream.Materialized)" class="member-name-link">aggregate</a><wbr>(<a href="Initializer.html" title="interface in org.apache.kafka.streams.kstream">Initializer</a>&lt;<a href="CogroupedKStream.html" title="type parameter in CogroupedKStream">VAgg</a>&gt;&nbsp;initializer,
 <a href="Named.html" title="class in org.apache.kafka.streams.kstream">Named</a>&nbsp;named,
 <a href="Materialized.html" title="class in org.apache.kafka.streams.kstream">Materialized</a>&lt;<a href="CogroupedKStream.html" title="type parameter in CogroupedKStream">K</a>,<wbr><a href="CogroupedKStream.html" title="type parameter in CogroupedKStream">VAgg</a>,<wbr><a href="../state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state">KeyValueStore</a>&lt;org.apache.kafka.common.utils.Bytes,<wbr>byte[]&gt;&gt;&nbsp;materialized)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">Aggregate the values of records in these streams by the grouped key.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>&lt;V&gt;&nbsp;<a href="CogroupedKStream.html" title="interface in org.apache.kafka.streams.kstream">CogroupedKStream</a>&lt;<a href="CogroupedKStream.html" title="type parameter in CogroupedKStream">K</a>,<wbr><a href="CogroupedKStream.html" title="type parameter in CogroupedKStream">VAgg</a>&gt;</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#cogroup(org.apache.kafka.streams.kstream.KGroupedStream,org.apache.kafka.streams.kstream.Aggregator)" class="member-name-link">cogroup</a><wbr>(<a href="KGroupedStream.html" title="interface in org.apache.kafka.streams.kstream">KGroupedStream</a>&lt;<a href="CogroupedKStream.html" title="type parameter in CogroupedKStream">K</a>,<wbr>V&gt;&nbsp;groupedStream,
 <a href="Aggregator.html" title="interface in org.apache.kafka.streams.kstream">Aggregator</a>&lt;? super <a href="CogroupedKStream.html" title="type parameter in CogroupedKStream">K</a>,<wbr>? super V,<wbr><a href="CogroupedKStream.html" title="type parameter in CogroupedKStream">VAgg</a>&gt;&nbsp;aggregator)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">Add an already <a href="KGroupedStream.html" title="interface in org.apache.kafka.streams.kstream"><code>grouped KStream</code></a> to this <code>CogroupedKStream</code>.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="SessionWindowedCogroupedKStream.html" title="interface in org.apache.kafka.streams.kstream">SessionWindowedCogroupedKStream</a>&lt;<a href="CogroupedKStream.html" title="type parameter in CogroupedKStream">K</a>,<wbr><a href="CogroupedKStream.html" title="type parameter in CogroupedKStream">VAgg</a>&gt;</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#windowedBy(org.apache.kafka.streams.kstream.SessionWindows)" class="member-name-link">windowedBy</a><wbr>(<a href="SessionWindows.html" title="class in org.apache.kafka.streams.kstream">SessionWindows</a>&nbsp;windows)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">Create a new <a href="SessionWindowedCogroupedKStream.html" title="interface in org.apache.kafka.streams.kstream"><code>SessionWindowedCogroupedKStream</code></a> instance that can be used to perform session
 windowed aggregations.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="TimeWindowedCogroupedKStream.html" title="interface in org.apache.kafka.streams.kstream">TimeWindowedCogroupedKStream</a>&lt;<a href="CogroupedKStream.html" title="type parameter in CogroupedKStream">K</a>,<wbr><a href="CogroupedKStream.html" title="type parameter in CogroupedKStream">VAgg</a>&gt;</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#windowedBy(org.apache.kafka.streams.kstream.SlidingWindows)" class="member-name-link">windowedBy</a><wbr>(<a href="SlidingWindows.html" title="class in org.apache.kafka.streams.kstream">SlidingWindows</a>&nbsp;windows)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">Create a new <a href="TimeWindowedCogroupedKStream.html" title="interface in org.apache.kafka.streams.kstream"><code>TimeWindowedCogroupedKStream</code></a> instance that can be used to perform sliding
 windowed aggregations.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>&lt;W extends <a href="Window.html" title="class in org.apache.kafka.streams.kstream">Window</a>&gt;<br><a href="TimeWindowedCogroupedKStream.html" title="interface in org.apache.kafka.streams.kstream">TimeWindowedCogroupedKStream</a>&lt;<a href="CogroupedKStream.html" title="type parameter in CogroupedKStream">K</a>,<wbr><a href="CogroupedKStream.html" title="type parameter in CogroupedKStream">VAgg</a>&gt;</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#windowedBy(org.apache.kafka.streams.kstream.Windows)" class="member-name-link">windowedBy</a><wbr>(<a href="Windows.html" title="class in org.apache.kafka.streams.kstream">Windows</a>&lt;W&gt;&nbsp;windows)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">Create a new <a href="TimeWindowedCogroupedKStream.html" title="interface in org.apache.kafka.streams.kstream"><code>TimeWindowedCogroupedKStream</code></a> instance that can be used to perform windowed
 aggregations.</div>
</div>
</div>
</div>
</div>
</section>
</li>
</ul>
</section>
<section class="details">
<ul class="details-list">
<!-- ============ METHOD DETAIL ========== -->
<li>
<section class="method-details" id="method-detail">
<h2>Method Details</h2>
<ul class="member-list">
<li>
<section class="detail" id="cogroup(org.apache.kafka.streams.kstream.KGroupedStream,org.apache.kafka.streams.kstream.Aggregator)">
<h3>cogroup</h3>
<div class="member-signature"><span class="type-parameters">&lt;V&gt;</span>&nbsp;<span class="return-type"><a href="CogroupedKStream.html" title="interface in org.apache.kafka.streams.kstream">CogroupedKStream</a>&lt;<a href="CogroupedKStream.html" title="type parameter in CogroupedKStream">K</a>,<wbr><a href="CogroupedKStream.html" title="type parameter in CogroupedKStream">VAgg</a>&gt;</span>&nbsp;<span class="element-name">cogroup</span><wbr><span class="parameters">(<a href="KGroupedStream.html" title="interface in org.apache.kafka.streams.kstream">KGroupedStream</a>&lt;<a href="CogroupedKStream.html" title="type parameter in CogroupedKStream">K</a>,<wbr>V&gt;&nbsp;groupedStream,
 <a href="Aggregator.html" title="interface in org.apache.kafka.streams.kstream">Aggregator</a>&lt;? super <a href="CogroupedKStream.html" title="type parameter in CogroupedKStream">K</a>,<wbr>? super V,<wbr><a href="CogroupedKStream.html" title="type parameter in CogroupedKStream">VAgg</a>&gt;&nbsp;aggregator)</span></div>
<div class="block">Add an already <a href="KGroupedStream.html" title="interface in org.apache.kafka.streams.kstream"><code>grouped KStream</code></a> to this <code>CogroupedKStream</code>.
 <p>
 The added <a href="KGroupedStream.html" title="interface in org.apache.kafka.streams.kstream"><code>grouped KStream</code></a> must have the same number of partitions as all existing
 streams of this <code>CogroupedKStream</code>.
 If this is not the case, you would need to call <a href="KStream.html#repartition(org.apache.kafka.streams.kstream.Repartitioned)"><code>KStream.repartition(Repartitioned)</code></a> before
 <a href="KStream.html#groupByKey()"><code>grouping</code></a> the <a href="KStream.html" title="interface in org.apache.kafka.streams.kstream"><code>KStream</code></a> and specify the "correct" number of
 partitions via <a href="Repartitioned.html" title="class in org.apache.kafka.streams.kstream"><code>Repartitioned</code></a> parameter.
 <p>
 The specified <a href="Aggregator.html" title="interface in org.apache.kafka.streams.kstream"><code>Aggregator</code></a> is applied in the actual <a href="#aggregate(org.apache.kafka.streams.kstream.Initializer)"><code>aggregation</code></a> step for
 each input record and computes a new aggregate using the current aggregate (or for the very first record per key
 using the initial intermediate aggregation result provided via the <a href="Initializer.html" title="interface in org.apache.kafka.streams.kstream"><code>Initializer</code></a> that is passed into
 <a href="#aggregate(org.apache.kafka.streams.kstream.Initializer)"><code>aggregate(Initializer)</code></a>) and the record's value.</div>
<dl class="notes">
<dt>Type Parameters:</dt>
<dd><code>V</code> - Type of input values</dd>
<dt>Parameters:</dt>
<dd><code>groupedStream</code> - a group stream</dd>
<dd><code>aggregator</code> - an <a href="Aggregator.html" title="interface in org.apache.kafka.streams.kstream"><code>Aggregator</code></a> that computes a new aggregate result</dd>
<dt>Returns:</dt>
<dd>a <code>CogroupedKStream</code></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aggregate(org.apache.kafka.streams.kstream.Initializer)">
<h3>aggregate</h3>
<div class="member-signature"><span class="return-type"><a href="KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="CogroupedKStream.html" title="type parameter in CogroupedKStream">K</a>,<wbr><a href="CogroupedKStream.html" title="type parameter in CogroupedKStream">VAgg</a>&gt;</span>&nbsp;<span class="element-name">aggregate</span><wbr><span class="parameters">(<a href="Initializer.html" title="interface in org.apache.kafka.streams.kstream">Initializer</a>&lt;<a href="CogroupedKStream.html" title="type parameter in CogroupedKStream">VAgg</a>&gt;&nbsp;initializer)</span></div>
<div class="block">Aggregate the values of records in these streams by the grouped key.
 Records with <code>null</code> key or value are ignored.
 The result is written into a local <a href="../state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state"><code>KeyValueStore</code></a> (which is basically an ever-updating materialized view)
 that can be queried by the given store name in <code>materialized</code>.
 Furthermore, updates to the store are sent downstream into a <a href="KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> changelog stream.
 <p>
 To compute the aggregation the corresponding <a href="Aggregator.html" title="interface in org.apache.kafka.streams.kstream"><code>Aggregator</code></a> as specified in
 <a href="#cogroup(org.apache.kafka.streams.kstream.KGroupedStream,org.apache.kafka.streams.kstream.Aggregator)"><code>cogroup(...)</code></a> is used per input stream.
 The specified <a href="Initializer.html" title="interface in org.apache.kafka.streams.kstream"><code>Initializer</code></a> is applied once per key, directly before the first input record per key is
 processed to provide an initial intermediate aggregation result that is used to process the first record.
 <p>
 Not all updates might get sent downstream, as an internal cache is used to deduplicate consecutive updates to the
 same key.
 The rate of propagated updates depends on your input data rate, the number of distinct keys, the number of
 parallel running Kafka Streams instances, and the <a href="../StreamsConfig.html" title="class in org.apache.kafka.streams"><code>configuration</code></a> parameters for
 <a href="../StreamsConfig.html#STATESTORE_CACHE_MAX_BYTES_CONFIG"><code>cache size</code></a>, and
 <a href="../StreamsConfig.html#COMMIT_INTERVAL_MS_CONFIG"><code>commit interval</code></a>.
 <p>
 To query the local <a href="../state/ReadOnlyKeyValueStore.html" title="interface in org.apache.kafka.streams.state"><code>ReadOnlyKeyValueStore</code></a> it must be obtained via
 <a href="../KafkaStreams.html#store(org.apache.kafka.streams.StoreQueryParameters)"><code>KafkaStreams#store(...)</code></a>:
 <pre><code>
 KafkaStreams streams = ... // some aggregation on value type double
 String queryableStoreName = "storeName" // the store name should be the name of the store as defined by the Materialized instance
 StoreQueryParameters&lt;ReadOnlyKeyValueStore&lt;K, ValueAndTimestamp&lt;VOut&gt;&gt;&gt; storeQueryParams = StoreQueryParameters.fromNameAndType(queryableStoreName, QueryableStoreTypes.timestampedKeyValueStore());
 ReadOnlyKeyValueStore&lt;K, ValueAndTimestamp&lt;VOut&gt;&gt; localStore = streams.store(storeQueryParams);
 K key = "some-key";
 ValueAndTimestamp&lt;VOut&gt; aggForKey = localStore.get(key); // key must be local (application state is shared over all running Kafka Streams instances)
 </code></pre>
 For non-local keys, a custom RPC mechanism must be implemented using <a href="../KafkaStreams.html#metadataForAllStreamsClients()"><code>KafkaStreams.metadataForAllStreamsClients()</code></a> to query
 the value of the key on a parallel running instance of your Kafka Streams application.
 <p>
 For failure and recovery the store (which always will be of type <a href="../state/TimestampedKeyValueStore.html" title="interface in org.apache.kafka.streams.state"><code>TimestampedKeyValueStore</code></a>) will be backed by
 an internal changelog topic that will be created in Kafka.
 Therefore, the store name defined by the Materialized instance must be a valid Kafka topic name and cannot
 contain characters other than ASCII alphanumerics, '.', '_' and '-'.
 The changelog topic will be named "${applicationId}-${storeName}-changelog", where "applicationId" is
 user-specified in <a href="../StreamsConfig.html" title="class in org.apache.kafka.streams"><code>StreamsConfig</code></a> via parameter
 <a href="../StreamsConfig.html#APPLICATION_ID_CONFIG"><code>APPLICATION_ID_CONFIG</code></a>, "storeName" is a generated value, and
 "-changelog" is a fixed suffix.
 <p>
 You can retrieve all generated internal topic names via <a href="../Topology.html#describe()"><code>Topology.describe()</code></a>.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>initializer</code> - an <a href="Initializer.html" title="interface in org.apache.kafka.streams.kstream"><code>Initializer</code></a> that computes an initial intermediate aggregation
        result. Cannot be <code>null</code>.</dd>
<dt>Returns:</dt>
<dd>a <a href="KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> that contains "update" records with unmodified keys, and values that
 represent the latest (rolling) aggregate for each key</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aggregate(org.apache.kafka.streams.kstream.Initializer,org.apache.kafka.streams.kstream.Named)">
<h3>aggregate</h3>
<div class="member-signature"><span class="return-type"><a href="KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="CogroupedKStream.html" title="type parameter in CogroupedKStream">K</a>,<wbr><a href="CogroupedKStream.html" title="type parameter in CogroupedKStream">VAgg</a>&gt;</span>&nbsp;<span class="element-name">aggregate</span><wbr><span class="parameters">(<a href="Initializer.html" title="interface in org.apache.kafka.streams.kstream">Initializer</a>&lt;<a href="CogroupedKStream.html" title="type parameter in CogroupedKStream">VAgg</a>&gt;&nbsp;initializer,
 <a href="Named.html" title="class in org.apache.kafka.streams.kstream">Named</a>&nbsp;named)</span></div>
<div class="block">Aggregate the values of records in these streams by the grouped key.
 Records with <code>null</code> key or value are ignored.
 The result is written into a local <a href="../state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state"><code>KeyValueStore</code></a> (which is basically an ever-updating materialized view)
 that can be queried by the given store name in <code>materialized</code>.
 Furthermore, updates to the store are sent downstream into a <a href="KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> changelog stream.
 <p>
 To compute the aggregation the corresponding <a href="Aggregator.html" title="interface in org.apache.kafka.streams.kstream"><code>Aggregator</code></a> as specified in
 <a href="#cogroup(org.apache.kafka.streams.kstream.KGroupedStream,org.apache.kafka.streams.kstream.Aggregator)"><code>cogroup(...)</code></a> is used per input stream.
 The specified <a href="Initializer.html" title="interface in org.apache.kafka.streams.kstream"><code>Initializer</code></a> is applied once per key, directly before the first input record per key is
 processed to provide an initial intermediate aggregation result that is used to process the first record.
 The specified <a href="Named.html" title="class in org.apache.kafka.streams.kstream"><code>Named</code></a> is applied once to the processor combining the grouped streams.
 <p>
 Not all updates might get sent downstream, as an internal cache is used to deduplicate consecutive updates to the
 same key.
 The rate of propagated updates depends on your input data rate, the number of distinct keys, the number of
 parallel running Kafka Streams instances, and the <a href="../StreamsConfig.html" title="class in org.apache.kafka.streams"><code>configuration</code></a> parameters for
 <a href="../StreamsConfig.html#STATESTORE_CACHE_MAX_BYTES_CONFIG"><code>cache size</code></a>, and
 <a href="../StreamsConfig.html#COMMIT_INTERVAL_MS_CONFIG"><code>commit interval</code></a>.
 <p>
 To query the local <a href="../state/ReadOnlyKeyValueStore.html" title="interface in org.apache.kafka.streams.state"><code>ReadOnlyKeyValueStore</code></a> it must be obtained via
 <a href="../KafkaStreams.html#store(org.apache.kafka.streams.StoreQueryParameters)"><code>KafkaStreams#store(...)</code></a>:
 <pre><code>
 KafkaStreams streams = ... // some aggregation on value type double
 String queryableStoreName = "storeName" // the store name should be the name of the store as defined by the Materialized instance
 StoreQueryParameters&lt;ReadOnlyKeyValueStore&lt;K, ValueAndTimestamp&lt;VOut&gt;&gt;&gt; storeQueryParams = StoreQueryParameters.fromNameAndType(queryableStoreName, QueryableStoreTypes.timestampedKeyValueStore());
 ReadOnlyKeyValueStore&lt;K, ValueAndTimestamp&lt;VOut&gt;&gt; localStore = streams.store(storeQueryParams);
 K key = "some-key";
 ValueAndTimestamp&lt;VOut&gt; aggForKey = localStore.get(key); // key must be local (application state is shared over all running Kafka Streams instances)
 </code></pre>
 For non-local keys, a custom RPC mechanism must be implemented using <a href="../KafkaStreams.html#metadataForAllStreamsClients()"><code>KafkaStreams.metadataForAllStreamsClients()</code></a> to query
 the value of the key on a parallel running instance of your Kafka Streams application.
 <p>
 For failure and recovery the store (which always will be of type <a href="../state/TimestampedKeyValueStore.html" title="interface in org.apache.kafka.streams.state"><code>TimestampedKeyValueStore</code></a>) will be backed by
 an internal changelog topic that will be created in Kafka.
 Therefore, the store name defined by the Materialized instance must be a valid Kafka topic name and cannot
 contain characters other than ASCII alphanumerics, '.', '_' and '-'.
 The changelog topic will be named "${applicationId}-${storeName}-changelog", where "applicationId" is
 user-specified in <a href="../StreamsConfig.html" title="class in org.apache.kafka.streams"><code>StreamsConfig</code></a> via parameter
 <a href="../StreamsConfig.html#APPLICATION_ID_CONFIG"><code>APPLICATION_ID_CONFIG</code></a>, "storeName" is the provide store name defined
 in <code>Materialized</code>, and "-changelog" is a fixed suffix.
 <p>
 You can retrieve all generated internal topic names via <a href="../Topology.html#describe()"><code>Topology.describe()</code></a>.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>initializer</code> - an <a href="Initializer.html" title="interface in org.apache.kafka.streams.kstream"><code>Initializer</code></a> that computes an initial intermediate aggregation result. Cannot be <code>null</code>.</dd>
<dd><code>named</code> - name the processor. Cannot be <code>null</code>.</dd>
<dt>Returns:</dt>
<dd>a <a href="KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> that contains "update" records with unmodified keys, and values that
 represent the latest (rolling) aggregate for each key</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aggregate(org.apache.kafka.streams.kstream.Initializer,org.apache.kafka.streams.kstream.Materialized)">
<h3>aggregate</h3>
<div class="member-signature"><span class="return-type"><a href="KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="CogroupedKStream.html" title="type parameter in CogroupedKStream">K</a>,<wbr><a href="CogroupedKStream.html" title="type parameter in CogroupedKStream">VAgg</a>&gt;</span>&nbsp;<span class="element-name">aggregate</span><wbr><span class="parameters">(<a href="Initializer.html" title="interface in org.apache.kafka.streams.kstream">Initializer</a>&lt;<a href="CogroupedKStream.html" title="type parameter in CogroupedKStream">VAgg</a>&gt;&nbsp;initializer,
 <a href="Materialized.html" title="class in org.apache.kafka.streams.kstream">Materialized</a>&lt;<a href="CogroupedKStream.html" title="type parameter in CogroupedKStream">K</a>,<wbr><a href="CogroupedKStream.html" title="type parameter in CogroupedKStream">VAgg</a>,<wbr><a href="../state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state">KeyValueStore</a>&lt;org.apache.kafka.common.utils.Bytes,<wbr>byte[]&gt;&gt;&nbsp;materialized)</span></div>
<div class="block">Aggregate the values of records in these streams by the grouped key.
 Records with <code>null</code> key or value are ignored.
 The result is written into a local <a href="../state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state"><code>KeyValueStore</code></a> (which is basically an ever-updating materialized view)
 that can be queried by the given store name in <code>materialized</code>.
 Furthermore, updates to the store are sent downstream into a <a href="KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> changelog stream.
 <p>
 To compute the aggregation the corresponding <a href="Aggregator.html" title="interface in org.apache.kafka.streams.kstream"><code>Aggregator</code></a> as specified in
 <a href="#cogroup(org.apache.kafka.streams.kstream.KGroupedStream,org.apache.kafka.streams.kstream.Aggregator)"><code>cogroup(...)</code></a> is used per input stream.
 The specified <a href="Initializer.html" title="interface in org.apache.kafka.streams.kstream"><code>Initializer</code></a> is applied once per key, directly before the first input record per key is
 processed to provide an initial intermediate aggregation result that is used to process the first record.
 <p>
 Not all updates might get sent downstream, as an internal cache is used to deduplicate consecutive updates to the
 same key.
 The rate of propagated updates depends on your input data rate, the number of distinct keys, the number of
 parallel running Kafka Streams instances, and the <a href="../StreamsConfig.html" title="class in org.apache.kafka.streams"><code>configuration</code></a> parameters for
 <a href="../StreamsConfig.html#STATESTORE_CACHE_MAX_BYTES_CONFIG"><code>cache size</code></a>, and
 <a href="../StreamsConfig.html#COMMIT_INTERVAL_MS_CONFIG"><code>commit interval</code></a>.
 <p>
 To query the local <a href="../state/ReadOnlyKeyValueStore.html" title="interface in org.apache.kafka.streams.state"><code>ReadOnlyKeyValueStore</code></a> it must be obtained via
 <a href="../KafkaStreams.html#store(org.apache.kafka.streams.StoreQueryParameters)"><code>KafkaStreams#store(...)</code></a>:
 <pre><code>
 KafkaStreams streams = ... // some aggregation on value type double
 String queryableStoreName = "storeName" // the store name should be the name of the store as defined by the Materialized instance
 StoreQueryParameters&lt;ReadOnlyKeyValueStore&lt;K, ValueAndTimestamp&lt;VOut&gt;&gt;&gt; storeQueryParams = StoreQueryParameters.fromNameAndType(queryableStoreName, QueryableStoreTypes.timestampedKeyValueStore());
 ReadOnlyKeyValueStore&lt;K, ValueAndTimestamp&lt;VOut&gt;&gt; localStore = streams.store(storeQueryParams);
 K key = "some-key";
 ValueAndTimestamp&lt;VOut&gt; aggForKey = localStore.get(key); // key must be local (application state is shared over all running Kafka Streams instances)
 </code></pre>
 For non-local keys, a custom RPC mechanism must be implemented using <a href="../KafkaStreams.html#metadataForAllStreamsClients()"><code>KafkaStreams.metadataForAllStreamsClients()</code></a> to query
 the value of the key on a parallel running instance of your Kafka Streams application.
 <p>
 For failure and recovery the store (which always will be of type <a href="../state/TimestampedKeyValueStore.html" title="interface in org.apache.kafka.streams.state"><code>TimestampedKeyValueStore</code></a> -- regardless of what
 is specified in the parameter <code>materialized</code>) will be backed by an internal changelog topic that will be created in Kafka.
 Therefore, the store name defined by the Materialized instance must be a valid Kafka topic name and cannot
 contain characters other than ASCII alphanumerics, '.', '_' and '-'.
 The changelog topic will be named "${applicationId}-${storeName}-changelog", where "applicationId" is
 user-specified in <a href="../StreamsConfig.html" title="class in org.apache.kafka.streams"><code>StreamsConfig</code></a> via parameter
 <a href="../StreamsConfig.html#APPLICATION_ID_CONFIG"><code>APPLICATION_ID_CONFIG</code></a>, "storeName" is the provide store name defined
 in <code>Materialized</code>, and "-changelog" is a fixed suffix.
 <p>
 You can retrieve all generated internal topic names via <a href="../Topology.html#describe()"><code>Topology.describe()</code></a>.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>initializer</code> - an <a href="Initializer.html" title="interface in org.apache.kafka.streams.kstream"><code>Initializer</code></a> that computes an initial intermediate aggregation result. Cannot be <code>null</code>.</dd>
<dd><code>materialized</code> - an instance of <a href="Materialized.html" title="class in org.apache.kafka.streams.kstream"><code>Materialized</code></a> used to materialize a state store. Cannot be <code>null</code>.</dd>
<dt>Returns:</dt>
<dd>a <a href="KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> that contains "update" records with unmodified keys, and values that
 represent the latest (rolling) aggregate for each key</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aggregate(org.apache.kafka.streams.kstream.Initializer,org.apache.kafka.streams.kstream.Named,org.apache.kafka.streams.kstream.Materialized)">
<h3>aggregate</h3>
<div class="member-signature"><span class="return-type"><a href="KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="CogroupedKStream.html" title="type parameter in CogroupedKStream">K</a>,<wbr><a href="CogroupedKStream.html" title="type parameter in CogroupedKStream">VAgg</a>&gt;</span>&nbsp;<span class="element-name">aggregate</span><wbr><span class="parameters">(<a href="Initializer.html" title="interface in org.apache.kafka.streams.kstream">Initializer</a>&lt;<a href="CogroupedKStream.html" title="type parameter in CogroupedKStream">VAgg</a>&gt;&nbsp;initializer,
 <a href="Named.html" title="class in org.apache.kafka.streams.kstream">Named</a>&nbsp;named,
 <a href="Materialized.html" title="class in org.apache.kafka.streams.kstream">Materialized</a>&lt;<a href="CogroupedKStream.html" title="type parameter in CogroupedKStream">K</a>,<wbr><a href="CogroupedKStream.html" title="type parameter in CogroupedKStream">VAgg</a>,<wbr><a href="../state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state">KeyValueStore</a>&lt;org.apache.kafka.common.utils.Bytes,<wbr>byte[]&gt;&gt;&nbsp;materialized)</span></div>
<div class="block">Aggregate the values of records in these streams by the grouped key.
 Records with <code>null</code> key or value are ignored.
 The result is written into a local <a href="../state/KeyValueStore.html" title="interface in org.apache.kafka.streams.state"><code>KeyValueStore</code></a> (which is basically an ever-updating materialized view)
 that can be queried by the given store name in <code>materialized</code>.
 Furthermore, updates to the store are sent downstream into a <a href="KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> changelog stream.
 <p>
 To compute the aggregation the corresponding <a href="Aggregator.html" title="interface in org.apache.kafka.streams.kstream"><code>Aggregator</code></a> as specified in
 <a href="#cogroup(org.apache.kafka.streams.kstream.KGroupedStream,org.apache.kafka.streams.kstream.Aggregator)"><code>cogroup(...)</code></a> is used per input stream.
 The specified <a href="Initializer.html" title="interface in org.apache.kafka.streams.kstream"><code>Initializer</code></a> is applied once per key, directly before the first input record per key is
 processed to provide an initial intermediate aggregation result that is used to process the first record.
 The specified <a href="Named.html" title="class in org.apache.kafka.streams.kstream"><code>Named</code></a> is used to name the processor combining the grouped streams.
 <p>
 Not all updates might get sent downstream, as an internal cache is used to deduplicate consecutive updates to the
 same key.
 The rate of propagated updates depends on your input data rate, the number of distinct keys, the number of
 parallel running Kafka Streams instances, and the <a href="../StreamsConfig.html" title="class in org.apache.kafka.streams"><code>configuration</code></a> parameters for
 <a href="../StreamsConfig.html#STATESTORE_CACHE_MAX_BYTES_CONFIG"><code>cache size</code></a>, and
 <a href="../StreamsConfig.html#COMMIT_INTERVAL_MS_CONFIG"><code>commit interval</code></a>.
 <p>
 To query the local <a href="../state/ReadOnlyKeyValueStore.html" title="interface in org.apache.kafka.streams.state"><code>ReadOnlyKeyValueStore</code></a> it must be obtained via
 <a href="../KafkaStreams.html#store(org.apache.kafka.streams.StoreQueryParameters)"><code>KafkaStreams#store(...)</code></a>:
 <pre><code>
 KafkaStreams streams = ... // some aggregation on value type double
 String queryableStoreName = "storeName" // the store name should be the name of the store as defined by the Materialized instance
 StoreQueryParameters&lt;ReadOnlyKeyValueStore&lt;K, ValueAndTimestamp&lt;VOut&gt;&gt;&gt; storeQueryParams = StoreQueryParameters.fromNameAndType(queryableStoreName, QueryableStoreTypes.timestampedKeyValueStore());
 ReadOnlyKeyValueStore&lt;K, ValueAndTimestamp&lt;VOut&gt;&gt; localStore = streams.store(storeQueryParams);
 K key = "some-key";
 ValueAndTimestamp&lt;VOut&gt; aggForKey = localStore.get(key); // key must be local (application state is shared over all running Kafka Streams instances)
 </code></pre>
 For non-local keys, a custom RPC mechanism must be implemented using <a href="../KafkaStreams.html#metadataForAllStreamsClients()"><code>KafkaStreams.metadataForAllStreamsClients()</code></a> to query
 the value of the key on a parallel running instance of your Kafka Streams application.
 <p>
 For failure and recovery the store (which always will be of type <a href="../state/TimestampedKeyValueStore.html" title="interface in org.apache.kafka.streams.state"><code>TimestampedKeyValueStore</code></a> -- regardless of what
 is specified in the parameter <code>materialized</code>) will be backed by an internal changelog topic that will be created in Kafka.
 Therefore, the store name defined by the Materialized instance must be a valid Kafka topic name and cannot
 contain characters other than ASCII alphanumerics, '.', '_' and '-'.
 The changelog topic will be named "${applicationId}-${storeName}-changelog", where "applicationId" is
 user-specified in <a href="../StreamsConfig.html" title="class in org.apache.kafka.streams"><code>StreamsConfig</code></a> via parameter
 <a href="../StreamsConfig.html#APPLICATION_ID_CONFIG"><code>APPLICATION_ID_CONFIG</code></a>, "storeName" is the provide store name defined
 in <code>Materialized</code>, and "-changelog" is a fixed suffix.
 <p>
 You can retrieve all generated internal topic names via <a href="../Topology.html#describe()"><code>Topology.describe()</code></a>.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>initializer</code> - an <a href="Initializer.html" title="interface in org.apache.kafka.streams.kstream"><code>Initializer</code></a> that computes an initial intermediate aggregation result. Cannot be <code>null</code>.</dd>
<dd><code>materialized</code> - an instance of <a href="Materialized.html" title="class in org.apache.kafka.streams.kstream"><code>Materialized</code></a> used to materialize a state store. Cannot be <code>null</code>.</dd>
<dd><code>named</code> - name the processors. Cannot be <code>null</code>.</dd>
<dt>Returns:</dt>
<dd>a <a href="KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> that contains "update" records with unmodified keys, and values that
 represent the latest (rolling) aggregate for each key</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="windowedBy(org.apache.kafka.streams.kstream.Windows)">
<h3>windowedBy</h3>
<div class="member-signature"><span class="type-parameters">&lt;W extends <a href="Window.html" title="class in org.apache.kafka.streams.kstream">Window</a>&gt;</span>
<span class="return-type"><a href="TimeWindowedCogroupedKStream.html" title="interface in org.apache.kafka.streams.kstream">TimeWindowedCogroupedKStream</a>&lt;<a href="CogroupedKStream.html" title="type parameter in CogroupedKStream">K</a>,<wbr><a href="CogroupedKStream.html" title="type parameter in CogroupedKStream">VAgg</a>&gt;</span>&nbsp;<span class="element-name">windowedBy</span><wbr><span class="parameters">(<a href="Windows.html" title="class in org.apache.kafka.streams.kstream">Windows</a>&lt;W&gt;&nbsp;windows)</span></div>
<div class="block">Create a new <a href="TimeWindowedCogroupedKStream.html" title="interface in org.apache.kafka.streams.kstream"><code>TimeWindowedCogroupedKStream</code></a> instance that can be used to perform windowed
 aggregations.</div>
<dl class="notes">
<dt>Type Parameters:</dt>
<dd><code>W</code> - the window type</dd>
<dt>Parameters:</dt>
<dd><code>windows</code> - the specification of the aggregation <a href="Windows.html" title="class in org.apache.kafka.streams.kstream"><code>Windows</code></a></dd>
<dt>Returns:</dt>
<dd>an instance of <a href="TimeWindowedCogroupedKStream.html" title="interface in org.apache.kafka.streams.kstream"><code>TimeWindowedCogroupedKStream</code></a></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="windowedBy(org.apache.kafka.streams.kstream.SlidingWindows)">
<h3>windowedBy</h3>
<div class="member-signature"><span class="return-type"><a href="TimeWindowedCogroupedKStream.html" title="interface in org.apache.kafka.streams.kstream">TimeWindowedCogroupedKStream</a>&lt;<a href="CogroupedKStream.html" title="type parameter in CogroupedKStream">K</a>,<wbr><a href="CogroupedKStream.html" title="type parameter in CogroupedKStream">VAgg</a>&gt;</span>&nbsp;<span class="element-name">windowedBy</span><wbr><span class="parameters">(<a href="SlidingWindows.html" title="class in org.apache.kafka.streams.kstream">SlidingWindows</a>&nbsp;windows)</span></div>
<div class="block">Create a new <a href="TimeWindowedCogroupedKStream.html" title="interface in org.apache.kafka.streams.kstream"><code>TimeWindowedCogroupedKStream</code></a> instance that can be used to perform sliding
 windowed aggregations.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>windows</code> - the specification of the aggregation <a href="SlidingWindows.html" title="class in org.apache.kafka.streams.kstream"><code>SlidingWindows</code></a></dd>
<dt>Returns:</dt>
<dd>an instance of <a href="TimeWindowedCogroupedKStream.html" title="interface in org.apache.kafka.streams.kstream"><code>TimeWindowedCogroupedKStream</code></a></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="windowedBy(org.apache.kafka.streams.kstream.SessionWindows)">
<h3>windowedBy</h3>
<div class="member-signature"><span class="return-type"><a href="SessionWindowedCogroupedKStream.html" title="interface in org.apache.kafka.streams.kstream">SessionWindowedCogroupedKStream</a>&lt;<a href="CogroupedKStream.html" title="type parameter in CogroupedKStream">K</a>,<wbr><a href="CogroupedKStream.html" title="type parameter in CogroupedKStream">VAgg</a>&gt;</span>&nbsp;<span class="element-name">windowedBy</span><wbr><span class="parameters">(<a href="SessionWindows.html" title="class in org.apache.kafka.streams.kstream">SessionWindows</a>&nbsp;windows)</span></div>
<div class="block">Create a new <a href="SessionWindowedCogroupedKStream.html" title="interface in org.apache.kafka.streams.kstream"><code>SessionWindowedCogroupedKStream</code></a> instance that can be used to perform session
 windowed aggregations.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>windows</code> - the specification of the aggregation <a href="SessionWindows.html" title="class in org.apache.kafka.streams.kstream"><code>SessionWindows</code></a></dd>
<dt>Returns:</dt>
<dd>an instance of <a href="SessionWindowedCogroupedKStream.html" title="interface in org.apache.kafka.streams.kstream"><code>SessionWindowedCogroupedKStream</code></a></dd>
</dl>
</section>
</li>
</ul>
</section>
</li>
</ul>
</section>
<!-- ========= END OF CLASS DATA ========= -->
</main>
</div>
</div>
</body>
</html>

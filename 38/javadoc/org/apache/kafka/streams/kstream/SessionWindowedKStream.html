<!DOCTYPE HTML>
<html lang="en">
<head>
<!-- Generated by javadoc (17) -->
<title>SessionWindowedKStream (kafka 3.8.1 API)</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="description" content="declaration: package: org.apache.kafka.streams.kstream, interface: SessionWindowedKStream">
<meta name="generator" content="javadoc/ClassWriterImpl">
<link rel="stylesheet" type="text/css" href="../../../../../stylesheet.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../../../../script-dir/jquery-ui.min.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../../../../jquery-ui.overrides.css" title="Style">
<script type="text/javascript" src="../../../../../script.js"></script>
<script type="text/javascript" src="../../../../../script-dir/jquery-3.5.1.min.js"></script>
<script type="text/javascript" src="../../../../../script-dir/jquery-ui.min.js"></script>
</head>
<body class="class-declaration-page">
<script type="text/javascript">var evenRowColor = "even-row-color";
var oddRowColor = "odd-row-color";
var tableTab = "table-tab";
var activeTableTab = "active-table-tab";
var pathtoroot = "../../../../../";
loadScripts(document, 'script');</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<div class="flex-box">
<header role="banner" class="flex-header">
<nav role="navigation">
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="top-nav" id="navbar-top">
<div class="skip-nav"><a href="#skip-navbar-top" title="Skip navigation links">Skip navigation links</a></div>
<ul id="navbar-top-firstrow" class="nav-list" title="Navigation">
<li><a href="../../../../../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="nav-bar-cell1-rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../../index-all.html">Index</a></li>
<li><a href="../../../../../help-doc.html#class">Help</a></li>
</ul>
</div>
<div class="sub-nav">
<div>
<ul class="sub-nav-list">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method-summary">Method</a></li>
</ul>
<ul class="sub-nav-list">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method-detail">Method</a></li>
</ul>
</div>
<div class="nav-list-search"><label for="search-input">SEARCH:</label>
<input type="text" id="search-input" value="search" disabled="disabled">
<input type="reset" id="reset-button" value="reset" disabled="disabled">
</div>
</div>
<!-- ========= END OF TOP NAVBAR ========= -->
<span class="skip-nav" id="skip-navbar-top"></span></nav>
</header>
<div class="flex-content">
<main role="main">
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="sub-title"><span class="package-label-in-type">Package</span>&nbsp;<a href="package-summary.html">org.apache.kafka.streams.kstream</a></div>
<h1 title="Interface SessionWindowedKStream" class="title">Interface SessionWindowedKStream&lt;K,<wbr>V&gt;</h1>
</div>
<section class="class-description" id="class-description">
<dl class="notes">
<dt>Type Parameters:</dt>
<dd><code>K</code> - Type of keys</dd>
<dd><code>V</code> - Type of values</dd>
</dl>
<hr>
<div class="type-signature"><span class="modifiers">public interface </span><span class="element-name type-name-label">SessionWindowedKStream&lt;K,<wbr>V&gt;</span></div>
<div class="block"><code>SessionWindowedKStream</code> is an abstraction of a <i>windowed</i> record stream of <a href="../KeyValue.html" title="class in org.apache.kafka.streams"><code>KeyValue</code></a> pairs.
 It is an intermediate representation after a grouping and windowing of a <a href="KStream.html" title="interface in org.apache.kafka.streams.kstream"><code>KStream</code></a> before an aggregation is
 applied to the new (partitioned) windows resulting in a windowed <a href="KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> (a <emph>windowed</emph>
 <code>KTable</code> is a <a href="KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> with key type <a href="Windowed.html" title="class in org.apache.kafka.streams.kstream"><code>Windowed<K></code></a>).
 <p>
 <a href="SessionWindows.html" title="class in org.apache.kafka.streams.kstream"><code>SessionWindows</code></a> are dynamic data driven windows.
 They have no fixed time boundaries, rather the size of the window is determined by the records.
 <p>
 The result is written into a local <a href="../state/SessionStore.html" title="interface in org.apache.kafka.streams.state"><code>SessionStore</code></a> (which is basically an ever-updating
 materialized view) that can be queried using the name provided in the <a href="Materialized.html" title="class in org.apache.kafka.streams.kstream"><code>Materialized</code></a> instance.
 Furthermore, updates to the store are sent downstream into a windowed <a href="KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> changelog stream, where
 "windowed" implies that the <a href="KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> key is a combined key of the original record key and a window ID.
 New events are added to sessions until their grace period ends (see <a href="SessionWindows.html#ofInactivityGapAndGrace(java.time.Duration,java.time.Duration)"><code>SessionWindows.ofInactivityGapAndGrace(Duration, Duration)</code></a>).
 <p>
 A <code>SessionWindowedKStream</code> must be obtained from a <a href="KGroupedStream.html" title="interface in org.apache.kafka.streams.kstream"><code>KGroupedStream</code></a> via
 <a href="KGroupedStream.html#windowedBy(org.apache.kafka.streams.kstream.SessionWindows)"><code>KGroupedStream.windowedBy(SessionWindows)</code></a>.</div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="KStream.html" title="interface in org.apache.kafka.streams.kstream"><code>KStream</code></a></li>
<li><a href="KGroupedStream.html" title="interface in org.apache.kafka.streams.kstream"><code>KGroupedStream</code></a></li>
<li><a href="SessionWindows.html" title="class in org.apache.kafka.streams.kstream"><code>SessionWindows</code></a></li>
</ul>
</dd>
</dl>
</section>
<section class="summary">
<ul class="summary-list">
<!-- ========== METHOD SUMMARY =========== -->
<li>
<section class="method-summary" id="method-summary">
<h2>Method Summary</h2>
<div id="method-summary-table">
<div class="table-tabs" role="tablist" aria-orientation="horizontal"><button id="method-summary-table-tab0" role="tab" aria-selected="true" aria-controls="method-summary-table.tabpanel" tabindex="0" onkeydown="switchTab(event)" onclick="show('method-summary-table', 'method-summary-table', 3)" class="active-table-tab">All Methods</button><button id="method-summary-table-tab2" role="tab" aria-selected="false" aria-controls="method-summary-table.tabpanel" tabindex="-1" onkeydown="switchTab(event)" onclick="show('method-summary-table', 'method-summary-table-tab2', 3)" class="table-tab">Instance Methods</button><button id="method-summary-table-tab3" role="tab" aria-selected="false" aria-controls="method-summary-table.tabpanel" tabindex="-1" onkeydown="switchTab(event)" onclick="show('method-summary-table', 'method-summary-table-tab3', 3)" class="table-tab">Abstract Methods</button></div>
<div id="method-summary-table.tabpanel" role="tabpanel">
<div class="summary-table three-column-summary" aria-labelledby="method-summary-table-tab0">
<div class="table-header col-first">Modifier and Type</div>
<div class="table-header col-second">Method</div>
<div class="table-header col-last">Description</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>&lt;VR&gt;&nbsp;<a href="KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="Windowed.html" title="class in org.apache.kafka.streams.kstream">Windowed</a>&lt;<a href="SessionWindowedKStream.html" title="type parameter in SessionWindowedKStream">K</a>&gt;,<wbr>VR&gt;</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#aggregate(org.apache.kafka.streams.kstream.Initializer,org.apache.kafka.streams.kstream.Aggregator,org.apache.kafka.streams.kstream.Merger)" class="member-name-link">aggregate</a><wbr>(<a href="Initializer.html" title="interface in org.apache.kafka.streams.kstream">Initializer</a>&lt;VR&gt;&nbsp;initializer,
 <a href="Aggregator.html" title="interface in org.apache.kafka.streams.kstream">Aggregator</a>&lt;? super <a href="SessionWindowedKStream.html" title="type parameter in SessionWindowedKStream">K</a>,<wbr>? super <a href="SessionWindowedKStream.html" title="type parameter in SessionWindowedKStream">V</a>,<wbr>VR&gt;&nbsp;aggregator,
 <a href="Merger.html" title="interface in org.apache.kafka.streams.kstream">Merger</a>&lt;? super <a href="SessionWindowedKStream.html" title="type parameter in SessionWindowedKStream">K</a>,<wbr>VR&gt;&nbsp;sessionMerger)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">Aggregate the values of records in this stream by the grouped key and defined sessions.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>&lt;VR&gt;&nbsp;<a href="KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="Windowed.html" title="class in org.apache.kafka.streams.kstream">Windowed</a>&lt;<a href="SessionWindowedKStream.html" title="type parameter in SessionWindowedKStream">K</a>&gt;,<wbr>VR&gt;</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#aggregate(org.apache.kafka.streams.kstream.Initializer,org.apache.kafka.streams.kstream.Aggregator,org.apache.kafka.streams.kstream.Merger,org.apache.kafka.streams.kstream.Materialized)" class="member-name-link">aggregate</a><wbr>(<a href="Initializer.html" title="interface in org.apache.kafka.streams.kstream">Initializer</a>&lt;VR&gt;&nbsp;initializer,
 <a href="Aggregator.html" title="interface in org.apache.kafka.streams.kstream">Aggregator</a>&lt;? super <a href="SessionWindowedKStream.html" title="type parameter in SessionWindowedKStream">K</a>,<wbr>? super <a href="SessionWindowedKStream.html" title="type parameter in SessionWindowedKStream">V</a>,<wbr>VR&gt;&nbsp;aggregator,
 <a href="Merger.html" title="interface in org.apache.kafka.streams.kstream">Merger</a>&lt;? super <a href="SessionWindowedKStream.html" title="type parameter in SessionWindowedKStream">K</a>,<wbr>VR&gt;&nbsp;sessionMerger,
 <a href="Materialized.html" title="class in org.apache.kafka.streams.kstream">Materialized</a>&lt;<a href="SessionWindowedKStream.html" title="type parameter in SessionWindowedKStream">K</a>,<wbr>VR,<wbr><a href="../state/SessionStore.html" title="interface in org.apache.kafka.streams.state">SessionStore</a>&lt;org.apache.kafka.common.utils.Bytes,<wbr>byte[]&gt;&gt;&nbsp;materialized)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">Aggregate the values of records in this stream by the grouped key and defined sessions.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>&lt;VR&gt;&nbsp;<a href="KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="Windowed.html" title="class in org.apache.kafka.streams.kstream">Windowed</a>&lt;<a href="SessionWindowedKStream.html" title="type parameter in SessionWindowedKStream">K</a>&gt;,<wbr>VR&gt;</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#aggregate(org.apache.kafka.streams.kstream.Initializer,org.apache.kafka.streams.kstream.Aggregator,org.apache.kafka.streams.kstream.Merger,org.apache.kafka.streams.kstream.Named)" class="member-name-link">aggregate</a><wbr>(<a href="Initializer.html" title="interface in org.apache.kafka.streams.kstream">Initializer</a>&lt;VR&gt;&nbsp;initializer,
 <a href="Aggregator.html" title="interface in org.apache.kafka.streams.kstream">Aggregator</a>&lt;? super <a href="SessionWindowedKStream.html" title="type parameter in SessionWindowedKStream">K</a>,<wbr>? super <a href="SessionWindowedKStream.html" title="type parameter in SessionWindowedKStream">V</a>,<wbr>VR&gt;&nbsp;aggregator,
 <a href="Merger.html" title="interface in org.apache.kafka.streams.kstream">Merger</a>&lt;? super <a href="SessionWindowedKStream.html" title="type parameter in SessionWindowedKStream">K</a>,<wbr>VR&gt;&nbsp;sessionMerger,
 <a href="Named.html" title="class in org.apache.kafka.streams.kstream">Named</a>&nbsp;named)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">Aggregate the values of records in this stream by the grouped key and defined sessions.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>&lt;VR&gt;&nbsp;<a href="KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="Windowed.html" title="class in org.apache.kafka.streams.kstream">Windowed</a>&lt;<a href="SessionWindowedKStream.html" title="type parameter in SessionWindowedKStream">K</a>&gt;,<wbr>VR&gt;</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#aggregate(org.apache.kafka.streams.kstream.Initializer,org.apache.kafka.streams.kstream.Aggregator,org.apache.kafka.streams.kstream.Merger,org.apache.kafka.streams.kstream.Named,org.apache.kafka.streams.kstream.Materialized)" class="member-name-link">aggregate</a><wbr>(<a href="Initializer.html" title="interface in org.apache.kafka.streams.kstream">Initializer</a>&lt;VR&gt;&nbsp;initializer,
 <a href="Aggregator.html" title="interface in org.apache.kafka.streams.kstream">Aggregator</a>&lt;? super <a href="SessionWindowedKStream.html" title="type parameter in SessionWindowedKStream">K</a>,<wbr>? super <a href="SessionWindowedKStream.html" title="type parameter in SessionWindowedKStream">V</a>,<wbr>VR&gt;&nbsp;aggregator,
 <a href="Merger.html" title="interface in org.apache.kafka.streams.kstream">Merger</a>&lt;? super <a href="SessionWindowedKStream.html" title="type parameter in SessionWindowedKStream">K</a>,<wbr>VR&gt;&nbsp;sessionMerger,
 <a href="Named.html" title="class in org.apache.kafka.streams.kstream">Named</a>&nbsp;named,
 <a href="Materialized.html" title="class in org.apache.kafka.streams.kstream">Materialized</a>&lt;<a href="SessionWindowedKStream.html" title="type parameter in SessionWindowedKStream">K</a>,<wbr>VR,<wbr><a href="../state/SessionStore.html" title="interface in org.apache.kafka.streams.state">SessionStore</a>&lt;org.apache.kafka.common.utils.Bytes,<wbr>byte[]&gt;&gt;&nbsp;materialized)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">Aggregate the values of records in this stream by the grouped key and defined sessions.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="Windowed.html" title="class in org.apache.kafka.streams.kstream">Windowed</a>&lt;<a href="SessionWindowedKStream.html" title="type parameter in SessionWindowedKStream">K</a>&gt;,<wbr><a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Long.html" title="class or interface in java.lang" class="external-link">Long</a>&gt;</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#count()" class="member-name-link">count</a>()</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">Count the number of records in this stream by the grouped key and defined sessions.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="Windowed.html" title="class in org.apache.kafka.streams.kstream">Windowed</a>&lt;<a href="SessionWindowedKStream.html" title="type parameter in SessionWindowedKStream">K</a>&gt;,<wbr><a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Long.html" title="class or interface in java.lang" class="external-link">Long</a>&gt;</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#count(org.apache.kafka.streams.kstream.Materialized)" class="member-name-link">count</a><wbr>(<a href="Materialized.html" title="class in org.apache.kafka.streams.kstream">Materialized</a>&lt;<a href="SessionWindowedKStream.html" title="type parameter in SessionWindowedKStream">K</a>,<wbr><a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Long.html" title="class or interface in java.lang" class="external-link">Long</a>,<wbr><a href="../state/SessionStore.html" title="interface in org.apache.kafka.streams.state">SessionStore</a>&lt;org.apache.kafka.common.utils.Bytes,<wbr>byte[]&gt;&gt;&nbsp;materialized)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">Count the number of records in this stream by the grouped key and defined sessions.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="Windowed.html" title="class in org.apache.kafka.streams.kstream">Windowed</a>&lt;<a href="SessionWindowedKStream.html" title="type parameter in SessionWindowedKStream">K</a>&gt;,<wbr><a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Long.html" title="class or interface in java.lang" class="external-link">Long</a>&gt;</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#count(org.apache.kafka.streams.kstream.Named)" class="member-name-link">count</a><wbr>(<a href="Named.html" title="class in org.apache.kafka.streams.kstream">Named</a>&nbsp;named)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">Count the number of records in this stream by the grouped key and defined sessions.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="Windowed.html" title="class in org.apache.kafka.streams.kstream">Windowed</a>&lt;<a href="SessionWindowedKStream.html" title="type parameter in SessionWindowedKStream">K</a>&gt;,<wbr><a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Long.html" title="class or interface in java.lang" class="external-link">Long</a>&gt;</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#count(org.apache.kafka.streams.kstream.Named,org.apache.kafka.streams.kstream.Materialized)" class="member-name-link">count</a><wbr>(<a href="Named.html" title="class in org.apache.kafka.streams.kstream">Named</a>&nbsp;named,
 <a href="Materialized.html" title="class in org.apache.kafka.streams.kstream">Materialized</a>&lt;<a href="SessionWindowedKStream.html" title="type parameter in SessionWindowedKStream">K</a>,<wbr><a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Long.html" title="class or interface in java.lang" class="external-link">Long</a>,<wbr><a href="../state/SessionStore.html" title="interface in org.apache.kafka.streams.state">SessionStore</a>&lt;org.apache.kafka.common.utils.Bytes,<wbr>byte[]&gt;&gt;&nbsp;materialized)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">Count the number of records in this stream by the grouped key and defined sessions.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="SessionWindowedKStream.html" title="interface in org.apache.kafka.streams.kstream">SessionWindowedKStream</a>&lt;<a href="SessionWindowedKStream.html" title="type parameter in SessionWindowedKStream">K</a>,<wbr><a href="SessionWindowedKStream.html" title="type parameter in SessionWindowedKStream">V</a>&gt;</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#emitStrategy(org.apache.kafka.streams.kstream.EmitStrategy)" class="member-name-link">emitStrategy</a><wbr>(<a href="EmitStrategy.html" title="interface in org.apache.kafka.streams.kstream">EmitStrategy</a>&nbsp;emitStrategy)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">Configure when the aggregated result will be emitted for <code>SessionWindowedKStream</code>.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="Windowed.html" title="class in org.apache.kafka.streams.kstream">Windowed</a>&lt;<a href="SessionWindowedKStream.html" title="type parameter in SessionWindowedKStream">K</a>&gt;,<wbr><a href="SessionWindowedKStream.html" title="type parameter in SessionWindowedKStream">V</a>&gt;</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#reduce(org.apache.kafka.streams.kstream.Reducer)" class="member-name-link">reduce</a><wbr>(<a href="Reducer.html" title="interface in org.apache.kafka.streams.kstream">Reducer</a>&lt;<a href="SessionWindowedKStream.html" title="type parameter in SessionWindowedKStream">V</a>&gt;&nbsp;reducer)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">Combine the values of records in this stream by the grouped key and defined sessions.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="Windowed.html" title="class in org.apache.kafka.streams.kstream">Windowed</a>&lt;<a href="SessionWindowedKStream.html" title="type parameter in SessionWindowedKStream">K</a>&gt;,<wbr><a href="SessionWindowedKStream.html" title="type parameter in SessionWindowedKStream">V</a>&gt;</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#reduce(org.apache.kafka.streams.kstream.Reducer,org.apache.kafka.streams.kstream.Materialized)" class="member-name-link">reduce</a><wbr>(<a href="Reducer.html" title="interface in org.apache.kafka.streams.kstream">Reducer</a>&lt;<a href="SessionWindowedKStream.html" title="type parameter in SessionWindowedKStream">V</a>&gt;&nbsp;reducer,
 <a href="Materialized.html" title="class in org.apache.kafka.streams.kstream">Materialized</a>&lt;<a href="SessionWindowedKStream.html" title="type parameter in SessionWindowedKStream">K</a>,<wbr><a href="SessionWindowedKStream.html" title="type parameter in SessionWindowedKStream">V</a>,<wbr><a href="../state/SessionStore.html" title="interface in org.apache.kafka.streams.state">SessionStore</a>&lt;org.apache.kafka.common.utils.Bytes,<wbr>byte[]&gt;&gt;&nbsp;materialized)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">Combine the values of records in this stream by the grouped key and defined sessions.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="Windowed.html" title="class in org.apache.kafka.streams.kstream">Windowed</a>&lt;<a href="SessionWindowedKStream.html" title="type parameter in SessionWindowedKStream">K</a>&gt;,<wbr><a href="SessionWindowedKStream.html" title="type parameter in SessionWindowedKStream">V</a>&gt;</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#reduce(org.apache.kafka.streams.kstream.Reducer,org.apache.kafka.streams.kstream.Named)" class="member-name-link">reduce</a><wbr>(<a href="Reducer.html" title="interface in org.apache.kafka.streams.kstream">Reducer</a>&lt;<a href="SessionWindowedKStream.html" title="type parameter in SessionWindowedKStream">V</a>&gt;&nbsp;reducer,
 <a href="Named.html" title="class in org.apache.kafka.streams.kstream">Named</a>&nbsp;named)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">Combine the values of records in this stream by the grouped key and defined sessions.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="Windowed.html" title="class in org.apache.kafka.streams.kstream">Windowed</a>&lt;<a href="SessionWindowedKStream.html" title="type parameter in SessionWindowedKStream">K</a>&gt;,<wbr><a href="SessionWindowedKStream.html" title="type parameter in SessionWindowedKStream">V</a>&gt;</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#reduce(org.apache.kafka.streams.kstream.Reducer,org.apache.kafka.streams.kstream.Named,org.apache.kafka.streams.kstream.Materialized)" class="member-name-link">reduce</a><wbr>(<a href="Reducer.html" title="interface in org.apache.kafka.streams.kstream">Reducer</a>&lt;<a href="SessionWindowedKStream.html" title="type parameter in SessionWindowedKStream">V</a>&gt;&nbsp;reducer,
 <a href="Named.html" title="class in org.apache.kafka.streams.kstream">Named</a>&nbsp;named,
 <a href="Materialized.html" title="class in org.apache.kafka.streams.kstream">Materialized</a>&lt;<a href="SessionWindowedKStream.html" title="type parameter in SessionWindowedKStream">K</a>,<wbr><a href="SessionWindowedKStream.html" title="type parameter in SessionWindowedKStream">V</a>,<wbr><a href="../state/SessionStore.html" title="interface in org.apache.kafka.streams.state">SessionStore</a>&lt;org.apache.kafka.common.utils.Bytes,<wbr>byte[]&gt;&gt;&nbsp;materialized)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">Combine the values of records in this stream by the grouped key and defined sessions.</div>
</div>
</div>
</div>
</div>
</section>
</li>
</ul>
</section>
<section class="details">
<ul class="details-list">
<!-- ============ METHOD DETAIL ========== -->
<li>
<section class="method-details" id="method-detail">
<h2>Method Details</h2>
<ul class="member-list">
<li>
<section class="detail" id="count()">
<h3>count</h3>
<div class="member-signature"><span class="return-type"><a href="KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="Windowed.html" title="class in org.apache.kafka.streams.kstream">Windowed</a>&lt;<a href="SessionWindowedKStream.html" title="type parameter in SessionWindowedKStream">K</a>&gt;,<wbr><a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Long.html" title="class or interface in java.lang" class="external-link">Long</a>&gt;</span>&nbsp;<span class="element-name">count</span>()</div>
<div class="block">Count the number of records in this stream by the grouped key and defined sessions.
 Note that sessions are generated on a per-key basis and records with different keys create independent sessions.
 Records with <code>null</code> key or value are ignored.
 <p>
 The result is written into a local <a href="../state/SessionStore.html" title="interface in org.apache.kafka.streams.state"><code>SessionStore</code></a> (which is basically an ever-updating materialized view).
 The default key serde from the config will be used for serializing the result.
 If a different serde is required then you should use <a href="#count(org.apache.kafka.streams.kstream.Materialized)"><code>count(Materialized)</code></a>.
 Furthermore, updates to the store are sent downstream into a <a href="KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> changelog stream.
 Not all updates might get sent downstream, as an internal cache is used to deduplicate consecutive updates to
 the same session and key.
 The rate of propagated updates depends on your input data rate, the number of distinct keys, the number of
 parallel running Kafka Streams instances, and the <a href="../StreamsConfig.html" title="class in org.apache.kafka.streams"><code>configuration</code></a> parameters for
 <a href="../StreamsConfig.html#STATESTORE_CACHE_MAX_BYTES_CONFIG"><code>cache size</code></a>, and
 <a href="../StreamsConfig.html#COMMIT_INTERVAL_MS_CONFIG"><code>commit interval</code></a>.
 <p>
 For failure and recovery the store will be backed by an internal changelog topic that will be created in Kafka.
 The changelog topic will be named "${applicationId}-${internalStoreName}-changelog", where "applicationId" is
 user-specified in <a href="../StreamsConfig.html" title="class in org.apache.kafka.streams"><code>StreamsConfig</code></a> via parameter
 <a href="../StreamsConfig.html#APPLICATION_ID_CONFIG"><code>APPLICATION_ID_CONFIG</code></a>, "internalStoreName" is an internal name
 and "-changelog" is a fixed suffix.
 Note that the internal store name may not be queryable through Interactive Queries.
 <p>
 You can retrieve all generated internal topic names via <a href="../Topology.html#describe()"><code>Topology.describe()</code></a>.</div>
<dl class="notes">
<dt>Returns:</dt>
<dd>a windowed <a href="KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> that contains "update" records with unmodified keys and <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Long.html" title="class or interface in java.lang" class="external-link"><code>Long</code></a> values
 that represent the latest (rolling) count (i.e., number of records) for each key per session</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="count(org.apache.kafka.streams.kstream.Named)">
<h3>count</h3>
<div class="member-signature"><span class="return-type"><a href="KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="Windowed.html" title="class in org.apache.kafka.streams.kstream">Windowed</a>&lt;<a href="SessionWindowedKStream.html" title="type parameter in SessionWindowedKStream">K</a>&gt;,<wbr><a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Long.html" title="class or interface in java.lang" class="external-link">Long</a>&gt;</span>&nbsp;<span class="element-name">count</span><wbr><span class="parameters">(<a href="Named.html" title="class in org.apache.kafka.streams.kstream">Named</a>&nbsp;named)</span></div>
<div class="block">Count the number of records in this stream by the grouped key and defined sessions.
 Note that sessions are generated on a per-key basis and records with different keys create independent sessions.
 Records with <code>null</code> key or value are ignored.
 <p>
 The result is written into a local <a href="../state/SessionStore.html" title="interface in org.apache.kafka.streams.state"><code>SessionStore</code></a> (which is basically an ever-updating materialized view).
 The default key serde from the config will be used for serializing the result.
 If a different serde is required then you should use <a href="#count(org.apache.kafka.streams.kstream.Named,org.apache.kafka.streams.kstream.Materialized)"><code>count(Named, Materialized)</code></a>.
 Furthermore, updates to the store are sent downstream into a <a href="KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> changelog stream.
 Not all updates might get sent downstream, as an internal cache is used to deduplicate consecutive updates to
 the same session and key.
 The rate of propagated updates depends on your input data rate, the number of distinct keys, the number of
 parallel running Kafka Streams instances, and the <a href="../StreamsConfig.html" title="class in org.apache.kafka.streams"><code>configuration</code></a> parameters for
 <a href="../StreamsConfig.html#STATESTORE_CACHE_MAX_BYTES_CONFIG"><code>cache size</code></a>, and
 <a href="../StreamsConfig.html#COMMIT_INTERVAL_MS_CONFIG"><code>commit interval</code></a>.
 <p>
 For failure and recovery the store will be backed by an internal changelog topic that will be created in Kafka.
 The changelog topic will be named "${applicationId}-${internalStoreName}-changelog", where "applicationId" is
 user-specified in <a href="../StreamsConfig.html" title="class in org.apache.kafka.streams"><code>StreamsConfig</code></a> via parameter
 <a href="../StreamsConfig.html#APPLICATION_ID_CONFIG"><code>APPLICATION_ID_CONFIG</code></a>, "internalStoreName" is an internal name
 and "-changelog" is a fixed suffix.
 Note that the internal store name may not be queryable through Interactive Queries.
 <p>
 You can retrieve all generated internal topic names via <a href="../Topology.html#describe()"><code>Topology.describe()</code></a>.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>named</code> - a <a href="Named.html" title="class in org.apache.kafka.streams.kstream"><code>Named</code></a> config used to name the processor in the topology. Cannot be <code>null</code>.</dd>
<dt>Returns:</dt>
<dd>a windowed <a href="KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> that contains "update" records with unmodified keys and <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Long.html" title="class or interface in java.lang" class="external-link"><code>Long</code></a> values
 that represent the latest (rolling) count (i.e., number of records) for each key per session</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="count(org.apache.kafka.streams.kstream.Materialized)">
<h3>count</h3>
<div class="member-signature"><span class="return-type"><a href="KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="Windowed.html" title="class in org.apache.kafka.streams.kstream">Windowed</a>&lt;<a href="SessionWindowedKStream.html" title="type parameter in SessionWindowedKStream">K</a>&gt;,<wbr><a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Long.html" title="class or interface in java.lang" class="external-link">Long</a>&gt;</span>&nbsp;<span class="element-name">count</span><wbr><span class="parameters">(<a href="Materialized.html" title="class in org.apache.kafka.streams.kstream">Materialized</a>&lt;<a href="SessionWindowedKStream.html" title="type parameter in SessionWindowedKStream">K</a>,<wbr><a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Long.html" title="class or interface in java.lang" class="external-link">Long</a>,<wbr><a href="../state/SessionStore.html" title="interface in org.apache.kafka.streams.state">SessionStore</a>&lt;org.apache.kafka.common.utils.Bytes,<wbr>byte[]&gt;&gt;&nbsp;materialized)</span></div>
<div class="block">Count the number of records in this stream by the grouped key and defined sessions.
 Note that sessions are generated on a per-key basis and records with different keys create independent sessions.
 Records with <code>null</code> key or value are ignored.
 <p>
 The result is written into a local <a href="../state/SessionStore.html" title="interface in org.apache.kafka.streams.state"><code>SessionStore</code></a> (which is basically an ever-updating materialized view)
 that can be queried using the name provided with <a href="Materialized.html" title="class in org.apache.kafka.streams.kstream"><code>Materialized</code></a>.
 Furthermore, updates to the store are sent downstream into a <a href="KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> changelog stream.
 <p>
 Not all updates might get sent downstream, as an internal cache will be used to deduplicate consecutive updates
 to the same window and key if caching is enabled on the <a href="Materialized.html" title="class in org.apache.kafka.streams.kstream"><code>Materialized</code></a> instance.
 When caching is enabled the rate of propagated updates depends on your input data rate, the number of distinct
 keys, the number of parallel running Kafka Streams instances, and the <a href="../StreamsConfig.html" title="class in org.apache.kafka.streams"><code>configuration</code></a>
 parameters for <a href="../StreamsConfig.html#STATESTORE_CACHE_MAX_BYTES_CONFIG"><code>cache size</code></a>, and
 <a href="../StreamsConfig.html#COMMIT_INTERVAL_MS_CONFIG"><code>commit interval</code></a>.
 <p>
 To query the local <a href="../state/SessionStore.html" title="interface in org.apache.kafka.streams.state"><code>SessionStore</code></a> it must be obtained via
 <a href="../KafkaStreams.html#store(org.apache.kafka.streams.StoreQueryParameters)"><code>KafkaStreams#store(...)</code></a>:
 <pre><code>
 KafkaStreams streams = ... // compute sum
 Sting queryableStoreName = ... // the queryableStoreName should be the name of the store as defined by the Materialized instance
 StoreQueryParameters&lt;ReadOnlySessionStore&lt;String, Long&gt;&gt; storeQueryParams = StoreQueryParameters.fromNameAndType(queryableStoreName, QueryableStoreTypes.sessionStore());
 ReadOnlySessionStore&lt;String,Long&gt; sessionStore = streams.store(storeQueryParams);
 String key = "some-key";
 KeyValueIterator&lt;Windowed&lt;String&gt;, Long&gt; sumForKeyForWindows = sessionStore.fetch(key); // key must be local (application state is shared over all running Kafka Streams instances)
 </code></pre>
 For non-local keys, a custom RPC mechanism must be implemented using <a href="../KafkaStreams.html#metadataForAllStreamsClients()"><code>KafkaStreams.metadataForAllStreamsClients()</code></a> to
 query the value of the key on a parallel running instance of your Kafka Streams application.
 <p>
 For failure and recovery the store will be backed by an internal changelog topic that will be created in Kafka.
 Therefore, the store name defined by the Materialized instance must be a valid Kafka topic name and cannot
 contain characters other than ASCII alphanumerics, '.', '_' and '-'.
 The changelog topic will be named "${applicationId}-${storeName}-changelog", where "applicationId" is
 user-specified in <a href="../StreamsConfig.html" title="class in org.apache.kafka.streams"><code>StreamsConfig</code></a> via parameter
 <a href="../StreamsConfig.html#APPLICATION_ID_CONFIG"><code>APPLICATION_ID_CONFIG</code></a>, "storeName" is the provide store name defined
 in <code>Materialized</code>, and "-changelog" is a fixed suffix.
 <p>
 You can retrieve all generated internal topic names via <a href="../Topology.html#describe()"><code>Topology.describe()</code></a>.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>materialized</code> - an instance of <a href="Materialized.html" title="class in org.apache.kafka.streams.kstream"><code>Materialized</code></a> used to materialize a state store. Cannot be <code>null</code>.
                      Note: the valueSerde will be automatically set to <a href="../../common/serialization/Serdes.html#Long()"><code>Serdes#Long()</code></a>
                      if there is no valueSerde provided</dd>
<dt>Returns:</dt>
<dd>a windowed <a href="KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> that contains "update" records with unmodified keys and <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Long.html" title="class or interface in java.lang" class="external-link"><code>Long</code></a> values
 that represent the latest (rolling) count (i.e., number of records) for each key per session</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="count(org.apache.kafka.streams.kstream.Named,org.apache.kafka.streams.kstream.Materialized)">
<h3>count</h3>
<div class="member-signature"><span class="return-type"><a href="KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="Windowed.html" title="class in org.apache.kafka.streams.kstream">Windowed</a>&lt;<a href="SessionWindowedKStream.html" title="type parameter in SessionWindowedKStream">K</a>&gt;,<wbr><a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Long.html" title="class or interface in java.lang" class="external-link">Long</a>&gt;</span>&nbsp;<span class="element-name">count</span><wbr><span class="parameters">(<a href="Named.html" title="class in org.apache.kafka.streams.kstream">Named</a>&nbsp;named,
 <a href="Materialized.html" title="class in org.apache.kafka.streams.kstream">Materialized</a>&lt;<a href="SessionWindowedKStream.html" title="type parameter in SessionWindowedKStream">K</a>,<wbr><a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Long.html" title="class or interface in java.lang" class="external-link">Long</a>,<wbr><a href="../state/SessionStore.html" title="interface in org.apache.kafka.streams.state">SessionStore</a>&lt;org.apache.kafka.common.utils.Bytes,<wbr>byte[]&gt;&gt;&nbsp;materialized)</span></div>
<div class="block">Count the number of records in this stream by the grouped key and defined sessions.
 Note that sessions are generated on a per-key basis and records with different keys create independent sessions.
 Records with <code>null</code> key or value are ignored.
 <p>
 The result is written into a local <a href="../state/SessionStore.html" title="interface in org.apache.kafka.streams.state"><code>SessionStore</code></a> (which is basically an ever-updating materialized view)
 that can be queried using the name provided with <a href="Materialized.html" title="class in org.apache.kafka.streams.kstream"><code>Materialized</code></a>.
 Furthermore, updates to the store are sent downstream into a <a href="KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> changelog stream.
 <p>
 Not all updates might get sent downstream, as an internal cache will be used to deduplicate consecutive updates
 to the same window and key if caching is enabled on the <a href="Materialized.html" title="class in org.apache.kafka.streams.kstream"><code>Materialized</code></a> instance.
 When caching is enabled the rate of propagated updates depends on your input data rate, the number of distinct
 keys, the number of parallel running Kafka Streams instances, and the <a href="../StreamsConfig.html" title="class in org.apache.kafka.streams"><code>configuration</code></a>
 parameters for <a href="../StreamsConfig.html#STATESTORE_CACHE_MAX_BYTES_CONFIG"><code>cache size</code></a>, and
 <a href="../StreamsConfig.html#COMMIT_INTERVAL_MS_CONFIG"><code>commit interval</code></a>.
 <p>
 To query the local <a href="../state/SessionStore.html" title="interface in org.apache.kafka.streams.state"><code>SessionStore</code></a> it must be obtained via
 <a href="../KafkaStreams.html#store(org.apache.kafka.streams.StoreQueryParameters)"><code>KafkaStreams#store(...)</code></a>:
 <pre><code>
 KafkaStreams streams = ... // compute sum
 Sting queryableStoreName = ... // the queryableStoreName should be the name of the store as defined by the Materialized instance
 StoreQueryParameters&lt;ReadOnlySessionStore&lt;String, Long&gt;&gt; storeQueryParams = StoreQueryParameters.fromNameAndType(queryableStoreName, QueryableStoreTypes.sessionStore());
 ReadOnlySessionStore&lt;String,Long&gt; sessionStore = streams.store(storeQueryParams);
 String key = "some-key";
 KeyValueIterator&lt;Windowed&lt;String&gt;, Long&gt; sumForKeyForWindows = sessionStore.fetch(key); // key must be local (application state is shared over all running Kafka Streams instances)
 </code></pre>
 For non-local keys, a custom RPC mechanism must be implemented using <a href="../KafkaStreams.html#metadataForAllStreamsClients()"><code>KafkaStreams.metadataForAllStreamsClients()</code></a> to
 query the value of the key on a parallel running instance of your Kafka Streams application.
 <p>
 For failure and recovery the store will be backed by an internal changelog topic that will be created in Kafka.
 Therefore, the store name defined by the Materialized instance must be a valid Kafka topic name and cannot
 contain characters other than ASCII alphanumerics, '.', '_' and '-'.
 The changelog topic will be named "${applicationId}-${storeName}-changelog", where "applicationId" is
 user-specified in <a href="../StreamsConfig.html" title="class in org.apache.kafka.streams"><code>StreamsConfig</code></a> via parameter
 <a href="../StreamsConfig.html#APPLICATION_ID_CONFIG"><code>APPLICATION_ID_CONFIG</code></a>, "storeName" is the provide store name defined
 in <code>Materialized</code>, and "-changelog" is a fixed suffix.
 <p>
 You can retrieve all generated internal topic names via <a href="../Topology.html#describe()"><code>Topology.describe()</code></a>.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>named</code> - a <a href="Named.html" title="class in org.apache.kafka.streams.kstream"><code>Named</code></a> config used to name the processor in the topology. Cannot be <code>null</code>.</dd>
<dd><code>materialized</code> - an instance of <a href="Materialized.html" title="class in org.apache.kafka.streams.kstream"><code>Materialized</code></a> used to materialize a state store. Cannot be <code>null</code>.
                      Note: the valueSerde will be automatically set to <a href="../../common/serialization/Serdes.html#Long()"><code>Serdes#Long()</code></a>
                      if there is no valueSerde provided</dd>
<dt>Returns:</dt>
<dd>a windowed <a href="KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> that contains "update" records with unmodified keys and <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Long.html" title="class or interface in java.lang" class="external-link"><code>Long</code></a> values
 that represent the latest (rolling) count (i.e., number of records) for each key per session</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aggregate(org.apache.kafka.streams.kstream.Initializer,org.apache.kafka.streams.kstream.Aggregator,org.apache.kafka.streams.kstream.Merger)">
<h3>aggregate</h3>
<div class="member-signature"><span class="type-parameters">&lt;VR&gt;</span>&nbsp;<span class="return-type"><a href="KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="Windowed.html" title="class in org.apache.kafka.streams.kstream">Windowed</a>&lt;<a href="SessionWindowedKStream.html" title="type parameter in SessionWindowedKStream">K</a>&gt;,<wbr>VR&gt;</span>&nbsp;<span class="element-name">aggregate</span><wbr><span class="parameters">(<a href="Initializer.html" title="interface in org.apache.kafka.streams.kstream">Initializer</a>&lt;VR&gt;&nbsp;initializer,
 <a href="Aggregator.html" title="interface in org.apache.kafka.streams.kstream">Aggregator</a>&lt;? super <a href="SessionWindowedKStream.html" title="type parameter in SessionWindowedKStream">K</a>,<wbr>? super <a href="SessionWindowedKStream.html" title="type parameter in SessionWindowedKStream">V</a>,<wbr>VR&gt;&nbsp;aggregator,
 <a href="Merger.html" title="interface in org.apache.kafka.streams.kstream">Merger</a>&lt;? super <a href="SessionWindowedKStream.html" title="type parameter in SessionWindowedKStream">K</a>,<wbr>VR&gt;&nbsp;sessionMerger)</span></div>
<div class="block">Aggregate the values of records in this stream by the grouped key and defined sessions.
 Note that sessions are generated on a per-key basis and records with different keys create independent sessions.
 Records with <code>null</code> key or value are ignored.
 Aggregating is a generalization of <a href="#reduce(org.apache.kafka.streams.kstream.Reducer)"><code>combining via reduce(...)</code></a> as it, for example,
 allows the result to have a different type than the input values.
 The result is written into a local <a href="../state/SessionStore.html" title="interface in org.apache.kafka.streams.state"><code>SessionStore</code></a> (which is basically an ever-updating materialized view).
 Furthermore, updates to the store are sent downstream into a <a href="KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> changelog stream.
 <p>
 The specified <a href="Initializer.html" title="interface in org.apache.kafka.streams.kstream"><code>Initializer</code></a> is applied directly before the first input record per session is processed to
 provide an initial intermediate aggregation result that is used to process the first record per session.
 The specified <a href="Aggregator.html" title="interface in org.apache.kafka.streams.kstream"><code>Aggregator</code></a> is applied for each input record and computes a new aggregate using the current
 aggregate (or for the very first record using the intermediate aggregation result provided via the
 <a href="Initializer.html" title="interface in org.apache.kafka.streams.kstream"><code>Initializer</code></a>) and the record's value.
 The specified <a href="Merger.html" title="interface in org.apache.kafka.streams.kstream"><code>Merger</code></a> is used to merge two existing sessions into one, i.e., when the windows overlap,
 they are merged into a single session and the old sessions are discarded.
 Thus, <code>aggregate()</code> can be used to compute aggregate functions like count (c.f. <a href="#count()"><code>count()</code></a>).
 <p>
 The default key and value serde from the config will be used for serializing the result.
 If a different serde is required then you should use
 <a href="#aggregate(org.apache.kafka.streams.kstream.Initializer,org.apache.kafka.streams.kstream.Aggregator,org.apache.kafka.streams.kstream.Merger,org.apache.kafka.streams.kstream.Materialized)"><code>aggregate(Initializer, Aggregator, Merger, Materialized)</code></a>.
 <p>
 Not all updates might get sent downstream, as an internal cache is used to deduplicate consecutive updates to
 the same window and key.
 The rate of propagated updates depends on your input data rate, the number of distinct keys, the number of
 parallel running Kafka Streams instances, and the <a href="../StreamsConfig.html" title="class in org.apache.kafka.streams"><code>configuration</code></a> parameters for
 <a href="../StreamsConfig.html#STATESTORE_CACHE_MAX_BYTES_CONFIG"><code>cache size</code></a>, and
 <a href="../StreamsConfig.html#COMMIT_INTERVAL_MS_CONFIG"><code>commit interval</code></a>.
 <p>
 For failure and recovery the store will be backed by an internal changelog topic that will be created in Kafka.
 The changelog topic will be named "${applicationId}-${internalStoreName}-changelog", where "applicationId" is
 user-specified in <a href="../StreamsConfig.html" title="class in org.apache.kafka.streams"><code>StreamsConfig</code></a> via parameter
 <a href="../StreamsConfig.html#APPLICATION_ID_CONFIG"><code>APPLICATION_ID_CONFIG</code></a>, "internalStoreName" is an internal name
 and "-changelog" is a fixed suffix.
 Note that the internal store name may not be queryable through Interactive Queries.
 <p>
 You can retrieve all generated internal topic names via <a href="../Topology.html#describe()"><code>Topology.describe()</code></a>.</div>
<dl class="notes">
<dt>Type Parameters:</dt>
<dd><code>VR</code> - the value type of the resulting <a href="KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a></dd>
<dt>Parameters:</dt>
<dd><code>initializer</code> - an <a href="Initializer.html" title="interface in org.apache.kafka.streams.kstream"><code>Initializer</code></a> that computes an initial intermediate aggregation result. Cannot be <code>null</code>.</dd>
<dd><code>aggregator</code> - an <a href="Aggregator.html" title="interface in org.apache.kafka.streams.kstream"><code>Aggregator</code></a> that computes a new aggregate result. Cannot be <code>null</code>.</dd>
<dd><code>sessionMerger</code> - a <a href="Merger.html" title="interface in org.apache.kafka.streams.kstream"><code>Merger</code></a> that combines two aggregation results. Cannot be <code>null</code>.</dd>
<dt>Returns:</dt>
<dd>a windowed <a href="KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> that contains "update" records with unmodified keys, and values that represent
 the latest (rolling) aggregate for each key per session</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aggregate(org.apache.kafka.streams.kstream.Initializer,org.apache.kafka.streams.kstream.Aggregator,org.apache.kafka.streams.kstream.Merger,org.apache.kafka.streams.kstream.Named)">
<h3>aggregate</h3>
<div class="member-signature"><span class="type-parameters">&lt;VR&gt;</span>&nbsp;<span class="return-type"><a href="KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="Windowed.html" title="class in org.apache.kafka.streams.kstream">Windowed</a>&lt;<a href="SessionWindowedKStream.html" title="type parameter in SessionWindowedKStream">K</a>&gt;,<wbr>VR&gt;</span>&nbsp;<span class="element-name">aggregate</span><wbr><span class="parameters">(<a href="Initializer.html" title="interface in org.apache.kafka.streams.kstream">Initializer</a>&lt;VR&gt;&nbsp;initializer,
 <a href="Aggregator.html" title="interface in org.apache.kafka.streams.kstream">Aggregator</a>&lt;? super <a href="SessionWindowedKStream.html" title="type parameter in SessionWindowedKStream">K</a>,<wbr>? super <a href="SessionWindowedKStream.html" title="type parameter in SessionWindowedKStream">V</a>,<wbr>VR&gt;&nbsp;aggregator,
 <a href="Merger.html" title="interface in org.apache.kafka.streams.kstream">Merger</a>&lt;? super <a href="SessionWindowedKStream.html" title="type parameter in SessionWindowedKStream">K</a>,<wbr>VR&gt;&nbsp;sessionMerger,
 <a href="Named.html" title="class in org.apache.kafka.streams.kstream">Named</a>&nbsp;named)</span></div>
<div class="block">Aggregate the values of records in this stream by the grouped key and defined sessions.
 Note that sessions are generated on a per-key basis and records with different keys create independent sessions.
 Records with <code>null</code> key or value are ignored.
 Aggregating is a generalization of <a href="#reduce(org.apache.kafka.streams.kstream.Reducer)"><code>combining via reduce(...)</code></a> as it, for example,
 allows the result to have a different type than the input values.
 The result is written into a local <a href="../state/SessionStore.html" title="interface in org.apache.kafka.streams.state"><code>SessionStore</code></a> (which is basically an ever-updating materialized view).
 Furthermore, updates to the store are sent downstream into a <a href="KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> changelog stream.
 <p>
 The specified <a href="Initializer.html" title="interface in org.apache.kafka.streams.kstream"><code>Initializer</code></a> is applied directly before the first input record per session is processed to
 provide an initial intermediate aggregation result that is used to process the first record per session.
 The specified <a href="Aggregator.html" title="interface in org.apache.kafka.streams.kstream"><code>Aggregator</code></a> is applied for each input record and computes a new aggregate using the current
 aggregate (or for the very first record using the intermediate aggregation result provided via the
 <a href="Initializer.html" title="interface in org.apache.kafka.streams.kstream"><code>Initializer</code></a>) and the record's value.
 The specified <a href="Merger.html" title="interface in org.apache.kafka.streams.kstream"><code>Merger</code></a> is used to merge two existing sessions into one, i.e., when the windows overlap,
 they are merged into a single session and the old sessions are discarded.
 Thus, <code>aggregate()</code> can be used to compute aggregate functions like count (c.f. <a href="#count()"><code>count()</code></a>).
 <p>
 The default key and value serde from the config will be used for serializing the result.
 If a different serde is required then you should use
 <a href="#aggregate(org.apache.kafka.streams.kstream.Initializer,org.apache.kafka.streams.kstream.Aggregator,org.apache.kafka.streams.kstream.Merger,org.apache.kafka.streams.kstream.Named,org.apache.kafka.streams.kstream.Materialized)"><code>aggregate(Initializer, Aggregator, Merger, Named, Materialized)</code></a>.
 <p>
 Not all updates might get sent downstream, as an internal cache is used to deduplicate consecutive updates to
 the same window and key.
 The rate of propagated updates depends on your input data rate, the number of distinct
 keys, the number of parallel running Kafka Streams instances, and the <a href="../StreamsConfig.html" title="class in org.apache.kafka.streams"><code>configuration</code></a>
 parameters for <a href="../StreamsConfig.html#STATESTORE_CACHE_MAX_BYTES_CONFIG"><code>cache size</code></a>, and
 <a href="../StreamsConfig.html#COMMIT_INTERVAL_MS_CONFIG"><code>commit interval</code></a>.
 <p>
 For failure and recovery the store will be backed by an internal changelog topic that will be created in Kafka.
 The changelog topic will be named "${applicationId}-${internalStoreName}-changelog", where "applicationId" is
 user-specified in <a href="../StreamsConfig.html" title="class in org.apache.kafka.streams"><code>StreamsConfig</code></a> via parameter
 <a href="../StreamsConfig.html#APPLICATION_ID_CONFIG"><code>APPLICATION_ID_CONFIG</code></a>, "internalStoreName" is an internal name
 and "-changelog" is a fixed suffix.
 Note that the internal store name may not be queryable through Interactive Queries.
 <p>
 You can retrieve all generated internal topic names via <a href="../Topology.html#describe()"><code>Topology.describe()</code></a>.</div>
<dl class="notes">
<dt>Type Parameters:</dt>
<dd><code>VR</code> - the value type of the resulting <a href="KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a></dd>
<dt>Parameters:</dt>
<dd><code>initializer</code> - an <a href="Initializer.html" title="interface in org.apache.kafka.streams.kstream"><code>Initializer</code></a> that computes an initial intermediate aggregation result. Cannot be <code>null</code>.</dd>
<dd><code>aggregator</code> - an <a href="Aggregator.html" title="interface in org.apache.kafka.streams.kstream"><code>Aggregator</code></a> that computes a new aggregate result. Cannot be <code>null</code>.</dd>
<dd><code>sessionMerger</code> - a <a href="Merger.html" title="interface in org.apache.kafka.streams.kstream"><code>Merger</code></a> that combines two aggregation results. Cannot be <code>null</code>.</dd>
<dd><code>named</code> - a <a href="Named.html" title="class in org.apache.kafka.streams.kstream"><code>Named</code></a> config used to name the processor in the topology. Cannot be <code>null</code>.</dd>
<dt>Returns:</dt>
<dd>a windowed <a href="KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> that contains "update" records with unmodified keys, and values that represent
 the latest (rolling) aggregate for each key per session</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aggregate(org.apache.kafka.streams.kstream.Initializer,org.apache.kafka.streams.kstream.Aggregator,org.apache.kafka.streams.kstream.Merger,org.apache.kafka.streams.kstream.Materialized)">
<h3>aggregate</h3>
<div class="member-signature"><span class="type-parameters">&lt;VR&gt;</span>&nbsp;<span class="return-type"><a href="KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="Windowed.html" title="class in org.apache.kafka.streams.kstream">Windowed</a>&lt;<a href="SessionWindowedKStream.html" title="type parameter in SessionWindowedKStream">K</a>&gt;,<wbr>VR&gt;</span>&nbsp;<span class="element-name">aggregate</span><wbr><span class="parameters">(<a href="Initializer.html" title="interface in org.apache.kafka.streams.kstream">Initializer</a>&lt;VR&gt;&nbsp;initializer,
 <a href="Aggregator.html" title="interface in org.apache.kafka.streams.kstream">Aggregator</a>&lt;? super <a href="SessionWindowedKStream.html" title="type parameter in SessionWindowedKStream">K</a>,<wbr>? super <a href="SessionWindowedKStream.html" title="type parameter in SessionWindowedKStream">V</a>,<wbr>VR&gt;&nbsp;aggregator,
 <a href="Merger.html" title="interface in org.apache.kafka.streams.kstream">Merger</a>&lt;? super <a href="SessionWindowedKStream.html" title="type parameter in SessionWindowedKStream">K</a>,<wbr>VR&gt;&nbsp;sessionMerger,
 <a href="Materialized.html" title="class in org.apache.kafka.streams.kstream">Materialized</a>&lt;<a href="SessionWindowedKStream.html" title="type parameter in SessionWindowedKStream">K</a>,<wbr>VR,<wbr><a href="../state/SessionStore.html" title="interface in org.apache.kafka.streams.state">SessionStore</a>&lt;org.apache.kafka.common.utils.Bytes,<wbr>byte[]&gt;&gt;&nbsp;materialized)</span></div>
<div class="block">Aggregate the values of records in this stream by the grouped key and defined sessions.
 Note that sessions are generated on a per-key basis and records with different keys create independent sessions.
 Records with <code>null</code> key or value are ignored.
 Aggregating is a generalization of <a href="#reduce(org.apache.kafka.streams.kstream.Reducer)"><code>combining via reduce(...)</code></a> as it, for example,
 allows the result to have a different type than the input values.
 The result is written into a local <a href="../state/SessionStore.html" title="interface in org.apache.kafka.streams.state"><code>SessionStore</code></a> (which is basically an ever-updating materialized view)
 that can be queried using the store name as provided with <a href="Materialized.html" title="class in org.apache.kafka.streams.kstream"><code>Materialized</code></a>.
 Furthermore, updates to the store are sent downstream into a <a href="KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> changelog stream.
 <p>
 The specified <a href="Initializer.html" title="interface in org.apache.kafka.streams.kstream"><code>Initializer</code></a> is applied directly before the first input record per session is processed to
 provide an initial intermediate aggregation result that is used to process the first record per session.
 The specified <a href="Aggregator.html" title="interface in org.apache.kafka.streams.kstream"><code>Aggregator</code></a> is applied for each input record and computes a new aggregate using the current
 aggregate (or for the very first record using the intermediate aggregation result provided via the
 <a href="Initializer.html" title="interface in org.apache.kafka.streams.kstream"><code>Initializer</code></a>) and the record's value.
 The specified <a href="Merger.html" title="interface in org.apache.kafka.streams.kstream"><code>Merger</code></a> is used to merge two existing sessions into one, i.e., when the windows overlap,
 they are merged into a single session and the old sessions are discarded.
 Thus, <code>aggregate()</code> can be used to compute aggregate functions like count (c.f. <a href="#count()"><code>count()</code></a>).
 <p>
 Not all updates might get sent downstream, as an internal cache is used to deduplicate consecutive updates to
 the same window and key if caching is enabled on the <a href="Materialized.html" title="class in org.apache.kafka.streams.kstream"><code>Materialized</code></a> instance.
 When caching is enabled the rate of propagated updates depends on your input data rate, the number of distinct keys, the number of
 parallel running Kafka Streams instances, and the <a href="../StreamsConfig.html" title="class in org.apache.kafka.streams"><code>configuration</code></a> parameters for
 <a href="../StreamsConfig.html#STATESTORE_CACHE_MAX_BYTES_CONFIG"><code>cache size</code></a>, and
 <a href="../StreamsConfig.html#COMMIT_INTERVAL_MS_CONFIG"><code>commit interval</code></a>.
 <p>
 To query the local <a href="../state/SessionStore.html" title="interface in org.apache.kafka.streams.state"><code>SessionStore</code></a> it must be obtained via
 <a href="../KafkaStreams.html#store(org.apache.kafka.streams.StoreQueryParameters)"><code>KafkaStreams#store(...)</code></a>:
 <pre><code>
 KafkaStreams streams = ... // some windowed aggregation on value type double
 Sting queryableStoreName = ... // the queryableStoreName should be the name of the store as defined by the Materialized instance
 StoreQueryParameters&lt;ReadOnlySessionStore&lt;String, Long&gt;&gt; storeQueryParams = StoreQueryParameters.fromNameAndType(queryableStoreName, QueryableStoreTypes.sessionStore());
 ReadOnlySessionStore&lt;String,Long&gt; sessionStore = streams.store(storeQueryParams);
 String key = "some-key";
 KeyValueIterator&lt;Windowed&lt;String&gt;, Long&gt; aggForKeyForSession = sessionStore.fetch(key); // key must be local (application state is shared over all running Kafka Streams instances)
 </code></pre>
 For non-local keys, a custom RPC mechanism must be implemented using <a href="../KafkaStreams.html#metadataForAllStreamsClients()"><code>KafkaStreams.metadataForAllStreamsClients()</code></a> to
 query the value of the key on a parallel running instance of your Kafka Streams application.
 <p>
 For failure and recovery the store will be backed by an internal changelog topic that will be created in Kafka.
 Therefore, the store name defined by the <a href="Materialized.html" title="class in org.apache.kafka.streams.kstream"><code>Materialized</code></a> instance must be a valid Kafka topic name and
 cannot contain characters other than ASCII alphanumerics, '.', '_' and '-'.
 The changelog topic will be named "${applicationId}-${storeName}-changelog", where "applicationId" is
 user-specified in <a href="../StreamsConfig.html" title="class in org.apache.kafka.streams"><code>StreamsConfig</code></a> via parameter
 <a href="../StreamsConfig.html#APPLICATION_ID_CONFIG"><code>APPLICATION_ID_CONFIG</code></a>, "storeName" is the
 provide store name defined in <a href="Materialized.html" title="class in org.apache.kafka.streams.kstream"><code>Materialized</code></a>, and "-changelog" is a fixed suffix.
 <p>
 You can retrieve all generated internal topic names via <a href="../Topology.html#describe()"><code>Topology.describe()</code></a>.</div>
<dl class="notes">
<dt>Type Parameters:</dt>
<dd><code>VR</code> - the value type of the resulting <a href="KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a></dd>
<dt>Parameters:</dt>
<dd><code>initializer</code> - an <a href="Initializer.html" title="interface in org.apache.kafka.streams.kstream"><code>Initializer</code></a> that computes an initial intermediate aggregation result. Cannot be <code>null</code>.</dd>
<dd><code>aggregator</code> - an <a href="Aggregator.html" title="interface in org.apache.kafka.streams.kstream"><code>Aggregator</code></a> that computes a new aggregate result. Cannot be <code>null</code>.</dd>
<dd><code>sessionMerger</code> - a <a href="Merger.html" title="interface in org.apache.kafka.streams.kstream"><code>Merger</code></a> that combines two aggregation results. Cannot be <code>null</code>.</dd>
<dd><code>materialized</code> - a <a href="Materialized.html" title="class in org.apache.kafka.streams.kstream"><code>Materialized</code></a> config used to materialize a state store. Cannot be <code>null</code>.</dd>
<dt>Returns:</dt>
<dd>a windowed <a href="KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> that contains "update" records with unmodified keys, and values that represent
 the latest (rolling) aggregate for each key per session</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aggregate(org.apache.kafka.streams.kstream.Initializer,org.apache.kafka.streams.kstream.Aggregator,org.apache.kafka.streams.kstream.Merger,org.apache.kafka.streams.kstream.Named,org.apache.kafka.streams.kstream.Materialized)">
<h3>aggregate</h3>
<div class="member-signature"><span class="type-parameters">&lt;VR&gt;</span>&nbsp;<span class="return-type"><a href="KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="Windowed.html" title="class in org.apache.kafka.streams.kstream">Windowed</a>&lt;<a href="SessionWindowedKStream.html" title="type parameter in SessionWindowedKStream">K</a>&gt;,<wbr>VR&gt;</span>&nbsp;<span class="element-name">aggregate</span><wbr><span class="parameters">(<a href="Initializer.html" title="interface in org.apache.kafka.streams.kstream">Initializer</a>&lt;VR&gt;&nbsp;initializer,
 <a href="Aggregator.html" title="interface in org.apache.kafka.streams.kstream">Aggregator</a>&lt;? super <a href="SessionWindowedKStream.html" title="type parameter in SessionWindowedKStream">K</a>,<wbr>? super <a href="SessionWindowedKStream.html" title="type parameter in SessionWindowedKStream">V</a>,<wbr>VR&gt;&nbsp;aggregator,
 <a href="Merger.html" title="interface in org.apache.kafka.streams.kstream">Merger</a>&lt;? super <a href="SessionWindowedKStream.html" title="type parameter in SessionWindowedKStream">K</a>,<wbr>VR&gt;&nbsp;sessionMerger,
 <a href="Named.html" title="class in org.apache.kafka.streams.kstream">Named</a>&nbsp;named,
 <a href="Materialized.html" title="class in org.apache.kafka.streams.kstream">Materialized</a>&lt;<a href="SessionWindowedKStream.html" title="type parameter in SessionWindowedKStream">K</a>,<wbr>VR,<wbr><a href="../state/SessionStore.html" title="interface in org.apache.kafka.streams.state">SessionStore</a>&lt;org.apache.kafka.common.utils.Bytes,<wbr>byte[]&gt;&gt;&nbsp;materialized)</span></div>
<div class="block">Aggregate the values of records in this stream by the grouped key and defined sessions.
 Note that sessions are generated on a per-key basis and records with different keys create independent sessions.
 Records with <code>null</code> key or value are ignored.
 Aggregating is a generalization of <a href="#reduce(org.apache.kafka.streams.kstream.Reducer)"><code>combining via reduce(...)</code></a> as it, for example,
 allows the result to have a different type than the input values.
 The result is written into a local <a href="../state/SessionStore.html" title="interface in org.apache.kafka.streams.state"><code>SessionStore</code></a> (which is basically an ever-updating materialized view)
 that can be queried using the store name as provided with <a href="Materialized.html" title="class in org.apache.kafka.streams.kstream"><code>Materialized</code></a>.
 Furthermore, updates to the store are sent downstream into a <a href="KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> changelog stream.
 <p>
 The specified <a href="Initializer.html" title="interface in org.apache.kafka.streams.kstream"><code>Initializer</code></a> is applied directly before the first input record per session is processed to
 provide an initial intermediate aggregation result that is used to process the first record per session.
 The specified <a href="Aggregator.html" title="interface in org.apache.kafka.streams.kstream"><code>Aggregator</code></a> is applied for each input record and computes a new aggregate using the current
 aggregate (or for the very first record using the intermediate aggregation result provided via the
 <a href="Initializer.html" title="interface in org.apache.kafka.streams.kstream"><code>Initializer</code></a>) and the record's value.
 The specified <a href="Merger.html" title="interface in org.apache.kafka.streams.kstream"><code>Merger</code></a> is used to merge two existing sessions into one, i.e., when the windows overlap,
 they are merged into a single session and the old sessions are discarded.
 Thus, <code>aggregate()</code> can be used to compute aggregate functions like count (c.f. <a href="#count()"><code>count()</code></a>).
 <p>
 Not all updates might get sent downstream, as an internal cache will be used to deduplicate consecutive updates
 to the same window and key if caching is enabled on the <a href="Materialized.html" title="class in org.apache.kafka.streams.kstream"><code>Materialized</code></a> instance.
 When caching is enabled the rate of propagated updates depends on your input data rate, the number of distinct
 keys, the number of parallel running Kafka Streams instances, and the <a href="../StreamsConfig.html" title="class in org.apache.kafka.streams"><code>configuration</code></a>
 parameters for <a href="../StreamsConfig.html#STATESTORE_CACHE_MAX_BYTES_CONFIG"><code>cache size</code></a>, and
 <a href="../StreamsConfig.html#COMMIT_INTERVAL_MS_CONFIG"><code>commit interval</code></a>.
 <p>
 To query the local <a href="../state/SessionStore.html" title="interface in org.apache.kafka.streams.state"><code>SessionStore</code></a> it must be obtained via
 <a href="../KafkaStreams.html#store(org.apache.kafka.streams.StoreQueryParameters)"><code>KafkaStreams#store(...)</code></a>:
 <pre><code>
 KafkaStreams streams = ... // some windowed aggregation on value type double
 Sting queryableStoreName = ... // the queryableStoreName should be the name of the store as defined by the Materialized instance
 StoreQueryParameters&lt;ReadOnlySessionStore&lt;String, Long&gt;&gt; storeQueryParams = StoreQueryParameters.fromNameAndType(queryableStoreName, QueryableStoreTypes.sessionStore());
 ReadOnlySessionStore&lt;String,Long&gt; sessionStore = streams.store(storeQueryParams);
 String key = "some-key";
 KeyValueIterator&lt;Windowed&lt;String&gt;, Long&gt; aggForKeyForSession = sessionStore.fetch(key); // key must be local (application state is shared over all running Kafka Streams instances)
 </code></pre>
 For non-local keys, a custom RPC mechanism must be implemented using <a href="../KafkaStreams.html#metadataForAllStreamsClients()"><code>KafkaStreams.metadataForAllStreamsClients()</code></a> to
 query the value of the key on a parallel running instance of your Kafka Streams application.
 <p>
 For failure and recovery the store will be backed by an internal changelog topic that will be created in Kafka.
 Therefore, the store name defined by the <a href="Materialized.html" title="class in org.apache.kafka.streams.kstream"><code>Materialized</code></a> instance must be a valid Kafka topic name and
 cannot contain characters other than ASCII alphanumerics, '.', '_' and '-'.
 The changelog topic will be named "${applicationId}-${storeName}-changelog", where "applicationId" is
 user-specified in <a href="../StreamsConfig.html" title="class in org.apache.kafka.streams"><code>StreamsConfig</code></a> via parameter
 <a href="../StreamsConfig.html#APPLICATION_ID_CONFIG"><code>APPLICATION_ID_CONFIG</code></a>, "storeName" is the
 provide store name defined in <a href="Materialized.html" title="class in org.apache.kafka.streams.kstream"><code>Materialized</code></a>, and "-changelog" is a fixed suffix.
 <p>
 You can retrieve all generated internal topic names via <a href="../Topology.html#describe()"><code>Topology.describe()</code></a>.</div>
<dl class="notes">
<dt>Type Parameters:</dt>
<dd><code>VR</code> - the value type of the resulting <a href="KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a></dd>
<dt>Parameters:</dt>
<dd><code>initializer</code> - an <a href="Initializer.html" title="interface in org.apache.kafka.streams.kstream"><code>Initializer</code></a> that computes an initial intermediate aggregation result. Cannot be <code>null</code>.</dd>
<dd><code>aggregator</code> - an <a href="Aggregator.html" title="interface in org.apache.kafka.streams.kstream"><code>Aggregator</code></a> that computes a new aggregate result. Cannot be <code>null</code>.</dd>
<dd><code>sessionMerger</code> - a <a href="Merger.html" title="interface in org.apache.kafka.streams.kstream"><code>Merger</code></a> that combines two aggregation results. Cannot be <code>null</code>.</dd>
<dd><code>named</code> - a <a href="Named.html" title="class in org.apache.kafka.streams.kstream"><code>Named</code></a> config used to name the processor in the topology. Cannot be <code>null</code>.</dd>
<dd><code>materialized</code> - a <a href="Materialized.html" title="class in org.apache.kafka.streams.kstream"><code>Materialized</code></a> config used to materialize a state store. Cannot be <code>null</code>.</dd>
<dt>Returns:</dt>
<dd>a windowed <a href="KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> that contains "update" records with unmodified keys, and values that represent
 the latest (rolling) aggregate for each key per session</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="reduce(org.apache.kafka.streams.kstream.Reducer)">
<h3>reduce</h3>
<div class="member-signature"><span class="return-type"><a href="KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="Windowed.html" title="class in org.apache.kafka.streams.kstream">Windowed</a>&lt;<a href="SessionWindowedKStream.html" title="type parameter in SessionWindowedKStream">K</a>&gt;,<wbr><a href="SessionWindowedKStream.html" title="type parameter in SessionWindowedKStream">V</a>&gt;</span>&nbsp;<span class="element-name">reduce</span><wbr><span class="parameters">(<a href="Reducer.html" title="interface in org.apache.kafka.streams.kstream">Reducer</a>&lt;<a href="SessionWindowedKStream.html" title="type parameter in SessionWindowedKStream">V</a>&gt;&nbsp;reducer)</span></div>
<div class="block">Combine the values of records in this stream by the grouped key and defined sessions.
 Note that sessions are generated on a per-key basis and records with different keys create independent sessions.
 Records with <code>null</code> key or value are ignored.
 Combining implies that the type of the aggregate result is the same as the type of the input value
 (c.f. <a href="#aggregate(org.apache.kafka.streams.kstream.Initializer,org.apache.kafka.streams.kstream.Aggregator,org.apache.kafka.streams.kstream.Merger)"><code>aggregate(Initializer, Aggregator, Merger)</code></a>).
 The result is written into a local <a href="../state/SessionStore.html" title="interface in org.apache.kafka.streams.state"><code>SessionStore</code></a> (which is basically an ever-updating materialized view).
 Furthermore, updates to the store are sent downstream into a <a href="KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> changelog stream.
 The default key and value serde from the config will be used for serializing the result.
 If a different serde is required then you should use <a href="#reduce(org.apache.kafka.streams.kstream.Reducer,org.apache.kafka.streams.kstream.Materialized)"><code>reduce(Reducer, Materialized)</code></a> .
 <p>
 The value of the first record per session initialized the session result.
 The specified <a href="Reducer.html" title="interface in org.apache.kafka.streams.kstream"><code>Reducer</code></a> is applied for each additional input record per session and computes a new
 aggregate using the current aggregate (first argument) and the record's value (second argument):
 <pre><code>
 // At the example of a Reducer&lt;Long&gt;
 new Reducer&lt;Long&gt;() {
   public Long apply(Long aggValue, Long currValue) {
     return aggValue + currValue;
   }
 }
 </code></pre>
 Thus, <code>reduce()</code> can be used to compute aggregate functions like sum, min, or max.
 <p>
 Not all updates might get sent downstream, as an internal cache is used to deduplicate consecutive updates to
 the same window and key.
 The rate of propagated updates depends on your input data rate, the number of distinct keys, the number of
 parallel running Kafka Streams instances, and the <a href="../StreamsConfig.html" title="class in org.apache.kafka.streams"><code>configuration</code></a> parameters for
 <a href="../StreamsConfig.html#STATESTORE_CACHE_MAX_BYTES_CONFIG"><code>cache size</code></a>, and
 <a href="../StreamsConfig.html#COMMIT_INTERVAL_MS_CONFIG"><code>commit interval</code></a>.
 <p>
 For failure and recovery the store will be backed by an internal changelog topic that will be created in Kafka.
 The changelog topic will be named "${applicationId}-${internalStoreName}-changelog", where "applicationId" is
 user-specified in <a href="../StreamsConfig.html" title="class in org.apache.kafka.streams"><code>StreamsConfig</code></a> via parameter
 <a href="../StreamsConfig.html#APPLICATION_ID_CONFIG"><code>APPLICATION_ID_CONFIG</code></a>, "internalStoreName" is an internal name
 and "-changelog" is a fixed suffix.
 <p>
 You can retrieve all generated internal topic names via <a href="../Topology.html#describe()"><code>Topology.describe()</code></a>.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>reducer</code> - a <a href="Reducer.html" title="interface in org.apache.kafka.streams.kstream"><code>Reducer</code></a> that computes a new aggregate result. Cannot be <code>null</code>.</dd>
<dt>Returns:</dt>
<dd>a windowed <a href="KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> that contains "update" records with unmodified keys, and values that represent
 the latest (rolling) aggregate for each key per session</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="reduce(org.apache.kafka.streams.kstream.Reducer,org.apache.kafka.streams.kstream.Named)">
<h3>reduce</h3>
<div class="member-signature"><span class="return-type"><a href="KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="Windowed.html" title="class in org.apache.kafka.streams.kstream">Windowed</a>&lt;<a href="SessionWindowedKStream.html" title="type parameter in SessionWindowedKStream">K</a>&gt;,<wbr><a href="SessionWindowedKStream.html" title="type parameter in SessionWindowedKStream">V</a>&gt;</span>&nbsp;<span class="element-name">reduce</span><wbr><span class="parameters">(<a href="Reducer.html" title="interface in org.apache.kafka.streams.kstream">Reducer</a>&lt;<a href="SessionWindowedKStream.html" title="type parameter in SessionWindowedKStream">V</a>&gt;&nbsp;reducer,
 <a href="Named.html" title="class in org.apache.kafka.streams.kstream">Named</a>&nbsp;named)</span></div>
<div class="block">Combine the values of records in this stream by the grouped key and defined sessions.
 Note that sessions are generated on a per-key basis and records with different keys create independent sessions.
 Records with <code>null</code> key or value are ignored.
 Combining implies that the type of the aggregate result is the same as the type of the input value
 (c.f. <a href="#aggregate(org.apache.kafka.streams.kstream.Initializer,org.apache.kafka.streams.kstream.Aggregator,org.apache.kafka.streams.kstream.Merger)"><code>aggregate(Initializer, Aggregator, Merger)</code></a>).
 The result is written into a local <a href="../state/SessionStore.html" title="interface in org.apache.kafka.streams.state"><code>SessionStore</code></a> (which is basically an ever-updating materialized view).
 Furthermore, updates to the store are sent downstream into a <a href="KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> changelog stream.
 The default key and value serde from the config will be used for serializing the result.
 If a different serde is required then you should use <a href="#reduce(org.apache.kafka.streams.kstream.Reducer,org.apache.kafka.streams.kstream.Named,org.apache.kafka.streams.kstream.Materialized)"><code>reduce(Reducer, Named, Materialized)</code></a> .
 <p>
 The value of the first record per session initialized the session result.
 The specified <a href="Reducer.html" title="interface in org.apache.kafka.streams.kstream"><code>Reducer</code></a> is applied for each additional input record per session and computes a new
 aggregate using the current aggregate (first argument) and the record's value (second argument):
 <pre><code>
 // At the example of a Reducer&lt;Long&gt;
 new Reducer&lt;Long&gt;() {
   public Long apply(Long aggValue, Long currValue) {
     return aggValue + currValue;
   }
 }
 </code></pre>
 Thus, <code>reduce()</code> can be used to compute aggregate functions like sum, min, or max.
 <p>
 Not all updates might get sent downstream, as an internal cache is used to deduplicate consecutive updates to
 the same window and key.
 The rate of propagated updates depends on your input data rate, the number of distinct keys, the number of
 parallel running Kafka Streams instances, and the <a href="../StreamsConfig.html" title="class in org.apache.kafka.streams"><code>configuration</code></a> parameters for
 <a href="../StreamsConfig.html#STATESTORE_CACHE_MAX_BYTES_CONFIG"><code>cache size</code></a>, and
 <a href="../StreamsConfig.html#COMMIT_INTERVAL_MS_CONFIG"><code>commit interval</code></a>.
 <p>
 For failure and recovery the store will be backed by an internal changelog topic that will be created in Kafka.
 The changelog topic will be named "${applicationId}-${internalStoreName}-changelog", where "applicationId" is
 user-specified in <a href="../StreamsConfig.html" title="class in org.apache.kafka.streams"><code>StreamsConfig</code></a> via parameter
 <a href="../StreamsConfig.html#APPLICATION_ID_CONFIG"><code>APPLICATION_ID_CONFIG</code></a>, "internalStoreName" is an internal name
 and "-changelog" is a fixed suffix.
 <p>
 You can retrieve all generated internal topic names via <a href="../Topology.html#describe()"><code>Topology.describe()</code></a>.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>reducer</code> - a <a href="Reducer.html" title="interface in org.apache.kafka.streams.kstream"><code>Reducer</code></a> that computes a new aggregate result. Cannot be <code>null</code>.</dd>
<dd><code>named</code> - a <a href="Named.html" title="class in org.apache.kafka.streams.kstream"><code>Named</code></a> config used to name the processor in the topology. Cannot be <code>null</code>.</dd>
<dt>Returns:</dt>
<dd>a windowed <a href="KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> that contains "update" records with unmodified keys, and values that represent
 the latest (rolling) aggregate for each key per session</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="reduce(org.apache.kafka.streams.kstream.Reducer,org.apache.kafka.streams.kstream.Materialized)">
<h3>reduce</h3>
<div class="member-signature"><span class="return-type"><a href="KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="Windowed.html" title="class in org.apache.kafka.streams.kstream">Windowed</a>&lt;<a href="SessionWindowedKStream.html" title="type parameter in SessionWindowedKStream">K</a>&gt;,<wbr><a href="SessionWindowedKStream.html" title="type parameter in SessionWindowedKStream">V</a>&gt;</span>&nbsp;<span class="element-name">reduce</span><wbr><span class="parameters">(<a href="Reducer.html" title="interface in org.apache.kafka.streams.kstream">Reducer</a>&lt;<a href="SessionWindowedKStream.html" title="type parameter in SessionWindowedKStream">V</a>&gt;&nbsp;reducer,
 <a href="Materialized.html" title="class in org.apache.kafka.streams.kstream">Materialized</a>&lt;<a href="SessionWindowedKStream.html" title="type parameter in SessionWindowedKStream">K</a>,<wbr><a href="SessionWindowedKStream.html" title="type parameter in SessionWindowedKStream">V</a>,<wbr><a href="../state/SessionStore.html" title="interface in org.apache.kafka.streams.state">SessionStore</a>&lt;org.apache.kafka.common.utils.Bytes,<wbr>byte[]&gt;&gt;&nbsp;materialized)</span></div>
<div class="block">Combine the values of records in this stream by the grouped key and defined sessions.
 Note that sessions are generated on a per-key basis and records with different keys create independent sessions.
 Records with <code>null</code> key or value are ignored.
 Combining implies that the type of the aggregate result is the same as the type of the input value
 (c.f. <a href="#aggregate(org.apache.kafka.streams.kstream.Initializer,org.apache.kafka.streams.kstream.Aggregator,org.apache.kafka.streams.kstream.Merger)"><code>aggregate(Initializer, Aggregator, Merger)</code></a>).
 The result is written into a local <a href="../state/SessionStore.html" title="interface in org.apache.kafka.streams.state"><code>SessionStore</code></a> (which is basically an ever-updating materialized view)
 that can be queried using the store name as provided with <a href="Materialized.html" title="class in org.apache.kafka.streams.kstream"><code>Materialized</code></a>.
 Furthermore, updates to the store are sent downstream into a <a href="KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> changelog stream.
 <p>
 The value of the first record per session initialized the session result.
 The specified <a href="Reducer.html" title="interface in org.apache.kafka.streams.kstream"><code>Reducer</code></a> is applied for each additional input record per session and computes a new
 aggregate using the current aggregate (first argument) and the record's value (second argument):
 <pre><code>
 // At the example of a Reducer&lt;Long&gt;
 new Reducer&lt;Long&gt;() {
   public Long apply(Long aggValue, Long currValue) {
     return aggValue + currValue;
   }
 }
 </code></pre>
 Thus, <code>reduce()</code> can be used to compute aggregate functions like sum, min, or max.
 <p>
 Not all updates might get sent downstream, as an internal cache will be used to deduplicate consecutive updates
 to the same window and key if caching is enabled on the <a href="Materialized.html" title="class in org.apache.kafka.streams.kstream"><code>Materialized</code></a> instance.
 When caching is enabled the rate of propagated updates depends on your input data rate, the number of distinct
 keys, the number of parallel running Kafka Streams instances, and the <a href="../StreamsConfig.html" title="class in org.apache.kafka.streams"><code>configuration</code></a>
 parameters for <a href="../StreamsConfig.html#STATESTORE_CACHE_MAX_BYTES_CONFIG"><code>cache size</code></a>, and
 <a href="../StreamsConfig.html#COMMIT_INTERVAL_MS_CONFIG"><code>commit interval</code></a>.
 <p>
 To query the local <a href="../state/SessionStore.html" title="interface in org.apache.kafka.streams.state"><code>SessionStore</code></a> it must be obtained via
 <a href="../KafkaStreams.html#store(org.apache.kafka.streams.StoreQueryParameters)"><code>KafkaStreams#store(...)</code></a>:
 <pre><code>
 KafkaStreams streams = ... // compute sum
 Sting queryableStoreName = ... // the queryableStoreName should be the name of the store as defined by the Materialized instance
 StoreQueryParameters&lt;ReadOnlySessionStore&lt;String, Long&gt;&gt; storeQueryParams = StoreQueryParameters.fromNameAndType(queryableStoreName, QueryableStoreTypes.sessionStore());
 ReadOnlySessionStore&lt;String,Long&gt; sessionStore = streams.store(storeQueryParams);
 String key = "some-key";
 KeyValueIterator&lt;Windowed&lt;String&gt;, Long&gt; sumForKeyForWindows = sessionStore.fetch(key); // key must be local (application state is shared over all running Kafka Streams instances)
 </code></pre>
 For non-local keys, a custom RPC mechanism must be implemented using <a href="../KafkaStreams.html#metadataForAllStreamsClients()"><code>KafkaStreams.metadataForAllStreamsClients()</code></a> to
 query the value of the key on a parallel running instance of your Kafka Streams application.
 <p>
 For failure and recovery the store will be backed by an internal changelog topic that will be created in Kafka.
 Therefore, the store name defined by the Materialized instance must be a valid Kafka topic name and cannot
 contain characters other than ASCII alphanumerics, '.', '_' and '-'.
 The changelog topic will be named "${applicationId}-${storeName}-changelog", where "applicationId" is
 user-specified in <a href="../StreamsConfig.html" title="class in org.apache.kafka.streams"><code>StreamsConfig</code></a> via parameter
 <a href="../StreamsConfig.html#APPLICATION_ID_CONFIG"><code>APPLICATION_ID_CONFIG</code></a>, "storeName" is the provide store name defined
 in <code>Materialized</code>, and "-changelog" is a fixed suffix.
 <p>
 You can retrieve all generated internal topic names via <a href="../Topology.html#describe()"><code>Topology.describe()</code></a>.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>reducer</code> - a <a href="Reducer.html" title="interface in org.apache.kafka.streams.kstream"><code>Reducer</code></a> that computes a new aggregate result. Cannot be <code>null</code>.</dd>
<dd><code>materialized</code> - a <a href="Materialized.html" title="class in org.apache.kafka.streams.kstream"><code>Materialized</code></a> config used to materialize a state store. Cannot be <code>null</code>.</dd>
<dt>Returns:</dt>
<dd>a windowed <a href="KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> that contains "update" records with unmodified keys, and values that represent
 the latest (rolling) aggregate for each key per session</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="reduce(org.apache.kafka.streams.kstream.Reducer,org.apache.kafka.streams.kstream.Named,org.apache.kafka.streams.kstream.Materialized)">
<h3>reduce</h3>
<div class="member-signature"><span class="return-type"><a href="KTable.html" title="interface in org.apache.kafka.streams.kstream">KTable</a>&lt;<a href="Windowed.html" title="class in org.apache.kafka.streams.kstream">Windowed</a>&lt;<a href="SessionWindowedKStream.html" title="type parameter in SessionWindowedKStream">K</a>&gt;,<wbr><a href="SessionWindowedKStream.html" title="type parameter in SessionWindowedKStream">V</a>&gt;</span>&nbsp;<span class="element-name">reduce</span><wbr><span class="parameters">(<a href="Reducer.html" title="interface in org.apache.kafka.streams.kstream">Reducer</a>&lt;<a href="SessionWindowedKStream.html" title="type parameter in SessionWindowedKStream">V</a>&gt;&nbsp;reducer,
 <a href="Named.html" title="class in org.apache.kafka.streams.kstream">Named</a>&nbsp;named,
 <a href="Materialized.html" title="class in org.apache.kafka.streams.kstream">Materialized</a>&lt;<a href="SessionWindowedKStream.html" title="type parameter in SessionWindowedKStream">K</a>,<wbr><a href="SessionWindowedKStream.html" title="type parameter in SessionWindowedKStream">V</a>,<wbr><a href="../state/SessionStore.html" title="interface in org.apache.kafka.streams.state">SessionStore</a>&lt;org.apache.kafka.common.utils.Bytes,<wbr>byte[]&gt;&gt;&nbsp;materialized)</span></div>
<div class="block">Combine the values of records in this stream by the grouped key and defined sessions.
 Note that sessions are generated on a per-key basis and records with different keys create independent sessions.
 Records with <code>null</code> key or value are ignored.
 Combining implies that the type of the aggregate result is the same as the type of the input value
 (c.f. <a href="#aggregate(org.apache.kafka.streams.kstream.Initializer,org.apache.kafka.streams.kstream.Aggregator,org.apache.kafka.streams.kstream.Merger)"><code>aggregate(Initializer, Aggregator, Merger)</code></a>).
 The result is written into a local <a href="../state/SessionStore.html" title="interface in org.apache.kafka.streams.state"><code>SessionStore</code></a> (which is basically an ever-updating materialized view)
 that can be queried using the store name as provided with <a href="Materialized.html" title="class in org.apache.kafka.streams.kstream"><code>Materialized</code></a>.
 Furthermore, updates to the store are sent downstream into a <a href="KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> changelog stream.
 <p>
 The value of the first record per session initialized the session result.
 The specified <a href="Reducer.html" title="interface in org.apache.kafka.streams.kstream"><code>Reducer</code></a> is applied for each additional input record per session and computes a new
 aggregate using the current aggregate (first argument) and the record's value (second argument):
 <pre><code>
 // At the example of a Reducer&lt;Long&gt;
 new Reducer&lt;Long&gt;() {
   public Long apply(Long aggValue, Long currValue) {
     return aggValue + currValue;
   }
 }
 </code></pre>
 Thus, <code>reduce()</code> can be used to compute aggregate functions like sum, min, or max.
 <p>
 Not all updates might get sent downstream, as an internal cache will be used to deduplicate consecutive updates
 to the same window and key if caching is enabled on the <a href="Materialized.html" title="class in org.apache.kafka.streams.kstream"><code>Materialized</code></a> instance.
 When caching is enabled the rate of propagated updates depends on your input data rate, the number of distinct
 keys, the number of parallel running Kafka Streams instances, and the <a href="../StreamsConfig.html" title="class in org.apache.kafka.streams"><code>configuration</code></a>
 parameters for <a href="../StreamsConfig.html#STATESTORE_CACHE_MAX_BYTES_CONFIG"><code>cache size</code></a>, and
 <a href="../StreamsConfig.html#COMMIT_INTERVAL_MS_CONFIG"><code>commit interval</code></a>.
 <p>
 To query the local <a href="../state/SessionStore.html" title="interface in org.apache.kafka.streams.state"><code>SessionStore</code></a> it must be obtained via
 <a href="../KafkaStreams.html#store(org.apache.kafka.streams.StoreQueryParameters)"><code>KafkaStreams.store(StoreQueryParameters)</code></a>  KafkaStreams#store(...)}:
 <pre><code>
 KafkaStreams streams = ... // compute sum
 Sting queryableStoreName = ... // the queryableStoreName should be the name of the store as defined by the Materialized instance
 StoreQueryParameters&lt;ReadOnlySessionStore&lt;String, Long&gt;&gt; storeQueryParams = StoreQueryParameters.fromNameAndType(QueryableStoreTypes.sessionStore());
 ReadOnlySessionStore&lt;String,Long&gt; sessionStore = streams.store(storeQueryParams);
 String key = "some-key";
 KeyValueIterator&lt;Windowed&lt;String&gt;, Long&gt; sumForKeyForWindows = sessionStore.fetch(key); // key must be local (application state is shared over all running Kafka Streams instances)
 </code></pre>
 For non-local keys, a custom RPC mechanism must be implemented using <a href="../KafkaStreams.html#metadataForAllStreamsClients()"><code>KafkaStreams.metadataForAllStreamsClients()</code></a> to
 query the value of the key on a parallel running instance of your Kafka Streams application.
 <p>
 For failure and recovery the store will be backed by an internal changelog topic that will be created in Kafka.
 Therefore, the store name defined by the Materialized instance must be a valid Kafka topic name and cannot
 contain characters other than ASCII alphanumerics, '.', '_' and '-'.
 The changelog topic will be named "${applicationId}-${storeName}-changelog", where "applicationId" is
 user-specified in <a href="../StreamsConfig.html" title="class in org.apache.kafka.streams"><code>StreamsConfig</code></a> via parameter
 <a href="../StreamsConfig.html#APPLICATION_ID_CONFIG"><code>APPLICATION_ID_CONFIG</code></a>, "storeName" is the provide store name defined
 in <a href="Materialized.html" title="class in org.apache.kafka.streams.kstream"><code>Materialized</code></a>, and "-changelog" is a fixed suffix.
 <p>
 You can retrieve all generated internal topic names via <a href="../Topology.html#describe()"><code>Topology.describe()</code></a>.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>reducer</code> - a <a href="Reducer.html" title="interface in org.apache.kafka.streams.kstream"><code>Reducer</code></a> that computes a new aggregate result. Cannot be <code>null</code>.</dd>
<dd><code>named</code> - a <a href="Named.html" title="class in org.apache.kafka.streams.kstream"><code>Named</code></a> config used to name the processor in the topology. Cannot be <code>null</code>.</dd>
<dd><code>materialized</code> - a <a href="Materialized.html" title="class in org.apache.kafka.streams.kstream"><code>Materialized</code></a> config used to materialize a state store. Cannot be <code>null</code>.</dd>
<dt>Returns:</dt>
<dd>a windowed <a href="KTable.html" title="interface in org.apache.kafka.streams.kstream"><code>KTable</code></a> that contains "update" records with unmodified keys, and values that represent
 the latest (rolling) aggregate for each key per session</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="emitStrategy(org.apache.kafka.streams.kstream.EmitStrategy)">
<h3>emitStrategy</h3>
<div class="member-signature"><span class="return-type"><a href="SessionWindowedKStream.html" title="interface in org.apache.kafka.streams.kstream">SessionWindowedKStream</a>&lt;<a href="SessionWindowedKStream.html" title="type parameter in SessionWindowedKStream">K</a>,<wbr><a href="SessionWindowedKStream.html" title="type parameter in SessionWindowedKStream">V</a>&gt;</span>&nbsp;<span class="element-name">emitStrategy</span><wbr><span class="parameters">(<a href="EmitStrategy.html" title="interface in org.apache.kafka.streams.kstream">EmitStrategy</a>&nbsp;emitStrategy)</span></div>
<div class="block">Configure when the aggregated result will be emitted for <code>SessionWindowedKStream</code>.
 <p>
 For example, for <a href="EmitStrategy.html#onWindowClose()"><code>EmitStrategy.onWindowClose()</code></a> strategy, the aggregated result for a
 window will only be emitted when the window closes. For <a href="EmitStrategy.html#onWindowUpdate()"><code>EmitStrategy.onWindowUpdate()</code></a>
 strategy, the aggregated result for a window will be emitted whenever there is an update to
 the window. Note that whether the result will be available in downstream also depends on
 cache policy.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>emitStrategy</code> - <a href="EmitStrategy.html" title="interface in org.apache.kafka.streams.kstream"><code>EmitStrategy</code></a> to configure when the aggregated result for a window will be emitted.</dd>
<dt>Returns:</dt>
<dd>a <code>SessionWindowedKStream</code> with <a href="EmitStrategy.html" title="interface in org.apache.kafka.streams.kstream"><code>EmitStrategy</code></a> configured.</dd>
</dl>
</section>
</li>
</ul>
</section>
</li>
</ul>
</section>
<!-- ========= END OF CLASS DATA ========= -->
</main>
</div>
</div>
</body>
</html>
